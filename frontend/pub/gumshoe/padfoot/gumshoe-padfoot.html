<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PADFOOT: The Case of the Whispering Stone</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Text&family=Cinzel&display=swap" rel="stylesheet">
    <!-- Google AdSense - Minimal Script -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3891410174900441"></script>
    <style>
        /*
         * PADFOOT Fantasy Terminal Aesthetics - Magical Enhancements:
         *
         * Mystical Effects: Enchanted parchment with magical runes and glowing text
         * Fantasy Particles: Floating magical energy particles and sparkles
         * Ancient Scrollbars: Ornate fantasy-themed scrollbars with magical glow
         * Mystical Typography: Enhanced text with magical shimmer and ancient script effects
         * Enchanted Animations: Floating runes, magical auras, and mystical transitions
         * Fantasy Atmosphere: Medieval fantasy ambiance with magical lighting
         *
         * Background Art: Fantasy realm landscape (./padfoot_background.png)
         * Menu Art: Enchanted tavern/inn (./padfoot_menu.png)
         * Particle Effects: Magical energy particles and mystical sparkles
         * Blend Modes: Advanced CSS blending for atmospheric depth
         *
         * All effects implemented with pure CSS and HTML5 techniques.
         * Fantasy aesthetic optimized for medieval/magical game theme.
         */

        :root {
            --background-color: #c5bba8; /* Aged paper background */
            --text-color: #2a1f1d; /* Brighter dark ink color for better readability */
            --glow-color: #a87e4a; /* Muted gold highlight */
            --border-color: #5a4a3a; /* Aged wood/leather */
            --accent-color: #7a5c3e; /* Darker brown for headers */
            --font-main: '"Crimson Text"', serif;
            --font-header: '"Cinzel"', serif;
        }
        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 20px;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            background-image: url('./padfoot_background.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            padding-top: 80px; /* Add space for navigation bar */
        }
        #terminal-container {
            width: 95%;
            max-width: 800px;
            height: 90vh;
            border: 6px solid var(--border-color);
            border-radius: 8px;
            background:
                /* Enchanted parchment base */
                radial-gradient(ellipse at center, rgba(253, 245, 230, 0.95) 0%, rgba(245, 235, 220, 0.9) 100%),
                /* Magical rune patterns */
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(168, 126, 74, 0.1) 2px,
                    rgba(168, 126, 74, 0.1) 4px
                ),
                repeating-linear-gradient(
                    -45deg,
                    transparent,
                    transparent 3px,
                    rgba(122, 92, 62, 0.08) 3px,
                    rgba(122, 92, 62, 0.08) 6px
                );
            background-size: 20px 20px, 40px 40px, 60px 60px;
            box-shadow:
                0 0 25px rgba(168, 126, 74, 0.4),
                0 0 50px rgba(122, 92, 62, 0.2),
                inset 0 0 20px rgba(0, 0, 0, 0.3),
                inset 0 0 40px rgba(168, 126, 74, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #terminal-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Floating magical runes */
                radial-gradient(circle at 20% 30%, rgba(168, 126, 74, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(122, 92, 62, 0.12) 0%, transparent 40%),
                radial-gradient(circle at 50% 20%, rgba(168, 126, 74, 0.08) 0%, transparent 40%);
            pointer-events: none;
            z-index: 5;
            animation: floating-runes 8s ease-in-out infinite;
        }

        #terminal-container::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Mystical aura */
                radial-gradient(ellipse at center, transparent 50%, rgba(168, 126, 74, 0.1) 100%),
                /* Magical shimmer */
                linear-gradient(
                    45deg,
                    transparent 30%,
                    rgba(168, 126, 74, 0.05) 50%,
                    transparent 70%
                );
            pointer-events: none;
            z-index: 10;
            animation: mystical-shimmer 6s ease-in-out infinite alternate;
        }

        @keyframes floating-runes {
            0%, 100% {
                transform: translateY(0) rotate(0deg);
                opacity: 0.6;
            }
            25% {
                transform: translateY(-10px) rotate(90deg);
                opacity: 0.8;
            }
            50% {
                transform: translateY(-5px) rotate(180deg);
                opacity: 0.7;
            }
            75% {
                transform: translateY(-15px) rotate(270deg);
                opacity: 0.9;
            }
        }

        @keyframes mystical-shimmer {
            0% { opacity: 0.3; filter: brightness(1) hue-rotate(0deg); }
            100% { opacity: 0.6; filter: brightness(1.2) hue-rotate(30deg); }
        }
        #header {
            padding: 15px 20px;
            border-bottom: 3px solid var(--border-color);
            text-align: center;
            font-family: var(--font-header);
            font-size: 28px;
            color: var(--accent-color);
            text-shadow:
                2px 2px 6px rgba(0, 0, 0, 0.9),
                0 0 12px var(--glow-color),
                0 0 18px rgba(168, 126, 74, 0.6),
                0 0 24px rgba(122, 92, 62, 0.4);
            flex-shrink: 0;
            background:
                linear-gradient(135deg, rgba(122, 92, 62, 0.1), rgba(90, 74, 58, 0.2)),
                radial-gradient(circle at 30% 70%, rgba(168, 126, 74, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 70% 30%, rgba(122, 92, 62, 0.15) 0%, transparent 50%);
            font-weight: bold;
            position: relative;
            letter-spacing: 1px;
            text-transform: uppercase;
            border-image: linear-gradient(90deg, rgba(168, 126, 74, 0.5), rgba(122, 92, 62, 0.5), rgba(168, 126, 74, 0.5)) 1;
        }

        #header::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image:
                linear-gradient(45deg, rgba(168, 126, 74, 0.1) 25%, transparent 25%, transparent 75%, rgba(168, 126, 74, 0.1) 75%),
                linear-gradient(-45deg, rgba(122, 92, 62, 0.08) 25%, transparent 25%, transparent 75%, rgba(122, 92, 62, 0.08) 75%);
            background-size: 30px 30px, 40px 40px;
            pointer-events: none;
            opacity: 0.4;
            animation: ancient-pattern 4s linear infinite;
        }

        @keyframes ancient-pattern {
            0% { background-position: 0 0, 0 0; }
            100% { background-position: 30px 30px, -40px -40px; }
        }
        #output {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            text-shadow: none;
            line-height: 1.5;
            white-space: pre-wrap;
            color: var(--text-color);
        }
        #input-line {
            display: flex;
            padding: 10px 20px;
            border-top: 2px solid var(--border-color);
            background-color: rgba(0,0,0,0.05);
            flex-shrink: 0;
            align-items: center;
        }
        #prompt { 
            color: var(--accent-color); 
            margin-right: 10px;
            font-weight: bold;
        }
        #input {
            background: none; border: none; color: var(--text-color);
            font-family: var(--font-main); font-size: 20px;
            width: 100%; outline: none; text-shadow: none;
        }
        #output::-webkit-scrollbar {
            width: 14px;
            background: linear-gradient(to bottom, rgba(122, 92, 62, 0.1), rgba(90, 74, 58, 0.2));
        }
        #output::-webkit-scrollbar-track {
            background: linear-gradient(to bottom, rgba(168, 126, 74, 0.1), rgba(122, 92, 62, 0.15));
            border-radius: 7px;
            margin: 2px;
            box-shadow: inset 0 0 5px rgba(168, 126, 74, 0.3);
        }
        #output::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, var(--glow-color), rgba(168, 126, 74, 0.8));
            border-radius: 7px;
            border: 1px solid rgba(122, 92, 62, 0.3);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        #output::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, rgba(168, 126, 74, 0.8), var(--glow-color));
            box-shadow: 0 0 8px rgba(168, 126, 74, 0.5);
        }
        .game-button {
            background-color: transparent;
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
            padding: 5px 10px;
            margin-left: 10px;
            font-family: var(--font-main);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 3px;
        }
        .game-button:hover { 
            background-color: var(--accent-color); 
            color: #fdf5e6; 
            text-shadow: none; 
        }
        
        /* Menu Overlay Styles */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            height: 100vh;
            width: 100vw;
            background:
                /* Enhanced menu art with magical blend mode */
                radial-gradient(ellipse at center, rgba(122, 92, 62, 0.8) 0%, rgba(90, 74, 58, 0.6) 40%, rgba(168, 126, 74, 0.1) 80%, rgba(122, 92, 62, 0.05) 100%),
                url('./padfoot_menu.png') center/cover;
            background-blend-mode: multiply, normal;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            position: relative;
        }

        .menu-overlay::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Magical energy streams */
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 4px,
                    rgba(168, 126, 74, 0.1) 4px,
                    rgba(168, 126, 74, 0.1) 8px
                ),
                /* Mystical interference */
                radial-gradient(circle at 25% 75%, rgba(122, 92, 62, 0.2) 0%, transparent 60%),
                radial-gradient(circle at 75% 25%, rgba(168, 126, 74, 0.15) 0%, transparent 60%);
            animation: magical-static 0.8s steps(12) infinite;
            pointer-events: none;
            opacity: 0.7;
        }

        .menu-overlay::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Magical energy waves */
                radial-gradient(circle at 30% 20%, rgba(168, 126, 74, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(122, 92, 62, 0.12) 0%, transparent 50%),
                linear-gradient(45deg, rgba(0, 0, 0, 0.3) 0%, transparent 40%, transparent 60%, rgba(0, 0, 0, 0.3) 100%);
            animation: magical-pulse 5s ease-in-out infinite alternate;
            pointer-events: none;
        }

        @keyframes magical-static {
            0%, 100% {
                transform: translate(0, 0);
                filter: hue-rotate(0deg) contrast(1);
            }
            25% {
                transform: translate(-1px, -1px);
                filter: hue-rotate(30deg) contrast(1.1);
            }
            50% {
                transform: translate(1px, -1px);
                filter: hue-rotate(60deg) contrast(0.9);
            }
            75% {
                transform: translate(-1px, 1px);
                filter: hue-rotate(90deg) contrast(1.05);
            }
        }

        @keyframes magical-pulse {
            0% { opacity: 0.6; filter: brightness(1); }
            100% { opacity: 0.9; filter: brightness(1.2) hue-rotate(20deg); }
        }

        /* Fantasy atmospheric particles */
        .menu-particles {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 5;
        }

        .menu-particles::before,
        .menu-particles::after,
        .menu-particles::nth-child(3)::before {
            content: '';
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: magical-particle 6s ease-in-out infinite;
        }

        .menu-particles::before {
            top: 20%;
            left: 15%;
            background: rgba(168, 126, 74, 0.8);
            box-shadow: 0 0 8px rgba(168, 126, 74, 0.6);
            animation-delay: 0s;
            animation-duration: 8s;
        }

        .menu-particles::after {
            top: 75%;
            right: 20%;
            background: rgba(122, 92, 62, 0.8);
            box-shadow: 0 0 8px rgba(122, 92, 62, 0.6);
            animation-delay: 2s;
            animation-duration: 7s;
        }

        .menu-particles::nth-child(3)::before {
            top: 50%;
            left: 80%;
            background: rgba(168, 126, 74, 0.8);
            box-shadow: 0 0 8px rgba(168, 126, 74, 0.6);
            animation-delay: 4s;
            animation-duration: 9s;
        }

        @keyframes magical-particle {
            0%, 100% {
                transform: translateY(0) translateX(0) scale(1);
                opacity: 0.4;
            }
            25% {
                transform: translateY(-30px) translateX(20px) scale(1.3);
                opacity: 0.8;
            }
            50% {
                transform: translateY(-20px) translateX(-15px) scale(0.9);
                opacity: 0.6;
            }
            75% {
                transform: translateY(-40px) translateX(25px) scale(1.5);
                opacity: 1;
            }
        }

        /* Add particles to menu overlay */
        .menu-overlay .menu-particles {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
        }
        
        .menu-content {
            text-align: center;
            padding: 40px;
        }
        
        .menu-title {
            font-family: var(--font-header);
            font-size: 48px;
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 8px var(--glow-color);
            margin-bottom: 10px;
            letter-spacing: 2px;
            font-weight: bold;
        }
        
        .menu-subtitle {
            font-family: var(--font-main);
            font-size: 24px;
            color: var(--text-color);
            margin-bottom: 40px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8), 0 0 4px var(--glow-color);
            font-weight: 600;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .menu-btn {
            background: rgba(253, 245, 230, 0.9);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 20px;
            padding: 15px 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 3px var(--glow-color);
            min-width: 200px;
            backdrop-filter: blur(5px);
        }
        
        .menu-btn:hover {
            background-color: var(--border-color);
            color: var(--background-color);
            text-shadow: none;
            box-shadow: 0 0 15px var(--glow-color);
        }
        
        .menu-overlay.hidden {
            display: none;
        }
        
        /* Music Controls */
        .music-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            display: flex;
            gap: 10px;
        }
        
        .music-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-main);
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .music-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: var(--accent-color);
        }
        
        .music-btn.muted {
            background: rgba(139, 0, 0, 0.7);
            border-color: #8b0000;
        }
        
        .npc-name {
            color: #8B4513; /* Saddle brown for fantasy theme */
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
    </style>
    
    <!-- Navigation removed for public access -->
</head>
<body>
    <!-- Navigation Container -->
    <div id="navigation-container"></div>

    <!-- Music Controls -->
    <div class="music-controls">
        <button id="mute-btn" class="music-btn" onclick="toggleMute()">
            <i class="fas fa-volume-mute"></i> Mute
        </button>
    </div>

    <div id="terminal-container">
        <!-- Menu Screen Overlay -->
        <div id="menu-overlay" class="menu-overlay">
            <div class="menu-particles"></div>
            <div class="menu-content">
                <h1 class="menu-title">PADFOOT</h1>
                <p class="menu-subtitle">The Case of the Glowing Orb</p>
                <div class="menu-buttons">
                    <button id="new-game-btn" class="menu-btn">NEW GAME</button>
                    <button id="load-game-btn" class="menu-btn">LOAD GAME</button>
                </div>
            </div>
        </div>
        
        <div id="header">
            PADFOOT
            <div id="money-display">0 gold coins</div>
        </div>
        <div id="output"></div>
        <div id="input-line">
            <span id="prompt">&gt;</span>
            <input type="text" id="input" autocomplete="off" autofocus>
        </div>
        <div id="controls" style="padding: 0 20px 10px; border-top: 1px solid var(--border-color); background-color: rgba(0,0,0,0.05); text-align: right;">
            <button id="new-game-btn" class="game-button">New Game</button>
            <button id="save-game-btn" class="game-button">Save</button>
            <button id="load-game-btn" class="game-button">Load</button>
        </div>
    </div>

    <script>
        // API Configuration
        const API_BASE_URL = (window.location.hostname === 'localhost') ? null : 'https://project-revelare-backend.liberatorgeminorum.workers.dev';
        
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const newGameBtn = document.getElementById('new-game-btn');
        const saveGameBtn = document.getElementById('save-game-btn');
        const loadGameBtn = document.getElementById('load-game-btn');

        const game = {
            state: {},
            init(isLoad = false) {
                if (!isLoad) {
                    this.state = this.getInitialState();
                }
                output.innerHTML = '';
                this.typeWriter(this.getIntroText(), 'normal');
                setTimeout(() => {
                    this.handleLook([]);
                    this.showStatus();
                }, 2500);
            },
            getInitialState() {
                const attributes = this.rollAttributes();
                const race = this.assignHiddenRace();
                const startingState = {
                    journal: [
                        "A new bounty just arrived by raven: 'The Whispering Stone.' Smells like dark magic and a heavy purse.",
                        "Client: Lady Elara Moonwhisper - elven scholar, claims her ancient artifact was stolen.",
                        "The 'stone' is actually a Whispering Stone that can commune with ancient spirits.",
                        "Three suspects: Her human rival scholar, her dwarven merchant contact, and a mysterious figure.",
                        "But something doesn't add up. The guards say it was destroyed in a magical accident. She says stolen.",
                        "The stone could unlock ancient knowledge - or unleash something that should stay buried.",
                        `You feel different today. Your ${race.trait} seems more pronounced. People look at you strangely.`
                    ],
                    health: 5,
                    inventory: [],
                    cash: 0,
                    discoveredCoords: new Set(['0,0,0']),
                    visitedLocations: new Set(['0,0,0']), // Track visited locations for map
                    playerPos: { x: 0, y: 0, z: 0 },
                    gameOver: false,
                    won: false,
                    equippedWeapon: "fists",
                    playerConditions: new Set(),
                    time: { hour: 20, minute: 0, day: 1 },
                    gameState: {
                        deskSearched: false,
                        chestOpened: false,
                        cratesSearched: false,
                        suspicionLevel: 0,
                        stressLevel: 0,
                        hunger: 0,
                        stolenItems: [],
                        // New systems for epic gameplay
                        sideQuests: [],
                        completedQuests: [],
                        skillPoints: 0,
                        skills: {
                            magic: 0,
                            combat: 0,
                            stealth: 0,
                            investigation: 0,
                            persuasion: 0,
                            intimidation: 0,
                            lockpicking: 0,
                            survival: 0
                        },
                        reputation: {
                            nobility: 0,
                            commoners: 0,
                            mages: 0,
                            thieves: 0
                        },
                        relationships: {},
                        discoveredSecrets: [],
                        timeBasedEvents: [],
                        worldState: {
                            weather: 'mystical',
                            temperature: 'temperate',
                            crimeLevel: 'moderate',
                            magicalActivity: 'high'
                        },
                        // New fantasy story elements
                        whisperingStoneCase: {
                            interviewedLadyElara: false,
                            interviewedScholar: false,
                            interviewedMerchant: false,
                            interviewedMysteriousFigure: false,
                            foundStone: false,
                            discoveredTruth: false,
                            trustLevel: 0, // -5 to +5, affects ending
                            evidenceCollected: [],
                            magicalAlignment: 0 // -5 to +5, affects magical ending
                        },
                        sideQuests: {
                            monsterHunt: { active: false, completed: false, trustGained: 0 },
                            treasureHunt: { active: false, completed: false, trustGained: 0 },
                            escortMission: { active: false, completed: false, trustGained: 0 },
                            informationGathering: { active: false, completed: false, trustGained: 0 }
                        },
                        // Consequential events that affect the world
                        consequentialEvents: {
                            helpedLicey: false,
                            bribedGuard: false,
                            stoleFromMerchant: false,
                            discoveredSecret: false,
                            angeredNoble: false,
                            savedChild: false,
                            exposedCorruption: false,
                            madeEnemy: false,
                            gainedAlly: false
                        },
                        // Random flavor NPCs that appear based on actions
                        flavorNPCs: {
                            streetUrchin: { appeared: false, helped: false, location: 'plaza' },
                            drunkNoble: { appeared: false, insulted: false, location: 'tavern' },
                            mysteriousStranger: { appeared: false, trusted: false, location: 'alley' },
                            cryingWidow: { appeared: false, comforted: false, location: 'graveyard' },
                            boastfulKnight: { appeared: false, challenged: false, location: 'barracks' }
                        },
                        relationships: {
                            ladyElara: 0,      // -5 to +5
                            scholar: 0,       // -5 to +5  
                            merchant: 0,      // -5 to +5
                            mysteriousFigure: 0, // -5 to +5
                            bartender: 0,     // -5 to +5
                            informant: 0      // -5 to +5
                        },
                        // Hidden race system
                        playerRace: race,
                        raceReputation: {
                            human: 0,    // -5 to +5
                            elf: 0,      // -5 to +5
                            dwarf: 0,    // -5 to +5
                            halfling: 0, // -5 to +5
                            gnome: 0,    // -5 to +5
                            orc: 0       // -5 to +5
                        }
                    },
                    attributes: attributes,
                    cash: this.rollStartingCash(attributes.luck),
                    debt: 0,
                    bills: {
                        guild_dues: { amount: 100, dueDay: 7, lateFee: 50, paid: false },
                        lodging: { amount: 50, dueDay: 4, lateFee: 20, paid: false }
                    },
                    contracts: this.generateContracts(),
                    activeContracts: [],
                    worldMap: JSON.parse(JSON.stringify(this.data.worldMap)),
                    npcStats: JSON.parse(JSON.stringify(this.data.npcStats)),
                };
                this.updateNpcs(startingState);
                return startingState;
            },
            rollAttributes() {
                const roll4d6DropLowest = () => {
                    let rolls = Array(4).fill(0).map(() => Math.floor(Math.random() * 6) + 1);
                    rolls.sort((a, b) => a - b);
                    return rolls.slice(1).reduce((sum, val) => sum + val, 0);
                };
                return {
                    constitution: roll4d6DropLowest(), perception: roll4d6DropLowest(),
                    dexterity: roll4d6DropLowest(), charisma: roll4d6DropLowest(),
                    strength: roll4d6DropLowest(), luck: roll4d6DropLowest(),
                };
            },
            rollStartingCash(luck) {
                 const luckModifier = Math.floor((luck - 10) / 2);
                 return Math.max(20, Math.floor(Math.random() * 151) + 50 + (luckModifier * 25));
            },

            assignHiddenRace() {
                const races = [
                    {
                        name: "Human",
                        trait: "versatility",
                        bonuses: { constitution: 1, charisma: 1 },
                        description: "You feel adaptable and well-rounded.",
                        racialAbility: "Adaptable - bonus to all social interactions",
                        clues: ["People seem comfortable around you", "You adapt easily to new situations", "You're treated as a neutral party"]
                    },
                    {
                        name: "Elf",
                        trait: "keen senses",
                        bonuses: { perception: 2, dexterity: 1 },
                        description: "Your senses are unusually sharp, and you move with grace.",
                        racialAbility: "Keen Senses - bonus to perception checks",
                        clues: ["You notice details others miss", "You move with unusual grace", "You have pointed ears"]
                    },
                    {
                        name: "Dwarf",
                        trait: "sturdy constitution",
                        bonuses: { constitution: 2, strength: 1 },
                        description: "You're unusually tough and strong for your size.",
                        racialAbility: "Sturdy - bonus to constitution and strength checks",
                        clues: ["You're shorter than most but very strong", "You have a thick beard", "You're naturally resistant to poison"]
                    },
                    {
                        name: "Halfling",
                        trait: "luck",
                        bonuses: { luck: 2, dexterity: 1 },
                        description: "You seem to have an unusual amount of good fortune.",
                        racialAbility: "Lucky - bonus to luck-based rolls",
                        clues: ["You're very small but surprisingly lucky", "You have hairy feet", "You're naturally stealthy"]
                    },
                    {
                        name: "Gnome",
                        trait: "magical affinity",
                        bonuses: { perception: 1, constitution: 1 },
                        description: "You have an unusual connection to magical forces.",
                        racialAbility: "Magical Affinity - bonus to magical interactions",
                        clues: ["Magic seems to respond to you", "You're small but very intelligent", "You have an unusual connection to nature"]
                    },
                    {
                        name: "Orc",
                        trait: "fierce strength",
                        bonuses: { strength: 2, constitution: 1 },
                        description: "You're unusually strong and intimidating.",
                        racialAbility: "Fierce - bonus to intimidation and combat",
                        clues: ["You're taller and stronger than most", "You have prominent tusks", "People seem intimidated by your presence"]
                    }
                ];
                
                const selectedRace = races[Math.floor(Math.random() * races.length)];
                
                return {
                    ...selectedRace,
                    discovered: false,
                    cluesFound: 0
                };
            },

            generateContracts() {
                const contractTypes = [
                    { type: "Monster Hunt", description: "Track down a dangerous creature", payout: 200, target_location: "forest" },
                    { type: "Treasure Hunt", description: "Find a lost artifact", payout: 150, target_location: "ruins" },
                    { type: "Escort Mission", description: "Protect a merchant caravan", payout: 300, target_location: "road" },
                    { type: "Information Gathering", description: "Collect intelligence on local threats", payout: 100, target_location: "tavern" }
                ];
                
                const contracts = [];
                for (let i = 0; i < 3; i++) {
                    const contract = JSON.parse(JSON.stringify(contractTypes[Math.floor(Math.random() * contractTypes.length)]));
                    contract.completed = false;
                    contracts.push(contract);
                }
                return contracts;
            },
            attributeCheck(attribute, difficultyClass) {
                const roll = Math.floor(Math.random() * 20) + 1;
                let modifier = Math.floor((this.state.attributes[attribute] - 10) / 2);
                if (this.state.playerConditions.has('limp')) modifier -= 2;
                if (this.state.playerConditions.has('concussion')) modifier -= 2;
                
                // Apply subtle racial bonuses
                const race = this.state.gameState.playerRace;
                if (race.name === "Elf" && attribute === "perception") modifier += 1;
                if (race.name === "Dwarf" && (attribute === "constitution" || attribute === "strength")) modifier += 1;
                if (race.name === "Halfling" && attribute === "luck") modifier += 1;
                if (race.name === "Gnome" && attribute === "perception") modifier += 1;
                if (race.name === "Orc" && (attribute === "strength" || attribute === "charisma")) modifier += 1;
                if (race.name === "Human" && attribute === "charisma") modifier += 1;
                
                const stressPenalty = -this.state.gameState.stressLevel;
                const hungerPenalty = -this.state.gameState.hunger;
                const total = roll + modifier + stressPenalty + hungerPenalty;
                const success = total >= difficultyClass;
                if (roll === 20) return { result: "critical_success", total };
                if (roll === 1) return { result: "critical_failure", total };
                return { result: success ? "success" : "failure", total };
            },
            advanceTime(minutes) {
                this.state.time.minute += minutes;
                const hoursPassed = Math.floor(this.state.time.minute / 60);
                if (hoursPassed > 0) {
                    this.state.time.minute %= 60;
                    for (let i = 0; i < hoursPassed; i++) {
                        this.state.time.hour++;
                        if (this.state.time.hour >= 24) {
                            this.state.time.hour = 0;
                            this.state.time.day++;
                            this.processDailyEvents();
                        }
                    }
                    this.updateNpcs(this.state);
                }
            },
            processDailyEvents() {
                this.outputText("The moon hangs high in the sky. A new day begins...", 'cyan');
                this.state.gameState.hunger = Math.min(3, this.state.gameState.hunger + 1);
                if (this.state.gameState.hunger > 1) {
                    this.outputText("Your stomach rumbles. You need to find some food.", 'warning');
                }
            },
            updateNpcs(state) {
                const currentHour = state.time.hour;
                for (const room of Object.values(state.worldMap)) {
                    if (room.npcs) room.npcs = {};
                }
                for (const [npcName, schedule] of Object.entries(this.data.npcSchedules)) {
                    for (const [[start, end], locationName] of Object.entries(schedule)) {
                        const isActive = (start <= end) ? (currentHour >= start && currentHour < end) : (currentHour >= start || currentHour < end);
                        if (isActive && locationName) {
                            for (const room of Object.values(state.worldMap)) {
                                if (room.name.toLowerCase().includes(locationName.toLowerCase())) {
                                    if (!room.npcs) room.npcs = {};
                                    // Get NPC description from npcDialogue or use a default
                                    const npcDesc = this.data.npcDialogue[npcName]?.greeting?.[0] || 
                                                   `A <span class="npc-name">${npcName.toLowerCase()}</span> is here.`;
                                    room.npcs[npcName] = npcDesc;
                                    break;
                                }
                            }
                        }
                    }
                }
            },
            takeDamage(amount) {
                this.state.health -= amount;
                this.outputText(`You take ${amount} damage! You have ${this.state.health} health left.`, 'fail');
                if (this.state.health <= 0) {
                    this.endGame("Your wounds are too great. Your vision fades to black...");
                }
            },
            endGame(message) {
                this.outputText("\n" + "=".repeat(60), 'fail');
                this.outputText(this.wrapText(message), 'fail');
                this.outputText("=".repeat(60) + "\n", 'fail');
                this.state.gameOver = true;
                input.disabled = true;
            },
            processCommand(commandStr) {
                if (this.state.gameOver) return;
                const echo = document.createElement('div');
                echo.style.color = 'var(--glow-color)';
                echo.textContent = `> ${commandStr}`;
                output.appendChild(echo);
                const words = commandStr.toLowerCase().split(' ').filter(w => w);
                const action = words[0];
                const args = words.slice(1);
                let minutesPassed = 0;
                // Check if we're in dialogue mode
                if (this.state.currentDialogue) {
                    // Only allow dialogue choices and quit/exit during dialogue
                    if (["1", "2", "3", "4", "5", "6", "7", "8", "9", "quit", "exit"].includes(action)) {
                        const commandMap = {
                            "1": () => this.handleDialogueChoice(1), "2": () => this.handleDialogueChoice(2), "3": () => this.handleDialogueChoice(3),
                            "4": () => this.handleDialogueChoice(4), "5": () => this.handleDialogueChoice(5), "6": () => this.handleDialogueChoice(6),
                            "7": () => this.handleDialogueChoice(7), "8": () => this.handleDialogueChoice(8), "9": () => this.handleDialogueChoice(9),
                            "quit": () => { this.state.gameOver = true; }, "exit": () => { this.state.gameOver = true; },
                        };
                        if (commandMap[action]) {
                            minutesPassed = commandMap[action].call(this, args) || 0;
                        } else {
                            this.outputText("Please choose a dialogue option (1-6) or type 'quit' to exit.");
                            minutesPassed = 0;
                        }
                    } else {
                        this.outputText("You're in the middle of a conversation. Choose a dialogue option (1-6) or type 'quit' to exit.");
                        minutesPassed = 0;
                    }
                } else {
                    // Normal command processing when not in dialogue
                    const commandMap = {
                        "go": this.handleGo, "n": () => this.handleGo(['n']), "s": () => this.handleGo(['s']),
                        "e": () => this.handleGo(['e']), "w": () => this.handleGo(['w']), "u": () => this.handleGo(['u']),
                        "d": () => this.handleGo(['d']), "take": this.handleTake, "get": this.handleTake,
                        "drop": this.handleDrop, "talk": this.handleTalk, "look": this.handleLook, "examine": this.handleLook,
                        "l": () => this.handleLook([]), "search": this.handleSearch, "use": this.handleUse, "give": this.handleGive,
                        "attack": this.handleAttack, "equip": this.handleEquip, "unequip": this.handleUnequip,
                        "read": this.handleRead, "drink": this.handleDrink, "think": this.handleThink,
                        "gamble": this.handleGamble, "contracts": this.handleContracts, "accept": this.handleAcceptContract,
                        "work": this.handleWorkContract, "buy": this.handleBuy, "bluff": this.handleBluff, "steal": this.handleSteal, "stolen": this.handleStolen, "break": this.handleBreakInto,
                        "pick": this.handlePickLock, "pry": this.handlePry, "cast": this.handleCast,
                        "investigate": this.handleInvestigate, "confront": this.handleConfront,
                        "play": this.handlePlayGame, "sing": this.handleSing, "story": this.handleTellStory,
                        "practice": this.handlePractice, "meditate": this.handleMeditate,
                        "status": this.showStatus, "inventory": this.showInventory, "i": this.showInventory,
                        "journal": this.handleThink, "map": this.handleMap, "hint": this.handleHint, "help": this.showHelp,
                        "save": this.handleSave, "load": this.handleLoad, "saves": this.handleSaves, "delete_save": this.handleDeleteSave,
                        "quit": () => { this.state.gameOver = true; }, "exit": () => { this.state.gameOver = true; },
                        // New epic systems
                        "quests": this.handleQuests, "sidequests": this.handleQuests,
                        "skills": this.handleSkills, "reputation": this.handleReputation,
                        "lore": this.handleLore, "library": this.handleLore,
                        "cast": this.handleCast, "spell": this.handleCast,
                        "enchant": this.handleEnchant, "disenchant": this.handleDisenchant,
                        "surveil": this.handleSurveil, "stakeout": this.handleStakeout,
                        "meditate": this.handleMeditate, "focus": this.handleFocus,
                        "scry": this.handleScry, "divine": this.handleDivine,
                    };
                    if (commandMap[action]) {
                        minutesPassed = commandMap[action].call(this, args) || 0;
                    } else {
                        this.outputText("You don't know how to do that. (Type 'help')");
                        minutesPassed = 1;
                    }
                }
                if (minutesPassed > 0) {
                    this.advanceTime(minutesPassed);
                    const { day, hour, minute } = this.state.time;
                    const timeStr = `Day ${day}, ${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                    this.outputText(`(${timeStr})`, 'grey');
                }
                if (this.state.won) {
                    this.endGame("YOU WIN! The City Watch storms the warehouse. You uncovered the conspiracy and found the stone. Well done, padfoot.");
                } else if (this.state.gameOver) {
                    this.endGame("YOUR TALE ENDS HERE. The city has claimed another. The cobblestones will remember your name, even if no one else does.");
                }
            },
            findTarget(targetWords, itemList) {
                const targetStr = targetWords.join(" ");
                if (!targetStr) return null;
                
                // First try exact match
                if (itemList.includes(targetStr)) return targetStr;
                
                // Try case-insensitive exact match
                const exactMatch = itemList.find(item => 
                    item.toLowerCase() === targetStr.toLowerCase()
                );
                if (exactMatch) return exactMatch;
                
                // Try partial word matching (case-insensitive)
                const found = itemList.filter(item => {
                    const normalizedItem = item.toLowerCase().replace(/_/g, ' ');
                    const normalizedTarget = targetStr.toLowerCase();
                    
                    // Check if all words in target are found in item
                    return targetWords.every(word => 
                        normalizedItem.includes(word.toLowerCase())
                    ) || normalizedItem.includes(normalizedTarget);
                });
                
                if (found.length === 1) return found[0];
                if (found.length > 1) { 
                    this.outputText(`Be more specific: ${found.join(', ')}?`); 
                    return null; 
                }
                return null;
            },
            getCurrentRoom() {
                const posKey = `${this.state.playerPos.x},${this.state.playerPos.y},${this.state.playerPos.z}`;
                return this.data.worldMap[posKey];
            },
            handleGo(args) {
                if (!args.length) { this.outputText("Go where?"); return 0; }
                const direction = args[0][0];
                const room = this.getCurrentRoom();
                const { x, y, z } = this.state.playerPos;
                if (room.exitsOverride && room.exitsOverride[direction]) {
                    const [nx, ny, nz] = room.exitsOverride[direction];
                    const nextPosKey = `${nx},${ny},${nz}`;
                    if (this.data.worldMap[nextPosKey]) {
                         if (this.data.worldMap[nextPosKey].locked) { this.outputText("The door is barred from the other side."); return 2; }
                         this.state.playerPos = { x: nx, y: ny, z: nz };
                         this.state.discoveredCoords.add(nextPosKey);
                         this.outputText(`You go ${direction.toUpperCase()}...`);
                         this.handleLook([]);
                         return 5;
                    }
                }
                const moves = { n: { y: y + 1 }, s: { y: y - 1 }, e: { x: x + 1 }, w: { x: x - 1 }, u: { z: z + 1 }, d: { z: z - 1 } };
                if (!moves[direction]) { this.outputText(`'${direction}' is not a valid direction.`); return 1; }
                const nextPos = { ...this.state.playerPos, ...moves[direction] };
                const nextPosKey = `${nextPos.x},${nextPos.y},${nextPos.z}`;
                if (this.data.worldMap[nextPosKey]) {
                    if (this.data.worldMap[nextPosKey].locked) { this.outputText("The door is barred."); return 2; }
                    this.state.playerPos = nextPos;
                    this.state.discoveredCoords.add(nextPosKey);
                    this.state.visitedLocations.add(nextPosKey); // Track visited location
                    
                    // Check for consequential events based on movement
                    this.checkConsequentialEvents(nextPosKey);
                    
                    this.outputText(`You go ${direction.toUpperCase()}...`);
                    this.handleLook([]);
                    return 5;
                } else { this.outputText("There's a solid wall that way."); return 1; }
            },
            
            // Check for consequential events based on location and actions
            checkConsequentialEvents(locationKey) {
                const room = this.data.worldMap[locationKey];
                if (!room) return;
                
                // Random flavor NPCs based on location and time
                const currentHour = this.state.time.hour;
                const roomName = room.name.toLowerCase();
                
                // Street Urchin in plaza during day
                if (roomName.includes('plaza') && currentHour >= 8 && currentHour <= 16 && 
                    !this.state.gameState.flavorNPCs.streetUrchin.appeared && Math.random() < 0.3) {
                    this.spawnFlavorNPC('streetUrchin', room);
                }
                
                // Drunk Noble in tavern at night
                if (roomName.includes('tavern') && currentHour >= 20 && 
                    !this.state.gameState.flavorNPCs.drunkNoble.appeared && Math.random() < 0.4) {
                    this.spawnFlavorNPC('drunkNoble', room);
                }
                
                // Mysterious Stranger in alleys
                if (roomName.includes('alley') && currentHour >= 22 && 
                    !this.state.gameState.flavorNPCs.mysteriousStranger.appeared && Math.random() < 0.2) {
                    this.spawnFlavorNPC('mysteriousStranger', room);
                }
                
                // Crying Widow in graveyard
                if (roomName.includes('graveyard') && currentHour >= 18 && 
                    !this.state.gameState.flavorNPCs.cryingWidow.appeared && Math.random() < 0.3) {
                    this.spawnFlavorNPC('cryingWidow', room);
                }
            },
            
            // Spawn flavor NPCs with consequential interactions
            spawnFlavorNPC(npcType, room) {
                const npc = this.state.gameState.flavorNPCs[npcType];
                npc.appeared = true;
                
                if (!room.npcs) room.npcs = {};
                
                switch (npcType) {
                    case 'streetUrchin':
                        room.npcs['street_urchin'] = "A dirty street urchin tugs at your cloak. 'Mister, spare a copper? I'm hungry...'";
                        this.outputText("\nA small street urchin approaches you, looking desperate.", 'yellow');
                        break;
                    case 'drunkNoble':
                        room.npcs['drunk_noble'] = "A well-dressed but clearly intoxicated noble slurs, 'You there! Do you know who I am?'";
                        this.outputText("\nA drunk noble stumbles toward you, clearly looking for trouble.", 'yellow');
                        break;
                    case 'mysteriousStranger':
                        room.npcs['mysterious_stranger'] = "A hooded figure steps from the shadows. 'You seek answers, do you not?'";
                        this.outputText("\nA mysterious figure emerges from the shadows.", 'yellow');
                        break;
                    case 'cryingWidow':
                        room.npcs['crying_widow'] = "A woman in black robes kneels by a grave, sobbing softly. 'My husband... why did they take him?'";
                        this.outputText("\nYou hear soft sobbing from a woman kneeling by a grave.", 'yellow');
                        break;
                }
            },
            
            handleLook(args = []) {
                const room = this.getCurrentRoom();
                if (!room) { this.outputText("You are lost in the ethereal plane. This should not be possible.", 'fail'); return 1; }
                if (args.length > 0) {
                    const searchSpace = [...(room.items || []), ...Object.keys(room.npcs || {}), ...(room.features || []), ...this.state.inventory];
                    const targetName = this.findTarget(args, searchSpace);
                    if (targetName) {
                        let desc = this.data.items[targetName]?.desc || this.data.features[targetName]?.desc || 
                                   this.data.npcDialogue[targetName]?.greeting?.[0] || `A <span class="npc-name">${targetName.toLowerCase()}</span> is here.`;
                        this.outputText(this.wrapText(desc));
                        return 2;
                    } else { this.outputText(`You see no '${args.join(' ')}' here.`); return 1; }
                }
                this.outputText(`--- ${room.name} ---`, 'header');
                this.outputText(this.wrapText(room.baseDesc));
                if (room.npcs && Object.keys(room.npcs).length > 0) { Object.values(room.npcs).forEach(desc => this.outputText(this.wrapText(desc), 'cyan')); }
                if (room.items && room.items.length > 0) { this.outputText("On the ground you see: " + room.items.join(', ')); }
                if (room.features && room.features.length > 0) { this.outputText("You notice: " + room.features.join(', ')); }
                const exits = [];
                const { x, y, z } = this.state.playerPos;
                const moves = { N: { y: y + 1 }, S: { y: y - 1 }, E: { x: x + 1 }, W: { x: x - 1 }, U: { z: z + 1 }, D: { z: z - 1 } };
                for (const [dir, move] of Object.entries(moves)) {
                    const checkPos = { ...this.state.playerPos, ...move };
                    if (this.data.worldMap[`${checkPos.x},${checkPos.y},${checkPos.z}`]) exits.push(dir);
                }
                if (exits.length > 0) this.outputText("Exits: " + exits.join(" "));
                return 1;
            },
            handleTake(args) {
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, room.items || []);
                if (!targetName) { this.outputText(`You don't see that here.`); return 1; }
                if (this.data.items[targetName]?.takeable) {
                    this.state.inventory.push(targetName);
                    room.items = room.items.filter(item => item !== targetName);
                    this.outputText(`You take the ${targetName}.`);
                    return 2;
                } else { this.outputText(`You can't take the ${targetName}.`); return 1; }
            },
            handleDrop(args) {
                 const targetName = this.findTarget(args, this.state.inventory);
                 if (!targetName) { this.outputText("You are not carrying that."); return 1; }
                 const room = this.getCurrentRoom();
                 this.state.inventory = this.state.inventory.filter(item => item !== targetName);
                 if (!room.items) room.items = [];
                 room.items.push(targetName);
                 this.outputText(`You drop the ${targetName}.`);
                 return 2;
            },
            handleTalk(args) {
                 const room = this.getCurrentRoom();
                if (!room || !room.npcs || Object.keys(room.npcs).length === 0) {
                    this.outputText("There's no one here to talk to.", 'fail');
                    return 1;
                }
                
                // Debug: Show available NPCs
                const availableNPCs = Object.keys(room.npcs);
                this.outputText(`Available NPCs: ${availableNPCs.join(', ')}`, 'debug');
                
                const npcName = args.length > 0 ? this.findTarget(args, Object.keys(room.npcs)) : Object.keys(room.npcs)[0];
                if (!npcName) {
                    this.outputText(`Who do you want to talk to? Available: ${availableNPCs.join(', ')}`, 'fail');
                    return 1;
                }
                
                // Check if it's a flavor NPC first
                if (['street_urchin', 'drunk_noble', 'mysterious_stranger', 'crying_widow'].includes(npcName)) {
                    this.handleFlavorNPCTalk(npcName);
                    return 2;
                }
                
                // Start RPG-style dialogue
                this.startDialogue(npcName);
                return 2;
            },
            
            // Enhanced dialogue with consequential outcomes
            handleFlavorNPCTalk(npcName) {
                const room = this.getCurrentRoom();
                const npc = room.npcs[npcName];
                
                switch (npcName) {
                    case 'street_urchin':
                        this.outputText("\n--- Talking to Street Urchin ---", 'header');
                        this.outputText('"Please, mister, I haven\'t eaten in two days. My little sister is sick..."', 'cyan');
                        this.outputText("\nWhat do you do?", 'yellow');
                        this.outputText("1. Give them some coins", 'cyan');
                        this.outputText("2. Ask about the case", 'cyan');
                        this.outputText("3. Ignore them", 'cyan');
                        this.outputText("4. End conversation", 'cyan');
                        
                        this.state.currentDialogue = {
                            npc: npcName,
                            stage: 'flavor_choices',
                            type: 'street_urchin'
                        };
                        break;
                        
                    case 'drunk_noble':
                        this.outputText("\n--- Talking to Drunk Noble ---", 'header');
                        this.outputText('"You there! Do you know who I am? I am Lord Blackthorne! Show some respect!"', 'cyan');
                        this.outputText("\nWhat do you do?", 'yellow');
                        this.outputText("1. Apologize respectfully", 'cyan');
                        this.outputText("2. Challenge their authority", 'cyan');
                        this.outputText("3. Ask about local politics", 'cyan');
                        this.outputText("4. End conversation", 'cyan');
                        
                        this.state.currentDialogue = {
                            npc: npcName,
                            stage: 'flavor_choices',
                            type: 'drunk_noble'
                        };
                        break;
                        
                    case 'mysterious_stranger':
                        this.outputText("\n--- Talking to Mysterious Stranger ---", 'header');
                        this.outputText('"The Whispering Stone... it calls to those who seek truth. But truth has a price."', 'cyan');
                        this.outputText("\nWhat do you do?", 'yellow');
                        this.outputText("1. Ask about the price", 'cyan');
                        this.outputText("2. Demand answers", 'cyan');
                        this.outputText("3. Offer payment", 'cyan');
                        this.outputText("4. End conversation", 'cyan');
                        
                        this.state.currentDialogue = {
                            npc: npcName,
                            stage: 'flavor_choices',
                            type: 'mysterious_stranger'
                        };
                        break;
                        
                    case 'crying_widow':
                        this.outputText("\n--- Talking to Crying Widow ---", 'header');
                        this.outputText('"They say it was an accident, but I know better. My husband was investigating something... something dangerous."', 'cyan');
                        this.outputText("\nWhat do you do?", 'yellow');
                        this.outputText("1. Offer comfort", 'cyan');
                        this.outputText("2. Ask about his investigation", 'cyan');
                        this.outputText("3. Promise to help", 'cyan');
                        this.outputText("4. End conversation", 'cyan');
                        
                        this.state.currentDialogue = {
                            npc: npcName,
                            stage: 'flavor_choices',
                            type: 'crying_widow'
                        };
                        break;
                }
            },
            
            startDialogue(npcName) {
                const npc = this.data.npcDialogue[npcName];
                if (!npc) {
                    this.outputText(`You don't know how to talk to ${npcName}.`, 'fail');
                    return;
                }
                
                this.outputText(`\n--- Talking to ${npc.name} ---`, 'header');
                
                // Show greeting
                const greeting = this.getRandomDialogue(npc.dialogue.greeting);
                this.outputText(`"${greeting}"`, 'cyan');
                
                // Show dialogue options
                this.showDialogueOptions(npcName);
            },
            
            showDialogueOptions(npcName) {
                const npc = this.data.npcDialogue[npcName];
                this.outputText("\nWhat would you like to ask about?", 'yellow');
                this.outputText("1. The case", 'cyan');
                this.outputText("2. Local news", 'cyan');
                this.outputText("3. Rumors", 'cyan');
                this.outputText("4. Their background", 'cyan');
                this.outputText("5. General conversation", 'cyan');
                this.outputText("6. End conversation", 'cyan');
                
                // Store current dialogue state
                this.state.currentDialogue = {
                    npc: npcName,
                    stage: 'options'
                };
                
                // Add visual indicator that we're in dialogue mode
                this.outputText("\n[DIALOGUE MODE - Use numbers 1-6 to respond, or 'quit' to exit]", 'yellow');
            },
            
            // Handle consequential choices for flavor NPCs
            handleFlavorNPCChoice(choice) {
                const npcType = this.state.currentDialogue.type;
                const npcName = this.state.currentDialogue.npc;
                
                switch (npcType) {
                    case 'street_urchin':
                        switch (choice) {
                            case 1: // Give coins
                                this.outputText('"Thank you, mister! You\'re a good person!" The urchin runs off, but you notice they\'re being watched by a guard.', 'cyan');
                                this.state.gameState.consequentialEvents.helpedLicey = true;
                                this.state.gameState.relationships.guards += 1;
                                this.outputText("\n[Your reputation with the guards has improved]", 'green');
                                break;
                            case 2: // Ask about case
                                this.outputText('"I don\'t know much, mister, but I saw some fancy folk arguing near the old warehouse last night. They mentioned something about a stone."', 'cyan');
                                this.state.journal.push("Street urchin: Saw fancy folk arguing near old warehouse about a stone.");
                                break;
                            case 3: // Ignore
                                this.outputText('"Please, mister..." The urchin looks disappointed and walks away.', 'cyan');
                                this.state.gameState.relationships.beggars -= 1;
                                break;
                            case 4: // End conversation
                                this.outputText('"Alright, mister. Maybe next time."', 'cyan');
                                break;
                        }
                        break;
                        
                    case 'drunk_noble':
                        switch (choice) {
                            case 1: // Apologize
                                this.outputText('"That\'s more like it! You show proper respect to your betters!" The noble seems pleased.', 'cyan');
                                this.state.gameState.relationships.nobles += 1;
                                this.outputText("\n[Your reputation with nobles has improved]", 'green');
                                break;
                            case 2: // Challenge
                                this.outputText('"How dare you! I\'ll have you thrown in the stocks for this insolence!" The noble storms off.', 'cyan');
                                this.state.gameState.consequentialEvents.angeredNoble = true;
                                this.state.gameState.relationships.nobles -= 2;
                                this.outputText("\n[You\'ve made an enemy of the nobility]", 'red');
                                break;
                            case 3: // Ask about politics
                                this.outputText('"Politics? Bah! The city guard is corrupt, the merchants are thieves, and the common folk are ungrateful wretches!"', 'cyan');
                                this.state.journal.push("Drunk noble: Claims city guard is corrupt and merchants are thieves.");
                                break;
                            case 4: // End conversation
                                this.outputText('"Fine, fine. Go about your business, peasant."', 'cyan');
                                break;
                        }
                        break;
                        
                    case 'mysterious_stranger':
                        switch (choice) {
                            case 1: // Ask about price
                                this.outputText('"The price is knowledge. What you seek lies in the old wizard\'s tower, but beware - some truths are better left buried."', 'cyan');
                                this.state.journal.push("Mysterious stranger: The Whispering Stone is in the old wizard's tower.");
                                break;
                            case 2: // Demand answers
                                this.outputText('"Demand? You have no power here, seeker. The stone will find you when it\'s ready." The stranger fades into the shadows.', 'cyan');
                                this.state.gameState.consequentialEvents.madeEnemy = true;
                                break;
                            case 3: // Offer payment
                                this.outputText('"Your coin means nothing to me. But your actions... they have weight. Choose wisely."', 'cyan');
                                this.state.gameState.consequentialEvents.gainedAlly = true;
                                break;
                            case 4: // End conversation
                                this.outputText('"As you wish. But remember - the stone calls to those who seek truth."', 'cyan');
                                break;
                        }
                        break;
                        
                    case 'crying_widow':
                        switch (choice) {
                            case 1: // Offer comfort
                                this.outputText('"Thank you for your kindness. My husband was investigating the Whispering Stone when he... when he died."', 'cyan');
                                this.state.gameState.consequentialEvents.savedChild = true;
                                this.state.gameState.relationships.widow += 2;
                                this.outputText("\n[The widow trusts you more]", 'green');
                                break;
                            case 2: // Ask about investigation
                                this.outputText('"He said the stone was dangerous, that it could drive men mad. He was trying to warn people, but they wouldn\'t listen."', 'cyan');
                                this.state.journal.push("Widow: Husband was investigating Whispering Stone, said it could drive men mad.");
                                break;
                            case 3: // Promise to help
                                this.outputText('"You would help me? Please, find out what really happened to my husband. I know it wasn\'t an accident."', 'cyan');
                                this.state.gameState.sideQuests.informationGathering.active = true;
                                this.outputText("\n[New side quest: Investigate the widow's husband's death]", 'yellow');
                                break;
                            case 4: // End conversation
                                this.outputText('"I understand. Some things are too painful to discuss."', 'cyan');
                                break;
                        }
                        break;
                }
                
                // End the conversation
                this.state.currentDialogue = null;
                this.outputText("\n[Conversation ended - You can now use normal commands]", 'yellow');
            },
            
            handleDialogueChoice(choice) {
                if (!this.state.currentDialogue) return;
                
                // Handle flavor NPC choices
                if (this.state.currentDialogue.stage === 'flavor_choices') {
                    this.handleFlavorNPCChoice(choice);
                    return;
                }
                
                const npcName = this.state.currentDialogue.npc;
                const npc = this.data.npcDialogue[npcName];
                
                let response = "";
                let topic = "";
                
                switch(choice) {
                    case 1:
                        response = this.getRandomDialogue(npc.dialogue.case);
                        topic = "case";
                        break;
                    case 2:
                        response = this.getRandomDialogue(npc.dialogue.topics.local_news || npc.dialogue.default);
                        topic = "local_news";
                        break;
                    case 3:
                        response = this.getRandomDialogue(npc.dialogue.topics.rumors || npc.dialogue.default);
                        topic = "rumors";
                        break;
                    case 4:
                        response = this.getRandomDialogue(npc.dialogue.background);
                        topic = "background";
                        break;
                    case 5:
                        response = this.getRandomDialogue(npc.dialogue.default);
                        topic = "general";
                        break;
                    case 6:
                        this.outputText(`"Well, I've got work to do. Come back if you need anything else."`, 'cyan');
                        this.state.currentDialogue = null;
                        this.outputText("\n[Conversation ended - You can now use normal commands]", 'yellow');
                        return;
                }
                
                this.outputText(`"${response}"`, 'cyan');
                
                // Check for race hints
                if (topic === "background" && Math.random() < 0.3) {
                    const raceHint = this.getRandomDialogue(npc.dialogue.race_hint);
                    this.outputText(`"${raceHint}"`, 'cyan');
                }
                
                // Show follow-up options
                this.showFollowUpOptions(npcName, topic);
            },
            
            showFollowUpOptions(npcName, topic) {
                const npc = this.data.npcDialogue[npcName];
                this.outputText("\nWhat else would you like to know?", 'yellow');
                
                const options = [];
                if (topic !== "case") options.push("1. Ask about the case");
                if (topic !== "local_news" && npc.dialogue.topics.local_news) options.push("2. Ask about local news");
                if (topic !== "rumors" && npc.dialogue.topics.rumors) options.push("3. Ask about rumors");
                if (topic !== "background") options.push("4. Ask about their background");
                if (topic !== "general") options.push("5. General conversation");
                
                // Add topic-specific options
                if (npc.dialogue.topics.magic) options.push("6. Ask about magic");
                if (npc.dialogue.topics.secrets) options.push("7. Ask about secrets");
                if (npc.dialogue.topics.underground) options.push("8. Ask about the underground");
                
                options.push("9. End conversation");
                
                options.forEach(option => this.outputText(option, 'cyan'));
                
                this.state.currentDialogue.stage = 'followup';
            },
            
            getRandomDialogue(dialogueArray) {
                if (!dialogueArray || dialogueArray.length === 0) return "I have nothing to say about that.";
                return dialogueArray[Math.floor(Math.random() * dialogueArray.length)];
            },

            handleRead(args) {
                if (!args.length) { 
                    this.outputText("Read what?"); 
                    return 0; 
                }
                
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, this.state.inventory.concat(room.items || []));
                
                if (!targetName) { 
                    this.outputText(`You don't see '${args.join(' ')}' to read.`); 
                    return 2; 
                }

                if (targetName === "bounty_notice") {
                    this.outputText("--- ROYAL BOUNTY NOTICE ---", 'header');
                    this.outputText("By Order of His Majesty King Aldric", 'cyan');
                    this.outputText("Date: 15th of Springmoon, 1247", 'cyan');
                    this.outputText("", 'normal');
                    this.outputText("BOUNTY:", 'header');
                    this.outputText("The Whispering Stone - Ancient artifact of power", 'normal');
                    this.outputText("Last seen: Lady Elara's chambers", 'normal');
                    this.outputText("Reward: 500 gold pieces", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("WARNING:", 'header');
                    this.outputText("Stone is said to grant wishes but corrupts the soul.", 'normal');
                    this.outputText("Handle with extreme caution.", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("OBJECTIVE: Locate the Whispering Stone, determine its fate.", 'green');
                    return 5;
                } else if (targetName === "tattered_proclamation") {
                    this.outputText("--- TATTERED PROCLAMATION ---", 'header');
                    this.outputText("The Royal Guard seeks information about:", 'cyan');
                    this.outputText("", 'normal');
                    this.outputText("- Mysterious glowing light in Lady Elara's tower", 'normal');
                    this.outputText("- Disappearance of court scholar Marcus", 'normal');
                    this.outputText("- Unusual magical disturbances", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("Reward for information: 50 gold pieces", 'normal');
                    this.outputText("Contact: Captain of the Guard", 'normal');
                    return 3;
                } else if (targetName === "enchanted_tome") {
                    this.outputText("--- ENCHANTED TOME ---", 'header');
                    this.outputText("Ancient text in flowing script:", 'cyan');
                    this.outputText("", 'normal');
                    this.outputText("'The Whispering Stone holds the power of ages,'", 'normal');
                    this.outputText("'But only the pure of heart may wield it safely.'", 'normal');
                    this.outputText("'Beware the corruption that follows power.'", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("'The stone seeks a worthy master,'", 'normal');
                    this.outputText("'But many have fallen to its temptation.'", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("This explains the stone's nature!", 'warning');
                    return 5;
                } else {
                    this.outputText(`You can't read the ${targetName}.`);
                    return 2;
                }
            },

            handleMap() {
                this.outputText("--- KINGDOM MAP ---", 'header');
                this.outputText("(Only showing locations you've discovered)", 'grey');
                
                // Only show visited locations
                const visitedRooms = [];
                for (const coord of this.state.discoveredCoords) {
                    const room = this.data.worldMap[coord];
                    if (room && room.name) {
                        const [x, y, z] = coord.split(',').map(Number);
                        const depth = z < 0 ? ` (Underground Level ${Math.abs(z)})` : z > 0 ? ` (Above Ground Level ${z})` : '';
                        visitedRooms.push(`${room.name}${depth} - ${coord}`);
                    }
                }
                
                if (visitedRooms.length === 0) {
                    this.outputText("You haven't discovered any locations yet. Start exploring!");
                } else {
                    visitedRooms.forEach(room => this.outputText(room));
                }
                
                // Show current location
                const currentCoord = `${this.state.playerPos.x},${this.state.playerPos.y},${this.state.playerPos.z}`;
                const currentRoom = this.data.worldMap[currentCoord];
                if (currentRoom) {
                    this.outputText(`\nYou are currently at: ${currentRoom.name}`, 'cyan');
                }
                
                return 1;
            },

            handleHint() {
                const caseState = this.state.gameState.whisperingStoneCase;
                this.outputText("--- INVESTIGATION HINTS ---", 'header');
                
                if (!caseState.interviewedLadyElara) {
                    this.outputText(" Visit Lady Elara's Tower to interview the client", 'cyan');
                }
                if (!caseState.interviewedScholar) {
                    this.outputText(" Check Royal Palace for the court scholar", 'cyan');
                }
                if (!caseState.interviewedMerchant) {
                    this.outputText(" Merchant's Stall - merchant might know something", 'cyan');
                }
                if (!caseState.interviewedMysteriousFigure) {
                    this.outputText(" Mysterious Figure's Lair - shadowy character", 'cyan');
                }
                if (!caseState.foundStone) {
                    this.outputText(" Look for the 'glowing orb' - Whispering Stone", 'cyan');
                }
                if (caseState.evidenceCollected.length < 3) {
                    this.outputText(" Search rooms thoroughly for evidence", 'cyan');
                }
                if (caseState.evidenceCollected.length >= 3 && !caseState.discoveredTruth) {
                    this.outputText(" Use 'investigate' to piece together the evidence", 'cyan');
                }
                
                this.outputText("", 'normal');
                this.outputText("Remember: Cast spells, talk to NPCs, follow the magic!", 'green');
                return 0;
            },

            handleBartenderTalk() {
                const race = this.state.gameState.playerRace;
                const room = this.getCurrentRoom();
                
                this.outputText(this.wrapText(room.npcs.bartender));
                
                // Subtle race-based reactions
                if (race.name === "Orc") {
                    this.outputText("The bartender seems slightly nervous around you, but tries to hide it.", 'normal');
                } else if (race.name === "Dwarf") {
                    this.outputText("The bartender nods approvingly. 'Good to see another stout soul in here.'", 'cyan');
                } else if (race.name === "Elf") {
                    this.outputText("The bartender's eyes narrow slightly. 'You hear well, don't you?'", 'cyan');
                } else if (race.name === "Halfling") {
                    this.outputText("The bartender smiles warmly. 'Always good to see one of the little folk.'", 'cyan');
                } else if (race.name === "Gnome") {
                    this.outputText("The bartender looks at you curiously. 'You've got that... spark about you.'", 'cyan');
                } else {
                    this.outputText("The bartender treats you with polite neutrality.", 'normal');
                }
                
                this.outputText(this.wrapText("He gestures to a quest board. 'Got some odd jobs if you need the coin. Type 'contracts'.'", 2), 'grey');
            },

            handleDwarfPatronTalk() {
                const race = this.state.gameState.playerRace;
                
                this.outputText("The dwarf looks up from his ale and studies you.", 'cyan');
                
                if (race.name === "Dwarf") {
                    this.outputText("'Ah, a fellow dwarf!' he says warmly, raising his mug. 'Come, share a drink with me.'", 'green');
                    this.outputText("He slides over a stool and pours you a mug of ale.", 'normal');
                    this.state.gameState.raceReputation.dwarf += 1;
                } else if (race.name === "Elf") {
                    this.outputText("The dwarf's eyes narrow. 'Pointy-ears,' he mutters, spitting into his spittoon.", 'fail');
                    this.outputText("He turns away and ignores you.", 'fail');
                    this.state.gameState.raceReputation.elf -= 1;
                } else if (race.name === "Orc") {
                    this.outputText("The dwarf's hand goes to his axe handle. 'What's a greenskin doing in here?' he growls.", 'fail');
                    this.outputText("Other patrons start to notice the tension.", 'warning');
                    this.state.gameState.raceReputation.orc -= 2;
                } else if (race.name === "Halfling") {
                    this.outputText("'Well, well, one of the little folk,' he says with a chuckle. 'Always good to see.'", 'cyan');
                    this.outputText("He pats the stool next to him.", 'normal');
                    this.state.gameState.raceReputation.halfling += 1;
                } else if (race.name === "Gnome") {
                    this.outputText("'Hmm, you've got that spark about you,' he says, studying you closely.", 'cyan');
                    this.outputText("'Magic-touched, aren't you?'", 'cyan');
                    this.state.gameState.raceReputation.gnome += 1;
                } else {
                    this.outputText("'Human, eh?' he says neutrally. 'Fair enough.'", 'normal');
                }
            },
            handleSearch(args) {
                if (!args.length) { this.outputText("Search what?"); return 0; }
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, room.features || []);
                if (!targetName) { this.outputText(`You see no '${args.join(' ')}' to search.`); return 5; }
                if (targetName === "scribe_desk" && this.posKey() === '0,0,0') {
                    if (!this.state.gameState.deskSearched) {
                        this.state.gameState.deskSearched = true;
                        const { result } = this.attributeCheck("perception", 12);
                        if (result.includes("success")) {
                            this.outputText("Tucked away in a secret compartment, you find a masterwork key.", 'green');
                            if (!room.items) room.items = [];
                            room.items.push("masterwork_key");
                        } else { this.outputText("You search the desk but find only old quills and dried inkwells.", 'grey'); }
                    } else { this.outputText("You've already searched the desk."); }
                    return 10;
                }
                else { this.outputText(`You search the ${targetName} but find nothing of interest.`); return 5; }
            },
            handleUse(args) {
                if (args.length === 1 && args[0] === 'healing_potion') {
                    if (this.state.inventory.includes('healing_potion')) {
                        this.state.inventory = this.state.inventory.filter(i => i !== 'healing_potion');
                        this.state.health = Math.min(5, this.state.health + 2);
                        this.outputText("You drink the potion. A warm energy flows through you, mending your wounds.", 'green');
                        return 2;
                    } else { this.outputText("You don't have a healing potion."); return 1; }
                }
                const onIndex = args.indexOf('on');
                if (onIndex === -1) { this.outputText("Use what on what?"); return 1; }
                const itemToUse = this.findTarget(args.slice(0, onIndex), this.state.inventory);
                const objectToUseOn = this.findTarget(args.slice(onIndex + 1), [...(this.getCurrentRoom().items || []), ...(this.getCurrentRoom().features || [])]);
                if (!itemToUse) { this.outputText(`You don't have that.`); return 1; }
                if (!objectToUseOn) { this.outputText(`You don't see that here.`); return 1; }
                if (itemToUse === "masterwork_key" && objectToUseOn === "iron-banded_chest") {
                     this.outputText("The key turns smoothly in the lock. The chest opens, revealing a coded parchment inside.", 'green');
                     this.state.inventory = this.state.inventory.filter(i => i !== itemToUse);
                     this.state.inventory.push("coded_parchment");
                     this.getCurrentRoom().items = this.getCurrentRoom().items.filter(i => i !== 'iron-banded_chest');
                     this.state.gameState.chestOpened = true;
                     this.state.journal.push("The key from my hideout opened a chest in the curio shop, revealing a note: 'The truth is not in the manifest, but in the glow.'");
                     return 5;
                } else if (itemToUse === "scrying_orb" && objectToUseOn === "enchanted_tome") {
                    this.outputText("You place the orb on the tome. A swirling light envelops the book, and the arcane runes resolve into a damning truth: a smuggling ring using forbidden magic. You've found your proof.", 'header');
                    this.state.won = true;
                    return 5;
                } else { this.outputText("That doesn't seem to work."); return 2; }
            },
            handleThink() {
                 if (!this.state.journal || this.state.journal.length <= 1) {
                    this.outputText(this.wrapText("You wrack your brain, but all you can remember is the taste of cheap ale."), 'grey');
                 } else {
                     this.outputText("You recall what you have learned...", 'cyan');
                     this.state.journal.forEach(entry => this.outputText(`- ${this.wrapText(entry, 2)}`, 'cyan'));
                 }
                 return 5;
            },
            handleDrink() {
                // Check if player has any drinkable items
                const drinkableItems = this.state.inventory.filter(item => 
                    item.includes('mead') || item.includes('ale') || item.includes('wine') || 
                    item.includes('potion') || item.includes('water') || item.includes('drink')
                );
                
                if (drinkableItems.length > 0) {
                    const item = drinkableItems[0];
                    this.outputText(`You drink the ${item}. It tastes refreshing.`);
                    // Remove the item from inventory
                    const index = this.state.inventory.indexOf(item);
                    if (index > -1) {
                        this.state.inventory.splice(index, 1);
                    }
                    return 2;
                } else {
                    this.outputText("You don't have anything to drink.");
                    return 1;
                }
            },
            showHelp() {
                this.outputText("--- ADVENTURER'S COMMANDS ---", 'header');
                this.outputText("Movement:  go <dir>, n, s, e, w, u, d");
                this.outputText("Actions: look, look at <obj>, take <item>, drop <item>");
                this.outputText("         search <obj>, talk to <npc>, use <item> on <object>");
                this.outputText("         give <item> to <npc>, attack <npc>");
                this.outputText("Social:   talk to <npc> [persuade|intimidate|bribe], give coin to <npc>");
                this.outputText("Combat:  attack <npc>, equip <weapon>, unequip");
                this.outputText("Gambling: gamble <amount> (at gambling den)");
                this.outputText("Reading:  read <item>, read case_file");
                this.outputText("Covert:  break into <place>, pick lock, pry <door>");
                this.outputText("Magic:   cast <spell> (weave magical threads)");
                this.outputText("Quests:  contracts, accept <num>, work contract");
                this.outputText("Personal: drink, think");
                this.outputText("Shopping: buy <item>, bluff <item>, steal <item> (at merchant's stall)");
                this.outputText("Investigation: investigate, confront <suspect>");
                this.outputText("Status:  status, inventory (i), journal, map, hint, stolen, quit");
                this.outputText("Save/Load: save [name], load <name>, saves, delete_save <name>");
                this.outputText("----------------", 'header');
                return 0;
            },
            showInventory() {
                if (this.state.inventory.length > 0) {
                    this.outputText("You are carrying: " + this.state.inventory.join(', '));
                } else {
                    this.outputText("Your pouches are empty.");
                }
                return 0;
            },
            
            // --- FANTASY COMMAND HANDLERS ---
            
            handleGamble(args) {
                const room = this.getCurrentRoom();
                if (room.name !== "The Gambling Den") {
                    this.outputText("This is no place to gamble.");
                    return 1;
                }
                
                try {
                    const bet = parseInt(args[0]);
                    if (bet <= 0) {
                        this.outputText("You must wager something, traveler.");
                        return 1;
                    }
                    if (this.state.cash >= bet) {
                        this.outputText(`You place ${bet} coins on the table and roll the dice...`);
                        this.state.cash -= bet;
                        const { result } = this.attributeCheck("luck", 13);
                        if (result.includes("success")) {
                            const winnings = bet * 2;
                            this.outputText(`The dice favor you! You win ${winnings} coins.`, 'green');
                            this.state.cash += winnings;
                        } else {
                            this.outputText("The house always wins. You lose your wager.", 'fail');
                        }
                        return 15;
                    } else {
                        this.outputText("You don't have enough coins for that wager.");
                        return 2;
                    }
                } catch (e) {
                    this.outputText("How much do you wish to wager? (e.g., 'gamble 20')");
                    return 1;
                }
            },
            
            handlePlayGame(args) {
                const room = this.getCurrentRoom();
                if (!room.features || !room.features.includes('game_board')) {
                    this.outputText("There's no game board here.", 'fail');
                    return 1;
                }
                
                this.outputText("\n--- Mini-Game: Dragon's Dice ---", 'header');
                this.outputText("Roll three dice. If you get three of a kind, you win!", 'cyan');
                this.outputText("Cost: 5 gold per game", 'yellow');
                
                if (this.state.cash < 5) {
                    this.outputText("You need at least 5 gold to play.", 'fail');
                    return 1;
                }
                
                this.state.cash -= 5;
                const dice1 = Math.floor(Math.random() * 6) + 1;
                const dice2 = Math.floor(Math.random() * 6) + 1;
                const dice3 = Math.floor(Math.random() * 6) + 1;
                
                this.outputText(`You roll: ${dice1}, ${dice2}, ${dice3}`, 'cyan');
                
                if (dice1 === dice2 && dice2 === dice3) {
                    const winnings = 50;
                    this.state.cash += winnings;
                    this.outputText(`Three ${dice1}s! You win ${winnings} gold!`, 'success');
                } else if (dice1 === dice2 || dice2 === dice3 || dice1 === dice3) {
                    const winnings = 10;
                    this.state.cash += winnings;
                    this.outputText(`A pair! You win ${winnings} gold!`, 'success');
                } else {
                    this.outputText("No luck this time. Try again!", 'fail');
                }
                
                return 3;
            },
            
            handleSing(args) {
                const room = this.getCurrentRoom();
                if (!room.features || !room.features.includes('fireplace')) {
                    this.outputText("There's no fireplace here to sing by.", 'fail');
                    return 1;
                }
                
                this.outputText("You begin to sing a haunting melody...", 'cyan');
                
                // Chance to gain reputation or cash
                const roll = Math.floor(Math.random() * 20) + 1;
                if (roll >= 15) {
                    const tip = Math.floor(Math.random() * 20) + 5;
                    this.state.cash += tip;
                    this.outputText(`A patron tosses you ${tip} gold! "Beautiful voice!"`, 'success');
                } else if (roll >= 10) {
                    this.outputText("The patrons nod appreciatively. You feel more confident.", 'cyan');
                    this.state.reputation += 1;
                } else {
                    this.outputText("Your voice cracks on the high note. The patrons politely ignore you.", 'fail');
                }
                
                return 2;
            },
            
            handleTellStory(args) {
                const room = this.getCurrentRoom();
                if (!room.npcs || Object.keys(room.npcs).length === 0) {
                    this.outputText("There's no one here to tell a story to.", 'fail');
                    return 1;
                }
                
                this.outputText("You begin to tell a tale of adventure...", 'cyan');
                
                const roll = Math.floor(Math.random() * 20) + 1;
                if (roll >= 18) {
                    const tip = Math.floor(Math.random() * 30) + 10;
                    this.state.cash += tip;
                    this.outputText(`The audience is captivated! They throw ${tip} gold at your feet!`, 'success');
                    this.state.reputation += 2;
                } else if (roll >= 12) {
                    this.outputText("The listeners are entertained. You gain some respect.", 'cyan');
                    this.state.reputation += 1;
                } else {
                    this.outputText("Your story falls flat. The audience politely claps.", 'fail');
                }
                
                return 3;
            },
            
            handlePractice(args) {
                const room = this.getCurrentRoom();
                if (!room.features || !room.features.includes('training_grounds')) {
                    this.outputText("There's no training area here.", 'fail');
                    return 1;
                }
                
                this.outputText("You practice your combat skills...", 'cyan');
                
                const roll = Math.floor(Math.random() * 20) + 1;
                if (roll >= 16) {
                    this.state.strength += 1;
                    this.outputText("Your training pays off! You feel stronger.", 'success');
                } else if (roll >= 10) {
                    this.outputText("You work up a sweat. Good practice.", 'cyan');
                } else {
                    this.outputText("You're having an off day. Maybe try again later.", 'fail');
                }
                
                return 4;
            },
            
            handleMeditate(args) {
                const room = this.getCurrentRoom();
                if (!room.features || !room.features.includes('ancient_rune')) {
                    this.outputText("There's no peaceful place to meditate here.", 'fail');
                    return 1;
                }
                
                this.outputText("You sit in meditation, focusing your mind...", 'cyan');
                
                const roll = Math.floor(Math.random() * 20) + 1;
                if (roll >= 15) {
                    this.state.willpower += 1;
                    this.outputText("Your mind feels clearer and more focused.", 'success');
                } else if (roll >= 8) {
                    this.outputText("You feel more centered and calm.", 'cyan');
                } else {
                    this.outputText("Your mind wanders. Meditation is harder than it looks.", 'fail');
                }
                
                return 3;
            },
            
            handleContracts(args) {
                const room = this.getCurrentRoom();
                if (room.name !== "The Tavern") {
                    this.outputText("You need to be at the tavern to see the quest board.");
                    return 1;
                }
                
                this.outputText("--- AVAILABLE QUESTS ---", 'header');
                this.state.contracts.forEach((contract, index) => {
                    if (!contract.completed) {
                        this.outputText(`${index + 1}. ${contract.type}: ${contract.description}`);
                        this.outputText(`   Reward: ${contract.payout} coins | Location: ${contract.target_location}`);
                    }
                });
                this.outputText("Type 'accept <number>' to take a quest.", 'cyan');
                return 0;
            },
            
            handleAcceptContract(args) {
                try {
                    const contractNum = parseInt(args[0]) - 1;
                    if (contractNum >= 0 && contractNum < this.state.contracts.length) {
                        const contract = this.state.contracts[contractNum];
                        if (!contract.completed) {
                            contract.completed = true;
                            this.state.activeContracts.push(contract);
                            this.outputText(`You accept the ${contract.type} quest.`, 'green');
                            this.outputText(`Go to ${contract.target_location} and type 'work contract' to complete it.`);
                            return 2;
                        } else {
                            this.outputText("That quest is already completed.");
                            return 1;
                        }
                    } else {
                        this.outputText("Invalid quest number.");
                        return 1;
                    }
                } catch (e) {
                    this.outputText("Usage: accept <number>");
                    return 1;
                }
            },
            
            handleWorkContract(args) {
                if (this.state.activeContracts.length === 0) {
                    this.outputText("You don't have any active quests.");
                    return 1;
                }
                
                const contract = this.state.activeContracts[0];
                const room = this.getCurrentRoom();
                const roomName = room.name.toLowerCase();
                
                if (roomName.includes(contract.target_location.toLowerCase())) {
                    this.outputText(`You complete the ${contract.type} quest.`, 'green');
                    this.state.cash += contract.payout;
                    this.outputText(`You earn ${contract.payout} coins.`);
                    this.state.activeContracts.shift();
                    return 30;
                } else {
                    this.outputText(`You need to be at ${contract.target_location} to work this quest.`);
                    return 1;
                }
            },
            
            handleBuy(args) {
                const room = this.getCurrentRoom();
                if (room.name === "The Merchant's Stall") {
                    const items = ["healing_potion", "iron_crowbar", "magic_torch"];
                    const costs = { "healing_potion": 5, "iron_crowbar": 25, "magic_torch": 15 };

                    const itemName = this.findTarget(args, items);
                    if (itemName && costs[itemName]) {
                        // Check if Barnaby is present
                        const isBarnabyPresent = room.npcs && room.npcs["Barnaby"];

                        if (isBarnabyPresent) {
                            // Normal purchase with Barnaby present
                            if (this.state.cash >= costs[itemName]) {
                                this.state.cash -= costs[itemName];
                                this.state.inventory.push(itemName);
                                this.outputText(`Barnaby hands you the ${itemName}. "Pleasure doing business with you, adventurer."`, 'green');
                                // Improve relationship with Barnaby
                                if (this.state.gameState.npcRelationships["Barnaby"]) {
                                    this.state.gameState.npcRelationships["Barnaby"].gratitude += 1;
                                }
                                return 2;
                            } else {
                                this.outputText(`Barnaby adjusts his spectacles. "You'll need ${costs[itemName]} coins for that, my friend."`);
                                return 1;
                            }
                        } else {
                            // Barnaby not present - could be stealing opportunity
                            this.outputText("Barnaby's not at his stall. You could try to take something... but that might anger the merchants.", 'warning');
                            return 1;
                        }
                    } else {
                        this.outputText("Barnaby's got: healing_potion (5 coins), iron_crowbar (25 coins), magic_torch (15 coins)");
                        return 1;
                    }
                } else {
                    this.outputText("There's nothing to buy here.");
                    return 1;
                }
            },

            handleBluff(args) {
                const room = this.getCurrentRoom();
                if (room.name !== "The Merchant's Stall") {
                    this.outputText("This isn't the place for haggling.");
                    return 1;
                }

                const items = ["healing_potion", "iron_crowbar", "magic_torch"];
                const costs = { "healing_potion": 5, "iron_crowbar": 25, "magic_torch": 15 };

                const itemName = this.findTarget(args, items);
                if (!itemName || !costs[itemName]) {
                    this.outputText("What are you trying to haggle for? Available: healing_potion, iron_crowbar, magic_torch");
                    return 1;
                }

                // Check if Barnaby is present
                const isBarnabyPresent = room.npcs && room.npcs["Barnaby"];
                if (!isBarnabyPresent) {
                    this.outputText("There's no one here to haggle with.");
                    return 1;
                }

                // Attempt to bluff using Charisma
                this.outputText("You try to talk Barnaby into a better price...", 'cyan');
                const { result } = this.attributeCheck("charisma", 14);

                if (result.includes("success")) {
                    // Success - get item at reduced price or free
                    const discountRoll = Math.random();
                    if (discountRoll > 0.7) {
                        // Free item!
                        this.state.inventory.push(itemName);
                        this.outputText(`Barnaby chuckles. "Alright, you win. Take the ${itemName} - on the house."`, 'green');
                        this.state.gameState.npcRelationships["Barnaby"].gratitude += 2;
                    } else {
                        // Half price
                        const halfPrice = Math.floor(costs[itemName] / 2);
                        if (this.state.cash >= halfPrice) {
                            this.state.cash -= halfPrice;
                            this.state.inventory.push(itemName);
                            this.outputText(`Barnaby smiles. "Fine, you drove a hard bargain. ${halfPrice} coins for the ${itemName}."`, 'green');
                            this.state.gameState.npcRelationships["Barnaby"].gratitude += 1;
                        } else {
                            this.outputText(`"Half price is ${halfPrice} coins, friend. You got that much?"`);
                            return 1;
                        }
                    }
                    return 3;
                } else {
                    // Failure - worse deal or suspicion
                    this.outputText("Barnaby peers at you over his spectacles. 'Nice try, adventurer. But I've been in this business too long.'", 'warning');
                    this.state.gameState.npcRelationships["Barnaby"].trust -= 1;
                    this.state.gameState.npcRelationships["Barnaby"].fear += 1;
                    // Slight increase in suspicion
                    this.state.gameState.suspicionLevel += 1;
                    return 2;
                }
            },

            handleSteal(args) {
                if (!args.length) {
                    this.outputText("Steal what?");
                    return 1;
                }

                const room = this.getCurrentRoom();
                const itemName = this.findTarget(args, room.items || []);
                if (!itemName) {
                    this.outputText(`You don't see ${args.join(' ')} here to steal.`);
                    return 1;
                }

                // Check if item is stealable
                const itemData = this.data.items[itemName];
                if (!itemData || !itemData.takeable) {
                    this.outputText(`You can't steal the ${itemName} - it's not something you can carry.`);
                    return 1;
                }

                // Check ownership and difficulty
                let difficulty = 12; // Base difficulty
                let owner = null;
                let witnesses = [];

                // Check for item ownership
                if (itemData.owned_by) {
                    owner = itemData.owned_by;
                    difficulty += 4; // Much harder to steal owned items
                }

                // Check for witnesses (NPCs in room)
                if (room.npcs) {
                    witnesses = Object.keys(room.npcs);
                    if (witnesses.length > 0) {
                        difficulty += witnesses.length * 2; // More witnesses = harder
                    }
                }

                // Special handling for merchant stall items
                if (room.name === "The Merchant's Stall") {
                    const isBarnabyPresent = room.npcs && room.npcs["Barnaby"];
                    if (isBarnabyPresent) {
                        owner = "Barnaby";
                        difficulty = 16;
                    }
                }

                this.outputText(`You attempt to steal the ${itemName}...`, 'warning');

                const { result } = this.attributeCheck("dexterity", difficulty);

                if (result.includes("success")) {
                    // Success!
                    this.state.inventory.push(itemName);
                    room.items = room.items.filter(item => item !== itemName);

                    // Mark item as stolen
                    if (!this.state.gameState.stolenItems) {
                        this.state.gameState.stolenItems = [];
                    }
                    this.state.gameState.stolenItems.push({
                        item: itemName,
                        from: room.name,
                        owner: owner,
                        time: `${this.state.time.day}:${String(this.state.time.hour).padStart(2, '0')}`
                    });

                    this.outputText(`You successfully pocket the ${itemName}!`, 'green');

                    // Consequences based on witnesses/owner
                    if (witnesses.length > 0) {
                        this.state.gameState.suspicionLevel += Math.min(witnesses.length, 3);
                        this.outputText("Someone might have seen that...", 'warning');
                    }

                    if (owner) {
                        // Damage relationship with owner
                        if (this.state.gameState.npcRelationships[owner]) {
                            this.state.gameState.npcRelationships[owner].trust -= 3;
                            this.state.gameState.npcRelationships[owner].fear += 1;
                        }

                        // Add to journal
                        this.state.journal.push(`Stole ${itemName} from ${owner}. The shadows remember.`);

                        // Higher suspicion for stealing from known owners
                        this.state.gameState.suspicionLevel += 2;
                    }

                    return 4;
                } else {
                    // Failure!
                    this.outputText("You fumble the attempt!", 'fail');

                    // Consequences
                    if (witnesses.length > 0) {
                        this.outputText("Someone noticed your attempt!", 'fail');
                        this.state.gameState.suspicionLevel += witnesses.length * 2;

                        // Witnesses might react
                        witnesses.forEach(npc => {
                            if (this.state.gameState.npcRelationships[npc]) {
                                this.state.gameState.npcRelationships[npc].trust -= 1;
                                this.state.gameState.npcRelationships[npc].fear += 1;
                            }
                        });

                        // Chance of being confronted
                        if (Math.random() > 0.6) {
                            this.outputText("They call for help! You should leave immediately.", 'fail');
                            this.state.gameState.suspicionLevel += 3;
                        }
                    } else if (owner) {
                        // Owner notices missing item later
                        this.state.gameState.suspicionLevel += 1;
                        this.outputText("The owner might notice this is missing soon...", 'warning');
                    }

                    return 3;
                }
            },

            handleStolen() {
                if (!this.state.gameState.stolenItems || this.state.gameState.stolenItems.length === 0) {
                    this.outputText("You haven't stolen anything... yet.", 'normal');
                    return 0;
                }

                this.outputText("--- ITEMS YOU'VE STOLEN ---", 'header');
                this.state.gameState.stolenItems.forEach((stolen, index) => {
                    const consequences = stolen.owner ?
                        ` (stolen from ${stolen.owner} - relationship damaged)` :
                        " (stolen anonymously)";
                    this.outputText(`${index + 1}. ${stolen.item} from ${stolen.from} at ${stolen.time}${consequences}`, 'warning');
                });

                // Calculate total suspicion from stolen items
                let totalSuspicionPenalty = 0;
                this.state.gameState.stolenItems.forEach(stolen => {
                    totalSuspicionPenalty += stolen.owner ? 3 : 1; // Higher penalty for owned items
                });

                this.outputText("", 'normal');
                this.outputText(`Total suspicion penalty from theft: +${totalSuspicionPenalty}`, 'warning');
                this.outputText("These items may have consequences if discovered...", 'warning');

                return 0;
            },

            handleBreakInto(args) {
                this.outputText("You attempt to force your way in...", 'warning');
                this.state.gameState.suspicionLevel += 3;
                const { result } = this.attributeCheck("strength", 15);
                if (result.includes("success")) {
                    this.outputText("You break through, but the noise draws attention.", 'green');
                    return 10;
                } else {
                    this.outputText("The barrier holds firm. You've made too much noise.", 'fail');
                    return 5;
                }
            },
            
            handlePickLock(args) {
                if (!this.state.inventory.includes('thieves_tools')) {
                    this.outputText("You need thieves' tools to pick locks.");
                    return 1;
                }
                
                this.outputText("You work the lock with delicate precision...", 'cyan');
                const { result } = this.attributeCheck("dexterity", 12);
                if (result.includes("success")) {
                    this.outputText("The lock clicks open.", 'green');
                    return 5;
                } else {
                    this.outputText("The lock resists your efforts.", 'fail');
                    return 3;
                }
            },
            
            handlePry(args) {
                if (!this.state.inventory.includes('iron_crowbar')) {
                    this.outputText("You need an iron crowbar to pry things open.");
                    return 1;
                }
                
                this.outputText("You wedge the crowbar and apply leverage...", 'cyan');
                const { result } = this.attributeCheck("strength", 10);
                if (result.includes("success")) {
                    this.outputText("Whatever it was gives way with a satisfying creak.", 'green');
                    return 5;
                } else {
                    this.outputText("It's stuck fast.", 'fail');
                    return 3;
                }
            },
            
            handleCast(args) {
                this.outputText("You begin to weave the threads of magic...", 'cyan');
                this.state.gameState.suspicionLevel += 2;
                const { result } = this.attributeCheck("perception", 14);
                if (result.includes("success")) {
                    this.outputText("The spell takes effect.", 'green');
                    return 8;
                } else {
                    this.outputText("The magic fizzles and fails.", 'fail');
                    return 5;
                }
            },

            handleInvestigate(args) {
                const caseState = this.state.gameState.whisperingStoneCase;
                const evidenceCount = caseState.evidenceCollected.length;
                
                this.outputText("You review the evidence you've gathered...", 'cyan');
                
                if (evidenceCount === 0) {
                    this.outputText("You haven't gathered any evidence yet. Talk to suspects and search locations.", 'warning');
                    return 5;
                }
                
                this.outputText(`Evidence collected: ${evidenceCount} pieces`, 'header');
                caseState.evidenceCollected.forEach((evidence, index) => {
                    this.outputText(`${index + 1}. ${evidence}`, 'normal');
                });
                
                // Determine if you have enough evidence to solve the case
                if (evidenceCount >= 4 && caseState.interviewedLadyElara && caseState.interviewedScholar && 
                    caseState.interviewedMerchant && caseState.interviewedMysteriousFigure) {
                    
                    this.outputText("\nYou've gathered enough evidence to piece together the truth...", 'green');
                    this.outputText("The Whispering Stone was stolen by the mysterious figure - a dark mage.", 'green');
                    this.outputText("He's using it to commune with ancient evil spirits and gain forbidden power.", 'green');
                    this.outputText("Lady Elara's rival scholar knew about the theft but was too scared to come forward.", 'green');
                    this.outputText("The dwarven merchant was just trying to profit from the situation.", 'green');
                    
                    caseState.discoveredTruth = true;
                    this.state.journal.push("SOLVED: Dark mage stole the stone to commune with evil spirits. Scholar knew but was scared.");
                    return 20;
                } else {
                    this.outputText("\nYou need more evidence to solve this case.", 'warning');
                    this.outputText("Interview all suspects and gather more clues.", 'warning');
                    return 10;
                }
            },

            handleConfront(args) {
                if (!args.length) { 
                    this.outputText("Confront who? (scholar, merchant, mysterious_figure, lady_elara)"); 
                    return 0; 
                }
                
                const caseState = this.state.gameState.whisperingStoneCase;
                if (!caseState.discoveredTruth) {
                    this.outputText("You need to investigate first and gather evidence.", 'warning');
                    return 5;
                }
                
                const target = args[0].toLowerCase();
                
                if (target === "mysterious_figure") {
                    this.outputText("You confront the mysterious figure with the evidence.", 'cyan');
                    this.outputText("'I know you stole the Whispering Stone and are using it for dark magic.'", 'normal');
                    
                    const { result } = this.attributeCheck("charisma", 16);
                    if (result.includes("success")) {
                        this.outputText("The dark mage breaks down. 'I didn't mean to unleash such evil! The spirits... they're too powerful!'", 'green');
                        this.outputText("'Help me destroy the stone before it's too late!'", 'green');
                        this.outputText("You've solved the case! The mage confesses and asks for help.", 'green');
                        this.state.won = true;
                        this.state.gameOver = true;
                        return 30;
                    } else {
                        this.outputText("The dark mage attacks you with forbidden magic!", 'fail');
                        this.state.gameState.suspicionLevel += 3;
                        return 15;
                    }
                } else if (target === "scholar") {
                    this.outputText("You confront the rival scholar about what they knew.", 'cyan');
                    this.outputText("'Why didn't you come forward about the dark mage's theft?'", 'normal');
                    
                    const { result } = this.attributeCheck("charisma", 12);
                    if (result.includes("success")) {
                        this.outputText("The scholar breaks down in tears. 'I was scared! The dark mage threatened me too.'", 'green');
                        this.outputText("'But I can help you stop him now. I know where he's hiding.'", 'green');
                        this.state.gameState.relationships.scholar += 3;
                        return 20;
                    } else {
                        this.outputText("The scholar refuses to talk and flees.", 'fail');
                        return 10;
                    }
                } else {
                    this.outputText("You can't confront that person with the evidence you have.", 'warning');
                    return 5;
                }
            },
            
            showStatus() {
                 const { time, health, cash, debt, gameState, equippedWeapon } = this.state;
                 const timeStr = `Day ${time.day}, ${String(time.hour).padStart(2, '0')}:${String(time.minute).padStart(2, '0')}`;
                 this.outputText(`--- ADVENTURER'S LOG ---`, 'header');
                 this.outputText(` Time: ${timeStr}`);
                 this.outputText(` Health: ${health}/5 | Gold: ${cash} | Debt: ${debt}`);
                 this.outputText(` Notoriety: ${gameState.suspicionLevel}`);
                 this.outputText(` Equipped: ${equippedWeapon.replace(/_/g, ' ')}`);
                 
                 // Contextual stress and hunger feedback
                 this.showContextualStatus();
                 
                 return 0;
            },

            showContextualStatus() {
                const { gameState } = this.state;
                
                // Stress feedback
                if (gameState.stressLevel >= 4) {
                    this.outputText(`<span style="color: #ff6b6b;">*The weight of your quest presses down on your shoulders*</span>`, 'warning');
                    this.outputText(`<span style="color: #ff6b6b;">Thinking to self: "The burden of this investigation is becoming too much to bear. Every step feels heavier, every shadow holds a new threat. I need to find some peace or I'll break under the pressure."</span>`, 'warning');
                } else if (gameState.stressLevel >= 2) {
                    this.outputText(`<span style="color: #ffa500;">*You feel the weight of responsibility settling on your shoulders*</span>`, 'warning');
                    this.outputText(`<span style="color: #ffa500;">Thinking to self: "This case is taking its toll. Maybe I should find a quiet tavern to rest my mind and gather my thoughts."</span>`, 'warning');
                }
                
                // Hunger feedback
                if (gameState.hunger >= 3) {
                    this.outputText(`<span style="color: #ff6b6b;">*Your stomach growls with hunger*</span>`, 'warning');
                    this.outputText(`<span style="color: #ff6b6b;">Thinking to self: "When was the last time I had a proper meal? My body is weak from lack of sustenance. I need to find some food before I collapse."</span>`, 'warning');
                } else if (gameState.hunger >= 1) {
                    this.outputText(`<span style="color: #ffa500;">*You feel a pang of hunger*</span>`, 'warning');
                    this.outputText(`<span style="color: #ffa500;">Thinking to self: "Could use a good meal. Maybe some hearty tavern fare or fresh bread from the market."</span>`, 'warning');
                }
                
                // Health feedback
                if (this.state.health <= 2) {
                    this.outputText(`<span style="color: #ff6b6b;">*You feel death's cold hand reaching for you*</span>`, 'error');
                    this.outputText(`<span style="color: #ff6b6b;">Thinking to self: "I'm barely holding together. One more wound and I might not survive. I need to find a healer or some magical healing, fast."</span>`, 'error');
                } else if (this.state.health <= 3) {
                    this.outputText(`<span style="color: #ffa500;">*You feel the pain of your wounds*</span>`, 'warning');
                    this.outputText(`<span style="color: #ffa500;">Thinking to self: "I'm hurt but not broken. My wounds are healing slowly, but I should be more careful. Maybe some rest or a healing potion would help."</span>`, 'warning');
                }
            },

            updateMoneyDisplay() {
                const moneyDisplay = document.getElementById('money-display');
                if (moneyDisplay) {
                    moneyDisplay.textContent = `${this.state.cash} gold coins`;
                }
            },

            spendMoney(amount, reason = "transaction") {
                const oldCash = this.state.cash;
                this.state.cash -= amount;
                this.updateMoneyDisplay();

                // Show spending notification with fantasy flair
                if (amount > 0) {
                    const fantasyReasons = {
                        "transaction": "mystical transaction",
                        "buy": "merchant acquisition",
                        "bribe": "noble's favor payment",
                        "upgrade": "magical enhancement",
                        "info": "bard's tale purchase",
                        "weapon": "armorer's wares",
                        "medical": "healer's services",
                        "transport": "carriage fare",
                        "food": "tavern meal",
                        "drink": "enchanted ale"
                    };
                    const reasonText = fantasyReasons[reason] || reason;
                    this.outputText(`[GOLD SPENT: -${amount} coins for ${reasonText} | Balance: ${oldCash}  ${this.state.cash} coins]`, 'warning');
                } else if (amount < 0) {
                    // Gained money
                    const gained = Math.abs(amount);
                    const gainReasons = {
                        "payment": "noble's reward",
                        "reward": "quest completion",
                        "sale": "merchant trade",
                        "theft": "treasure liberation",
                        "gambling": "tavern winnings",
                        "info": "intelligence sale",
                        "job": "adventurer's contract"
                    };
                    const reasonText = gainReasons[reason] || reason;
                    this.outputText(`[GOLD GAINED: +${gained} coins from ${reasonText} | Balance: ${oldCash}  ${this.state.cash} coins]`, 'success');
                }
            },

            // --- EPIC FANTASY SYSTEMS ---
            
            handleQuests() {
                this.outputText("--- ACTIVE SIDE QUESTS ---", 'header');
                
                if (this.state.gameState.sideQuests.length === 0) {
                    this.outputText("No active side quests. Keep your eyes open for opportunities.", 'grey');
                    return 0;
                }
                
                this.state.gameState.sideQuests.forEach((quest, index) => {
                    this.outputText(`${index + 1}. ${quest.title}`, 'cyan');
                    this.outputText(`   ${quest.description}`, 'normal');
                    this.outputText(`   Status: ${quest.status}`, 'yellow');
                    if (quest.objectives) {
                        quest.objectives.forEach(obj => {
                            const status = obj.completed ? '' : '';
                            this.outputText(`   ${status} ${obj.description}`, obj.completed ? 'green' : 'grey');
                        });
                    }
                    this.outputText("", 'normal');
                });
                
                return 0;
            },

            handleSkills() {
                this.outputText("--- ADVENTURER'S SKILLS ---", 'header');
                this.outputText(`Skill Points Available: ${this.state.gameState.skillPoints}`, 'cyan');
                this.outputText("", 'normal');
                
                Object.entries(this.state.gameState.skills).forEach(([skill, level]) => {
                    const skillName = skill.charAt(0).toUpperCase() + skill.slice(1).replace(/_/g, ' ');
                    const bar = ''.repeat(level) + ''.repeat(10 - level);
                    this.outputText(`${skillName}: [${bar}] (${level}/10)`, 'normal');
                });
                
                this.outputText("", 'normal');
                this.outputText("Use 'train [skill]' to improve a skill (costs 1 skill point)", 'yellow');
                
                return 0;
            },

            handleReputation() {
                this.outputText("--- REPUTATION TRACKER ---", 'header');
                
                Object.entries(this.state.gameState.reputation).forEach(([group, level]) => {
                    const groupName = group.charAt(0).toUpperCase() + group.slice(1).replace(/_/g, ' ');
                    const bar = level > 0 ? ''.repeat(Math.min(level, 10)) : ''.repeat(Math.min(Math.abs(level), 10));
                    const color = level > 0 ? 'green' : level < 0 ? 'red' : 'grey';
                    this.outputText(`${groupName}: [${bar}] (${level})`, color);
                });
                
                this.outputText("", 'normal');
                this.outputText("Your reputation affects how factions treat you and what opportunities are available.", 'yellow');
                
                return 0;
            },

            handleLore() {
                this.outputText("--- LORE COLLECTION ---", 'header');
                
                const loreItems = this.state.inventory.filter(item => 
                    this.data.items[item] && this.data.items[item].lore
                );
                
                if (loreItems.length === 0) {
                    this.outputText("No lore items in your possession. Look for books, scrolls, and other sources of information.", 'grey');
                    return 0;
                }
                
                loreItems.forEach(item => {
                    this.outputText(` ${item.replace(/_/g, ' ').toUpperCase()}`, 'cyan');
                    this.outputText(`  ${this.data.items[item].desc}`, 'normal');
                    this.outputText("", 'normal');
                });
                
                return 0;
            },

            handleCast(args) {
                if (!args.length) {
                    this.outputText("Cast what? (spell, enchantment, curse, blessing)");
                    return 0;
                }
                
                const spell = args[0].toLowerCase();
                this.outputText(`You begin casting ${spell}...`, 'cyan');
                
                // Spell casting mini-game
                this.startSpellCastingMiniGame(spell);
                
                return 5;
            },

            startSpellCastingMiniGame(spell) {
                this.outputText("--- SPELL CASTING ---", 'header');
                this.outputText(`Casting ${spell}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Spell recitation mini-game
                const spells = {
                    spell: {
                        incantation: "By the power of the ancient ones, I command thee to obey my will!",
                        description: "A basic spell of power and influence"
                    },
                    enchantment: {
                        incantation: "Enchant this object with the magic of the realm!",
                        description: "An enchantment to imbue objects with magical properties"
                    },
                    curse: {
                        incantation: "May the dark forces curse my enemies with misfortune!",
                        description: "A curse to bring bad luck to your enemies"
                    },
                    blessing: {
                        incantation: "May the light of the gods bless this place with peace!",
                        description: "A blessing to bring good fortune and protection"
                    }
                };
                
                const selectedSpell = spells[spell] || spells.spell;
                
                this.outputText("Recite the incantation:", 'yellow');
                this.outputText(`"${selectedSpell.incantation}"`, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Type the incantation exactly as shown:", 'yellow');
                
                // Set up spell casting callback
                this.spellCastingMode = true;
                this.spellCastingSpell = spell;
                this.spellCastingIncantation = selectedSpell.incantation;
            },

            handleEnchant(args) {
                if (!args.length) {
                    this.outputText("Enchant what? (weapon, armor, item)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin enchanting ${target}...`, 'cyan');
                
                // Enchantment mini-game
                this.startEnchantmentMiniGame(target);
                
                return 10;
            },

            startEnchantmentMiniGame(target) {
                this.outputText("--- ENCHANTMENT ---", 'header');
                this.outputText(`Enchanting ${target}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate enchantment
                this.outputText("Channeling magical energy...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** ENCHANTMENT SUCCESSFUL ***", 'green');
                    this.outputText(`${target} is now enchanted!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.magic += 1;
                    this.outputText("+2 Skill Points, +1 Magic Skill", 'green');
                    
                    // Apply enchantment
                    this.applyEnchantment(target);
                    
                }, 3000);
            },

            applyEnchantment(target) {
                this.outputText(`${target} now glows with magical energy.`, 'cyan');
                // Add enchantment to item
                if (this.state.inventory.includes(target)) {
                    this.outputText(`Your ${target} has been enhanced with magical properties.`, 'cyan');
                }
            },

            handleDisenchant(args) {
                if (!args.length) {
                    this.outputText("Disenchant what? (weapon, armor, item)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin disenchanting ${target}...`, 'cyan');
                
                // Disenchantment mini-game
                this.startDisenchantmentMiniGame(target);
                
                return 10;
            },

            startDisenchantmentMiniGame(target) {
                this.outputText("--- DISENCHANTMENT ---", 'header');
                this.outputText(`Disenchanting ${target}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate disenchantment
                this.outputText("Removing magical energy...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** DISENCHANTMENT SUCCESSFUL ***", 'green');
                    this.outputText(`${target} is no longer enchanted.`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.magic += 1;
                    this.outputText("+1 Skill Point, +1 Magic Skill", 'green');
                    
                    // Remove enchantment
                    this.removeEnchantment(target);
                    
                }, 2000);
            },

            removeEnchantment(target) {
                this.outputText(`${target} no longer glows with magical energy.`, 'cyan');
            },

            handleFocus(args) {
                if (!args.length) {
                    this.outputText("Focus on what? (magic, combat, stealth, investigation)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You focus your mind on ${target}...`, 'cyan');
                
                // Focus mini-game
                this.startFocusMiniGame(target);
                
                return 5;
            },

            startFocusMiniGame(target) {
                this.outputText("--- FOCUS ---", 'header');
                this.outputText(`Focusing on ${target}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate focus
                this.outputText("Concentrating your mental energy...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText(`*** FOCUS ON ${target.toUpperCase()} SUCCESSFUL ***`, 'green');
                    this.outputText(`Your ${target} abilities are enhanced!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills[target] += 1;
                    this.outputText(`+1 Skill Point, +1 ${target.charAt(0).toUpperCase() + target.slice(1)} Skill`, 'green');
                    
                    // Apply focus effect
                    this.applyFocusEffect(target);
                    
                }, 1500);
            },

            applyFocusEffect(target) {
                switch (target) {
                    case 'magic':
                        this.outputText("Your magical abilities are enhanced. Spells are more powerful.", 'cyan');
                        break;
                    case 'combat':
                        this.outputText("Your combat abilities are enhanced. You're more accurate and deadly.", 'cyan');
                        break;
                    case 'stealth':
                        this.outputText("Your stealth abilities are enhanced. You're harder to detect.", 'cyan');
                        break;
                    case 'investigation':
                        this.outputText("Your investigation abilities are enhanced. You notice more details.", 'cyan');
                        break;
                }
            },

            handleScry(args) {
                if (!args.length) {
                    this.outputText("Scry what? (person, location, object, future)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin scrying ${target}...`, 'cyan');
                
                // Scrying mini-game
                this.startScryingMiniGame(target);
                
                return 15;
            },

            startScryingMiniGame(target) {
                this.outputText("--- SCRYING ---", 'header');
                this.outputText(`Scrying ${target}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate scrying
                this.outputText("Gazing into the mystical realm...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** SCRYING SUCCESSFUL ***", 'green');
                    
                    const scryingResults = this.getScryingResults(target);
                    this.outputText(`You see: ${scryingResults}`, 'cyan');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.magic += 1;
                    this.outputText("+2 Skill Points, +1 Magic Skill", 'green');
                    
                }, 4000);
            },

            getScryingResults(target) {
                const results = {
                    person: "The target is involved in mysterious activities and has hidden secrets",
                    location: "The location is filled with magical energy and ancient power",
                    object: "The object is imbued with powerful magic and has a dark history",
                    future: "The future holds great danger and opportunity in equal measure"
                };
                
                return results[target] || "Mystical visions and ancient knowledge";
            },

            handleDivine(args) {
                if (!args.length) {
                    this.outputText("Divine what? (truth, lies, magic, danger)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin divining ${target}...`, 'cyan');
                
                // Divination mini-game
                this.startDivinationMiniGame(target);
                
                return 10;
            },

            startDivinationMiniGame(target) {
                this.outputText("--- DIVINATION ---", 'header');
                this.outputText(`Divining ${target}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate divination
                this.outputText("Seeking divine guidance...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** DIVINATION SUCCESSFUL ***", 'green');
                    
                    const divinationResults = this.getDivinationResults(target);
                    this.outputText(`Divine insight: ${divinationResults}`, 'cyan');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.magic += 1;
                    this.outputText("+1 Skill Point, +1 Magic Skill", 'green');
                    
                }, 2500);
            },

            getDivinationResults(target) {
                const results = {
                    truth: "The truth is hidden behind layers of deception and lies",
                    lies: "Deception is everywhere, but the truth can be found with patience",
                    magic: "Powerful magic is at work, but its source is unknown",
                    danger: "Great danger approaches, but so does great opportunity"
                };
                
                return results[target] || "Mystical insights and divine wisdom";
            },

            handleSurveil(args) {
                if (!args.length) {
                    this.outputText("Surveil what? (person, location, building, magical_aura)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin surveilling ${target}...`, 'cyan');
                
                // Surveillance mini-game
                this.startSurveillanceMiniGame(target);
                
                return 20;
            },

            startSurveillanceMiniGame(target) {
                this.outputText("--- SURVEILLANCE ---", 'header');
                this.outputText("Magical surveillance active...", 'yellow');
                this.outputText("", 'normal');
                
                // Simulate surveillance
                this.outputText("Monitoring magical energies...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** SURVEILLANCE COMPLETE ***", 'green');
                    
                    const surveillanceResults = this.getSurveillanceResults(target);
                    this.outputText(`You observe: ${surveillanceResults}`, 'cyan');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+1 Skill Point, +1 Investigation Skill", 'green');
                    
                }, 3000);
            },

            getSurveillanceResults(target) {
                const results = {
                    person: "The target is involved in magical activities and has hidden powers",
                    location: "The location is filled with magical energy and ancient secrets",
                    building: "The building has magical protections and hidden passages",
                    magical_aura: "Powerful magical auras reveal hidden activities and secrets"
                };
                
                return results[target] || "Nothing suspicious observed";
            },

            handleStakeout(args) {
                if (!args.length) {
                    this.outputText("Stakeout what? (location, person, building, magical_site)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin a stakeout of ${target}...`, 'cyan');
                
                // Stakeout mini-game
                this.startStakeoutMiniGame(target);
                
                return 30;
            },

            startStakeoutMiniGame(target) {
                this.outputText("--- STAKEOUT ---", 'header');
                this.outputText("Magical stakeout active. Stay alert...", 'yellow');
                this.outputText("", 'normal');
                
                // Simulate stakeout
                this.outputText("Hours pass...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** STAKEOUT COMPLETE ***", 'green');
                    
                    const stakeoutResults = this.getStakeoutResults(target);
                    this.outputText(`You discover: ${stakeoutResults}`, 'cyan');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+2 Skill Points, +1 Investigation Skill", 'green');
                    
                }, 5000);
            },

            getStakeoutResults(target) {
                const results = {
                    location: "The location is used as a meeting place for magical activities",
                    person: "The target is involved in magical operations and has multiple identities",
                    building: "The building has secret entrances and is used for magical experiments",
                    magical_site: "The magical site is a nexus of power and ancient knowledge"
                };
                
                return results[target] || "Nothing significant observed";
            },

            // --- ADVANCED FANTASY SYSTEMS ---
            
            handleMemory(args) {
                if (!args.length) {
                    this.outputText("Memory what? (test, train, recall, pattern)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You focus your magical memory on ${action}...`, 'cyan');
                
                // Memory mini-game
                this.startMemoryMiniGame(action);
                
                return 5;
            },

            startMemoryMiniGame(action) {
                this.outputText("--- MAGICAL MEMORY CHALLENGE ---", 'header');
                this.outputText(`Testing ${action} memory...`, 'yellow');
                this.outputText("", 'normal');
                
                if (action === 'pattern') {
                    this.startPatternMemoryGame();
                } else if (action === 'sequence') {
                    this.startSequenceMemoryGame();
                } else if (action === 'faces') {
                    this.startFacesMemoryGame();
                } else {
                    this.startGeneralMemoryGame();
                }
            },

            startPatternMemoryGame() {
                this.outputText("Remember this magical pattern:", 'yellow');
                const pattern = this.generateMemoryPattern();
                this.outputText(pattern, 'cyan');
                this.outputText("", 'normal');
                this.outputText("You have 10 seconds to memorize it...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now recreate the pattern:", 'yellow');
                    this.outputText("Type the pattern exactly as shown:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memoryPattern = pattern;
                }, 10000);
            },

            generateMemoryPattern() {
                const symbols = ['', '', '', '', '', '', '', ''];
                let pattern = '';
                for (let i = 0; i < 8; i++) {
                    pattern += symbols[Math.floor(Math.random() * symbols.length)] + ' ';
                }
                return pattern.trim();
            },

            startSequenceMemoryGame() {
                this.outputText("Remember this magical sequence:", 'yellow');
                const sequence = this.generateMemorySequence();
                this.outputText(sequence, 'cyan');
                this.outputText("", 'normal');
                this.outputText("You have 15 seconds to memorize it...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now recreate the sequence:", 'yellow');
                    this.outputText("Type the sequence exactly as shown:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memorySequence = sequence;
                }, 15000);
            },

            generateMemorySequence() {
                const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
                let sequence = '';
                for (let i = 0; i < 6; i++) {
                    sequence += numbers[Math.floor(Math.random() * numbers.length)] + ' ';
                }
                return sequence.trim();
            },

            startFacesMemoryGame() {
                this.outputText("Remember these magical profiles:", 'yellow');
                const faces = this.generateMemoryFaces();
                faces.forEach(face => {
                    this.outputText(face, 'cyan');
                });
                this.outputText("", 'normal');
                this.outputText("You have 20 seconds to memorize them...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now describe the profiles:", 'yellow');
                    this.outputText("Type the descriptions exactly as shown:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memoryFaces = faces;
                }, 20000);
            },

            generateMemoryFaces() {
                const faces = [
                    "Elven mage with silver hair, blue eyes, and glowing runes",
                    "Dwarven warrior with braided beard, brown eyes, and battle scars",
                    "Human bard with golden hair, green eyes, and musical instruments",
                    "Halfling rogue with curly hair, hazel eyes, and nimble fingers"
                ];
                return faces.slice(0, 3);
            },

            startGeneralMemoryGame() {
                this.outputText("Remember this magical information:", 'yellow');
                const info = this.generateMemoryInfo();
                this.outputText(info, 'cyan');
                this.outputText("", 'normal');
                this.outputText("You have 30 seconds to memorize it...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now answer the question:", 'yellow');
                    this.outputText("Type your answer:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memoryInfo = info;
                }, 30000);
            },

            generateMemoryInfo() {
                const info = [
                    "The whispering stone was last touched by Lady Elara at midnight during the full moon",
                    "Ancient texts reveal that the stone was created by the first elven mages",
                    "The stone's power is strongest when the stars align in the constellation of the Dragon",
                    "Witnesses report seeing a hooded figure with glowing eyes near the stone"
                ];
                return info[Math.floor(Math.random() * info.length)];
            },

            handlePuzzle(args) {
                if (!args.length) {
                    this.outputText("Puzzle what? (logic, math, word, visual)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You begin solving a ${type} puzzle...`, 'cyan');
                
                // Puzzle mini-game
                this.startPuzzleMiniGame(type);
                
                return 10;
            },

            startPuzzleMiniGame(type) {
                this.outputText("--- MAGICAL PUZZLE CHALLENGE ---", 'header');
                this.outputText(`Solving ${type} puzzle...`, 'yellow');
                this.outputText("", 'normal');
                
                if (type === 'logic') {
                    this.startLogicPuzzle();
                } else if (type === 'math') {
                    this.startMathPuzzle();
                } else if (type === 'word') {
                    this.startWordPuzzle();
                } else if (type === 'visual') {
                    this.startVisualPuzzle();
                }
            },

            startLogicPuzzle() {
                this.outputText("Magical Logic Puzzle:", 'yellow');
                this.outputText("Three magical creatures: Dragon, Phoenix, and Griffin", 'normal');
                this.outputText("Dragon says: 'Phoenix is lying'", 'normal');
                this.outputText("Phoenix says: 'Griffin is lying'", 'normal');
                this.outputText("Griffin says: 'Dragon is lying'", 'normal');
                this.outputText("", 'normal');
                this.outputText("Which creature is telling the truth?", 'cyan');
                this.outputText("Type your answer (Dragon, Phoenix, or Griffin):", 'yellow');
                
                this.puzzleMode = true;
                this.puzzleType = 'logic';
                this.puzzleAnswer = 'Phoenix';
            },

            startMathPuzzle() {
                this.outputText("Magical Math Puzzle:", 'yellow');
                const a = Math.floor(Math.random() * 10) + 1;
                const b = Math.floor(Math.random() * 10) + 1;
                const c = a + b;
                this.outputText(`If a wizard casts ${a} spells in the first hour`, 'normal');
                this.outputText(`and ${b} spells in the second hour`, 'normal');
                this.outputText(`how many spells did they cast in total?`, 'normal');
                this.outputText("", 'normal');
                this.outputText("Type your answer:", 'cyan');
                
                this.puzzleMode = true;
                this.puzzleType = 'math';
                this.puzzleAnswer = c.toString();
            },

            startWordPuzzle() {
                this.outputText("Magical Word Puzzle:", 'yellow');
                this.outputText("Unscramble this word:", 'normal');
                const word = "MAGICAL";
                const scrambled = this.scrambleWord(word);
                this.outputText(scrambled, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Type the unscrambled word:", 'yellow');
                
                this.puzzleMode = true;
                this.puzzleType = 'word';
                this.puzzleAnswer = word;
            },

            scrambleWord(word) {
                return word.split('').sort(() => Math.random() - 0.5).join('');
            },

            startVisualPuzzle() {
                this.outputText("Magical Visual Puzzle:", 'yellow');
                this.outputText("Count the number of runes in this pattern:", 'normal');
                this.outputText("", 'cyan');
                this.outputText("", 'cyan');
                this.outputText("", 'cyan');
                this.outputText("", 'normal');
                this.outputText("Type your answer:", 'yellow');
                
                this.puzzleMode = true;
                this.puzzleType = 'visual';
                this.puzzleAnswer = '9';
            },

            handleFaction(args) {
                if (!args.length) {
                    this.outputText("Faction what? (status, join, leave, info)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} faction operations...`, 'cyan');
                
                // Faction system
                this.handleFactionAction(action);
                
                return 5;
            },

            handleFactionAction(action) {
                this.outputText("--- FACTION STATUS ---", 'header');
                
                Object.entries(this.state.gameState.factionLoyalty).forEach(([faction, loyalty]) => {
                    const factionName = faction.charAt(0).toUpperCase() + faction.slice(1).replace(/_/g, ' ');
                    const bar = loyalty > 0 ? ''.repeat(Math.min(loyalty, 10)) : ''.repeat(Math.min(Math.abs(loyalty), 10));
                    const color = loyalty > 0 ? 'green' : loyalty < 0 ? 'red' : 'grey';
                    this.outputText(`${factionName}: [${bar}] (${loyalty})`, color);
                });
                
                this.outputText("", 'normal');
                this.outputText("Your faction loyalty affects available opportunities and NPC reactions.", 'yellow');
            },

            handleLoyalty(args) {
                if (!args.length) {
                    this.outputText("Loyalty what? (check, improve, betray)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} loyalty operations...`, 'cyan');
                
                // Loyalty system
                this.handleLoyaltyAction(action);
                
                return 5;
            },

            handleLoyaltyAction(action) {
                this.outputText("--- LOYALTY SYSTEM ---", 'header');
                this.outputText("Your loyalty to different factions affects your reputation and opportunities.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'faction' to check your current standing.", 'cyan');
            },

            handleCraft(args) {
                if (!args.length) {
                    this.outputText("Craft what? (item, tool, weapon, armor)");
                    return 0;
                }
                
                const item = args[0].toLowerCase();
                this.outputText(`You begin crafting ${item}...`, 'cyan');
                
                // Crafting mini-game
                this.startCraftingMiniGame(item);
                
                return 15;
            },

            startCraftingMiniGame(item) {
                this.outputText("--- MAGICAL CRAFTING ---", 'header');
                this.outputText(`Crafting ${item}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate crafting
                this.outputText("Gathering magical materials...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** CRAFTING SUCCESSFUL ***", 'green');
                    this.outputText(`${item} has been crafted!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.magic += 1;
                    this.outputText("+2 Skill Points, +1 Magic Skill", 'green');
                    
                    // Add crafted item
                    this.state.inventory.push(item);
                    this.outputText(`${item} added to inventory.`, 'cyan');
                    
                }, 5000);
            },

            handleEnhance(args) {
                if (!args.length) {
                    this.outputText("Enhance what? (weapon, armor, tool)");
                    return 0;
                }
                
                const item = args[0].toLowerCase();
                this.outputText(`You begin enhancing ${item}...`, 'cyan');
                
                // Enhancement mini-game
                this.startEnhancementMiniGame(item);
                
                return 10;
            },

            startEnhancementMiniGame(item) {
                this.outputText("--- MAGICAL ENHANCEMENT ---", 'header');
                this.outputText(`Enhancing ${item}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate enhancement
                this.outputText("Applying magical improvements...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** ENHANCEMENT SUCCESSFUL ***", 'green');
                    this.outputText(`${item} has been enhanced!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.magic += 1;
                    this.outputText("+1 Skill Point, +1 Magic Skill", 'green');
                    
                    // Apply enhancement
                    this.applyEnhancement(item);
                    
                }, 3000);
            },

            applyEnhancement(item) {
                this.outputText(`${item} is now more effective.`, 'cyan');
            },

            handleRomance(args) {
                if (!args.length) {
                    this.outputText("Romance what? (check, flirt, date, break)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} romance operations...`, 'cyan');
                
                // Romance system
                this.handleRomanceAction(action);
                
                return 5;
            },

            handleRomanceAction(action) {
                this.outputText("--- ROMANCE SYSTEM ---", 'header');
                this.outputText("Your romantic relationships affect your reputation and opportunities.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'flirt' to interact with potential romantic interests.", 'cyan');
            },

            handleFlirt(args) {
                if (!args.length) {
                    this.outputText("Flirt with who? (bard, mage, warrior, rogue)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin flirting with ${target}...`, 'cyan');
                
                // Flirt mini-game
                this.startFlirtMiniGame(target);
                
                return 5;
            },

            startFlirtMiniGame(target) {
                this.outputText("--- MAGICAL FLIRTING ---", 'header');
                this.outputText(`Flirting with ${target}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate flirting
                this.outputText("Making your magical move...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** FLIRTING SUCCESSFUL ***", 'green');
                    this.outputText(`${target} is interested!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.persuasion += 1;
                    this.outputText("+1 Skill Point, +1 Persuasion Skill", 'green');
                    
                    // Apply romance effect
                    this.applyRomanceEffect(target);
                    
                }, 2000);
            },

            applyRomanceEffect(target) {
                this.outputText(`${target} is now more friendly towards you.`, 'cyan');
            },

            handleAchievement(args) {
                if (!args.length) {
                    this.outputText("Achievement what? (list, check, claim)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} achievement operations...`, 'cyan');
                
                // Achievement system
                this.handleAchievementAction(action);
                
                return 0;
            },

            handleAchievementAction(action) {
                this.outputText("--- ACHIEVEMENTS ---", 'header');
                
                if (this.state.gameState.achievements.length === 0) {
                    this.outputText("No achievements yet. Keep playing to unlock them!", 'grey');
                    return 0;
                }
                
                this.state.gameState.achievements.forEach((achievement, index) => {
                    this.outputText(`${index + 1}. ${achievement.name}`, 'cyan');
                    this.outputText(`   ${achievement.description}`, 'normal');
                    this.outputText(`   Status: ${achievement.completed ? 'Completed' : 'In Progress'}`, achievement.completed ? 'green' : 'yellow');
                    this.outputText("", 'normal');
                });
            },

            handleTrophy(args) {
                if (!args.length) {
                    this.outputText("Trophy what? (list, check, display)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} trophy operations...`, 'cyan');
                
                // Trophy system
                this.handleTrophyAction(action);
                
                return 0;
            },

            handleTrophyAction(action) {
                this.outputText("--- TROPHIES ---", 'header');
                
                if (this.state.gameState.trophies.length === 0) {
                    this.outputText("No trophies yet. Keep playing to earn them!", 'grey');
                    return 0;
                }
                
                this.state.gameState.trophies.forEach((trophy, index) => {
                    this.outputText(`${index + 1}. ${trophy.name}`, 'cyan');
                    this.outputText(`   ${trophy.description}`, 'normal');
                    this.outputText(`   Earned: ${trophy.date}`, 'green');
                    this.outputText("", 'normal');
                });
            },

            handleWeather(args) {
                if (!args.length) {
                    this.outputText("Weather what? (check, forecast, change)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} weather operations...`, 'cyan');
                
                // Weather system
                this.handleWeatherAction(action);
                
                return 0;
            },

            handleWeatherAction(action) {
                this.outputText("--- WEATHER SYSTEM ---", 'header');
                this.outputText(`Current weather: ${this.state.gameState.worldState.weather}`, 'cyan');
                this.outputText(`Temperature: ${this.state.gameState.worldState.temperature}`, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Weather affects NPC behavior and available activities.", 'yellow');
            },

            handleForecast(args) {
                if (!args.length) {
                    this.outputText("Forecast what? (weather, crime, activity)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You check the ${type} forecast...`, 'cyan');
                
                // Forecast system
                this.handleForecastAction(type);
                
                return 0;
            },

            handleForecastAction(type) {
                this.outputText("--- FORECAST ---", 'header');
                this.outputText(`${type.charAt(0).toUpperCase() + type.slice(1)} forecast:`, 'cyan');
                this.outputText("", 'normal');
                
                if (type === 'weather') {
                    this.outputText("Tomorrow: Mystical fog with a chance of rain", 'normal');
                    this.outputText("Day after: Clear skies with magical aurora", 'normal');
                } else if (type === 'crime') {
                    this.outputText("Tomorrow: Moderate crime activity expected", 'normal');
                    this.outputText("Day after: Low crime levels", 'normal');
                } else if (type === 'activity') {
                    this.outputText("Tomorrow: Busy day for magical operations", 'normal');
                    this.outputText("Day after: Quiet day, good for meditation", 'normal');
                }
            },

            handleEconomy(args) {
                if (!args.length) {
                    this.outputText("Economy what? (check, trade, invest)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} economy operations...`, 'cyan');
                
                // Economy system
                this.handleEconomyAction(action);
                
                return 0;
            },

            handleEconomyAction(action) {
                this.outputText("--- ECONOMY ---", 'header');
                this.outputText(`Current inflation: ${this.state.gameState.economy.inflation}x`, 'cyan');
                this.outputText(`Black market access: ${this.state.gameState.economy.blackMarket ? 'Yes' : 'No'}`, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Economic conditions affect item prices and availability.", 'yellow');
            },

            handleTrade(args) {
                if (!args.length) {
                    this.outputText("Trade what? (items, information, favors)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You begin trading ${type}...`, 'cyan');
                
                // Trading mini-game
                this.startTradingMiniGame(type);
                
                return 10;
            },

            startTradingMiniGame(type) {
                this.outputText("--- MAGICAL TRADING ---", 'header');
                this.outputText(`Trading ${type}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate trading
                this.outputText("Negotiating magical terms...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** TRADING SUCCESSFUL ***", 'green');
                    this.outputText(`${type} trade completed!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.persuasion += 1;
                    this.outputText("+1 Skill Point, +1 Persuasion Skill", 'green');
                    
                    // Apply trade effect
                    this.applyTradeEffect(type);
                    
                }, 3000);
            },

            applyTradeEffect(type) {
                this.outputText(`You've gained valuable ${type}.`, 'cyan');
            },

            handleCombat(args) {
                if (!args.length) {
                    this.outputText("Combat what? (attack, defend, tactics, special)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} combat operations...`, 'cyan');
                
                // Combat system
                this.handleCombatAction(action);
                
                return 5;
            },

            handleCombatAction(action) {
                this.outputText("--- COMBAT SYSTEM ---", 'header');
                this.outputText("Your combat abilities affect your effectiveness in confrontations.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'tactics' to plan your approach.", 'cyan');
            },

            handleTactics(args) {
                if (!args.length) {
                    this.outputText("Tactics what? (plan, execute, review)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} tactical operations...`, 'cyan');
                
                // Tactics mini-game
                this.startTacticsMiniGame(action);
                
                return 10;
            },

            startTacticsMiniGame(action) {
                this.outputText("--- MAGICAL TACTICS ---", 'header');
                this.outputText(`Planning ${action}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate tactics
                this.outputText("Analyzing magical situation...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** TACTICS SUCCESSFUL ***", 'green');
                    this.outputText(`${action} plan executed!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.combat += 1;
                    this.outputText("+1 Skill Point, +1 Combat Skill", 'green');
                    
                    // Apply tactics effect
                    this.applyTacticsEffect(action);
                    
                }, 2000);
            },

            applyTacticsEffect(action) {
                this.outputText(`Your ${action} approach is now more effective.`, 'cyan');
            },

            handleMystery(args) {
                if (!args.length) {
                    this.outputText("Mystery what? (solve, clue, suspect, timeline)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} mystery operations...`, 'cyan');
                
                // Mystery system
                this.handleMysteryAction(action);
                
                return 5;
            },

            handleMysteryAction(action) {
                this.outputText("--- MYSTERY SYSTEM ---", 'header');
                this.outputText("Your mystery-solving abilities affect your investigation effectiveness.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'clue' to analyze evidence.", 'cyan');
            },

            handleClue(args) {
                if (!args.length) {
                    this.outputText("Clue what? (analyze, connect, verify)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} clue operations...`, 'cyan');
                
                // Clue mini-game
                this.startClueMiniGame(action);
                
                return 10;
            },

            startClueMiniGame(action) {
                this.outputText("--- MAGICAL CLUE ANALYSIS ---", 'header');
                this.outputText(`Analyzing ${action}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate clue analysis
                this.outputText("Examining magical evidence...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** CLUE ANALYSIS SUCCESSFUL ***", 'green');
                    this.outputText(`${action} analysis complete!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+1 Skill Point, +1 Investigation Skill", 'green');
                    
                    // Apply clue effect
                    this.applyClueEffect(action);
                    
                }, 3000);
            },

            applyClueEffect(action) {
                this.outputText(`You've gained new insights from ${action}.`, 'cyan');
            },
            
            async typeWriter(text, className = 'normal', speed = 15) {
                const p = document.createElement('p');
                if (className === 'header') p.style.color = 'var(--accent-color)';
                else if (className === 'cyan') p.style.color = '#5a7a7a'; // Muted Teal for magical feel
                else if (className === 'green') p.style.color = '#5a8a5a'; // Forest Green
                else if (className === 'fail') p.style.color = '#a84a4a'; // Muted Red
                else if (className === 'warning') p.style.color = '#a87e4a'; // Muted gold
                else if (className === 'grey') p.style.color = '#6b665e'; // Stony grey
                else p.style.color = 'var(--text-color)';
                output.appendChild(p);
                for (let i = 0; i < text.length; i++) {
                    p.innerHTML += text.charAt(i);
                    output.scrollTop = output.scrollHeight;
                    await new Promise(resolve => setTimeout(resolve, speed));
                }
                 output.scrollTop = output.scrollHeight;
            },
            outputText(text, className = 'normal', indent = 0) {
                const p = document.createElement('div');
                 if (className === 'header') p.style.color = 'var(--accent-color)';
                else if (className === 'cyan') p.style.color = '#5a7a7a';
                else if (className === 'green') p.style.color = '#5a8a5a';
                else if (className === 'fail') p.style.color = '#a84a4a';
                else if (className === 'warning') p.style.color = '#a87e4a';
                else if (className === 'grey') p.style.color = '#6b665e';
                p.style.paddingLeft = `${indent * 4}px`;
                // Use innerHTML if text contains HTML tags, otherwise use textContent
                if (text.includes('<span class="npc-name">')) {
                    p.innerHTML = text;
                } else {
                    p.textContent = text;
                }
                output.appendChild(p);
                output.scrollTop = output.scrollHeight;
            },
            wrapText(text, indent = 0) {
                if (!text || typeof text !== 'string') {
                    return '';
                }
                const prefix = ' '.repeat(indent);
                const width = 80;
                let wrappedText = '';
                const lines = text.split('\n');
                for (const line of lines) {
                    let currentLine = prefix;
                    const words = line.split(' ');
                    for (const word of words) {
                        if ((currentLine + word).length > width) {
                            wrappedText += currentLine.trimEnd() + '\n';
                            currentLine = prefix + word + ' ';
                        } else { currentLine += word + ' '; }
                    }
                    wrappedText += currentLine.trimEnd() + '\n';
                }
                return wrappedText.trim();
            },
            getIntroText() {
                return this.wrapText(`The rain is a constant drumbeat on the cobblestone streets. It's a rhythm you know well. Another bounty, another crooked noble, another reason to wish you'd taken up farming. But you didn't. You're a padfoot. On your table, a royal scroll sits, its title mocking you in the dim candlelight:\n\n'THE CASE OF THE WHISPERING STONE'\n\n(Type 'help' for a list of commands)`);
            },
            posKey() {
                return `${this.state.playerPos.x},${this.state.playerPos.y},${this.state.playerPos.z}`;
            },
            // --- SAVE/LOAD (Database-backed) ---
            async saveGame(saveName = 'Auto Save') {
                try {
                    // Try to save with authentication first
                    const authToken = localStorage.getItem('authToken');
                    const saveData = {
                        gameType: 'fantasy',
                        saveName: saveName,
                        gameState: this.state,
                        variant: 'padfoot'
                    };

                    let response;
                    if (authToken) {
                        // Authenticated save
                        response = await fetch(`${API_BASE_URL}/api/games/save`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${authToken}`,
                                'Content-Type': 'application/json'
                            },
                            credentials: 'include',
                            body: JSON.stringify(saveData)
                        });
                    } else {
                        // Local storage fallback for demo/testing
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '{}');
                        saves[saveName] = {
                            gameState: this.state,
                            timestamp: new Date().toISOString(),
                            variant: 'padfoot'
                        };
                        localStorage.setItem('gumshoe_saves', JSON.stringify(saves));
                        this.outputText(`You commit your journey to memory as "${saveName}". (Demo mode)`, 'success');
                        return true;
                    }

                    if (response.ok) {
                        this.outputText(`You commit your journey to memory as "${saveName}".`, 'success');
                        return true;
                    } else {
                        // Fallback to local storage if server save fails
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '{}');
                        saves[saveName] = {
                            gameState: this.state,
                            timestamp: new Date().toISOString(),
                            variant: 'padfoot'
                        };
                        localStorage.setItem('gumshoe_saves', JSON.stringify(saves));
                        this.outputText(`You commit your journey to memory as "${saveName}". (Server unavailable)`, 'warning');
                        return true;
                    }
                } catch (error) {
                    console.error('Error saving game:', error);
                    // Fallback to local storage
                    try {
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '{}');
                        const saveName = args.length > 0 ? args.join(' ') : 'Auto Save';
                        saves[saveName] = {
                            gameState: this.state,
                            timestamp: new Date().toISOString(),
                            variant: 'padfoot'
                        };
                        localStorage.setItem('gumshoe_saves', JSON.stringify(saves));
                        this.outputText(`You commit your journey to memory as "${saveName}". (Network error)`, 'warning');
                        return true;
                    } catch (localError) {
                        this.outputText('Error saving game: ' + error.message, 'error');
                        return false;
                    }
                }
            },

            async loadGame(saveName) {
                try {
                    const authToken = localStorage.getItem('authToken');
                    if (!authToken) {
                        this.outputText("You must be logged in to load games.", 'error');
                        return false;
                    }

                    const response = await fetch(`${API_BASE_URL}/api/games/load/fantasy/${encodeURIComponent(saveName)}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        // Restore the full state, not just gameState
                        this.state = { ...this.state, ...data.gameState };
                        output.innerHTML = '';
                        this.outputText(`You recall your past deeds from "${saveName}"...`, 'success');
                        this.outputText("--- MEMORY RESTORED ---", 'header');
                        this.outputText(`Location: ${this.getCurrentRoom().name}`, 'cyan');
                        this.outputText(`Gold: ${this.state.cash}`, 'cyan');
                        this.outputText(`Health: ${this.state.health}/5`, 'cyan');
                        this.outputText("", 'normal');
                        this.handleLook([]);
                        this.showStatus();
                        input.disabled = false;
                        return true;
                    } else {
                        const error = await response.json();
                        this.outputText(`Load failed: ${error.message}`, 'error');
                        return false;
                    }
                } catch (error) {
                    this.outputText(`Load failed: ${error.message}`, 'error');
                    return false;
                }
            },

            async listSaves() {
                try {
                    const authToken = localStorage.getItem('authToken');
                    if (!authToken) {
                        this.outputText("You must be logged in to list saves.", 'error');
                        return;
                    }

                    const response = await fetch(`${API_BASE_URL}/api/games/saves/fantasy`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (response.ok) {
                        const saves = await response.json();
                        this.outputText("--- YOUR SAVED MEMORIES ---", 'header');
                        if (saves.length === 0) {
                            this.outputText("No saved memories found.", 'normal');
                        } else {
                            saves.forEach(save => {
                                const date = new Date(save.updated_at).toLocaleString();
                                this.outputText(` ${save.save_name} (${date})`, 'cyan');
                            });
                        }
                        this.outputText("", 'normal');
                        this.outputText("Use 'load <save_name>' to recall a memory.", 'green');
                    } else {
                        const error = await response.json();
                        this.outputText(`Failed to list saves: ${error.message}`, 'error');
                    }
                } catch (error) {
                    this.outputText(`Failed to list saves: ${error.message}`, 'error');
                }
            },

            async deleteSave(saveName) {
                try {
                    const authToken = localStorage.getItem('authToken');
                    if (!authToken) {
                        this.outputText("You must be logged in to delete saves.", 'error');
                        return false;
                    }

                    const response = await fetch(`${API_BASE_URL}/api/games/delete/fantasy/${encodeURIComponent(saveName)}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (response.ok) {
                        this.outputText(`Memory "${saveName}" forgotten successfully.`, 'success');
                        return true;
                    } else {
                        const error = await response.json();
                        this.outputText(`Delete failed: ${error.message}`, 'error');
                        return false;
                    }
                } catch (error) {
                    this.outputText(`Delete failed: ${error.message}`, 'error');
                    return false;
                }
            },

            // Enhanced command handlers
            handleSave(args) {
                const saveName = args.length > 0 ? args.join(' ') : 'Auto Save';
                this.saveGame(saveName);
                return 0;
            },

            handleLoad(args) {
                if (!args.length) {
                    this.outputText("Recall which memory? Use 'saves' to see available memories.", 'error');
                    return 0;
                }
                const saveName = args.join(' ');
                this.loadGame(saveName);
                return 0;
            },

            handleSaves() {
                this.listSaves();
                return 0;
            },

            handleDeleteSave(args) {
                if (!args.length) {
                    this.outputText("Forget which memory? Use 'saves' to see available memories.", 'error');
                    return 0;
                }
                const saveName = args.join(' ');
                this.deleteSave(saveName);
                return 0;
            },

            handleAttack(args) {
                if (!args.length) {
                    this.outputText("Attack what?");
                    return 0;
                }
                
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, Object.keys(room.npcs || {}));
                
                if (!targetName) {
                    this.outputText(`You don't see ${args.join(' ')} here.`);
                    return 0;
                }
                
                // Combat system
                const playerStrength = this.state.attributes.strength;
                const targetStrength = Math.floor(Math.random() * 10) + 5; // NPC strength
                
                this.outputText(`You attack ${targetName}!`);
                
                if (playerStrength > targetStrength) {
                    this.outputText(`${targetName} is defeated! You gain experience.`);
                    this.state.gameState.experience = (this.state.gameState.experience || 0) + 10;
                    this.state.attributes.strength += 1;
                } else {
                    this.outputText(`${targetName} fights back! You take damage.`);
                    this.state.health -= 2;
                }
                
                if (this.state.health <= 0) {
                    this.outputText("You have been defeated!");
                    this.state.gameOver = true;
                }
                return 5;
            },

            handleEquip(args) {
                if (!args.length) {
                    this.outputText("Equip what?");
                    return 0;
                }
                
                const item = args.join(' ').toLowerCase();
                
                if (!this.state.inventory.includes(item)) {
                    this.outputText(`You don't have ${item}.`);
                    return 0;
                }
                
                // Check if item is a weapon by looking at game data
                const itemData = this.data.items[item];
                const isWeapon = itemData && (itemData.type === 'weapon' || itemData.damage || item.includes('sword') || item.includes('knife') || item.includes('staff') || item.includes('wand') || item.includes('bow') || item.includes('axe') || item.includes('dagger') || item.includes('club') || item.includes('mace'));
                
                if (isWeapon) {
                    this.state.equippedWeapon = item;
                    this.outputText(`You equip ${item}.`);
                } else {
                    this.outputText(`${item} is not a weapon.`);
                }
                return 0;
            },

            handleUnequip() {
                if (this.state.equippedWeapon) {
                    this.outputText(`You unequip ${this.state.equippedWeapon}.`);
                    this.state.equippedWeapon = null;
                } else {
                    this.outputText("You're not equipping anything.");
                }
                return 0;
            },

            handleGive(args) {
                if (args.length < 2) {
                    this.outputText("Usage: give <item> to <npc>");
                    return 0;
                }
                
                const itemIndex = args.indexOf('to');
                if (itemIndex === -1 || itemIndex === 0 || itemIndex === args.length - 1) {
                    this.outputText("Usage: give <item> to <npc>");
                    return 0;
                }
                
                const item = args.slice(0, itemIndex).join(' ').toLowerCase();
                const npc = args.slice(itemIndex + 1).join(' ').toLowerCase();
                
                if (!this.state.inventory.includes(item)) {
                    this.outputText(`You don't have ${item}.`);
                    return 0;
                }
                
                const room = this.getCurrentRoom();
                
                if (!room.npcs || !Object.keys(room.npcs).includes(npc)) {
                    this.outputText(`You don't see ${npc} here.`);
                    return 0;
                }
                
                // Remove item from inventory
                const itemIndex_inv = this.state.inventory.indexOf(item);
                this.state.inventory.splice(itemIndex_inv, 1);
                
                this.outputText(`You give ${item} to ${npc}.`);
                
                // NPC reactions based on item
                if (item === 'gold' && npc === 'bartender') {
                    this.outputText("The bartender nods appreciatively. 'Thanks, traveler. Maybe I can help you with some information.'");
                    this.state.charisma += 1;
                } else if (item === 'ale' && npc === 'bartender') {
                    this.outputText("The bartender smiles. 'A man after my own heart. What can I tell you?'");
                } else {
                    this.outputText(`${npc} accepts the ${item} but doesn't seem particularly interested.`);
                }
                return 0;
            }
        };

        game.data = {
            worldMap: {
                // Starting area - Hideout
                '0,0,0': { 
                    name: "Your Hideout", 
                    baseDesc: "Your cramped room in the city's underbelly. The window looks out onto a grimy alley. A flickering hearth provides the only light.", 
                    items: ["bounty_notice", "flagon_of_mead"], 
                    features: ["scribe_desk", "flickering_hearth", "loose_floorboard"],
                    exitsOverride: {'e': [1, 0, 0], 's': [0, -1, 0]}
                },
                
                // Residential District
                '1,0,0': { 
                    name: "Elara's Apothecary", 
                    baseDesc: "A small shop smelling of herbs and strange potions. Jars of colorful liquids and dried plants line the shelves.", 
                    items: ["healing_potion"], 
                    npcs: {"Elara": "A woman with kind eyes grinds herbs with a mortar and pestle. 'In need of healing?'"},
                    exitsOverride: {'w': [0, 0, 0], 'e': [2, 0, 0], 's': [1, -1, 0]}
                },
                '2,0,0': { 
                    name: "Residential Street", 
                    baseDesc: "A quiet street lined with modest homes. Smoke rises from chimneys and the sound of children playing can be heard.", 
                    features: ["well", "flower_garden"],
                    exitsOverride: {'w': [1, 0, 0], 'e': [3, 0, 0], 's': [2, -1, 0]}
                },
                '3,0,0': { 
                    name: "The Prancing Pony Inn", 
                    baseDesc: "A cozy inn with warm lighting and the sound of merry conversation. The smell of roasted meat and ale fills the air. Through the window, you can see airships docking at the skyport in the distance.", 
                    features: ["bar_counter", "fireplace"],
                    npcs: {"Thorgath": "The innkeeper, a burly dwarf named Thorgath, cleans a tankard. 'What can I get for ye, traveler?'"},
                    exitsOverride: {'w': [2, 0, 0], 's': [3, -1, 0]}
                },
                
                // Market District
                '0,-1,0': { 
                    name: "The King's Plaza", 
                    baseDesc: "The rain falls on the cobblestones of the main city plaza. The grand cathedral looms in the distance. High above, you can see the silhouette of an airship passing through the clouds.", 
                    features: ["sewer_grate", "statue_of_king"],
                    npcs: {"Licey Lacey": "A beggar in rags looks up at you with weary eyes. 'Spare a coin? I've seen things... glowing things... down by the Guild warehouses.'"},
                    exitsOverride: {'n': [0, 0, 0], 's': [0, -2, 0], 'e': [1, -1, 0], 'w': [-1, -1, 0], 'd': [0, -1, -1]} 
                },
                '1,-1,0': { 
                    name: "Market Square", 
                    baseDesc: "A bustling marketplace filled with vendors selling their wares. The air is filled with the sounds of haggling and the smells of food. In the shadows, a large orc in a weathered trench coat glowers at passersby.", 
                    features: ["fountain", "merchant_stalls"],
                    npcs: {"Barnaby": "Barnaby, the old shopkeeper, peers at you over his spectacles. 'Looking for something... unusual, are we?'", "Nwar-Gom'shu": "A massive orc in a tattered trench coat stands in the shadows, his yellow eyes following your movements. He grumbles something under his breath about 'city folk' and 'their fancy ways'."},
                    exitsOverride: {'n': [1, 0, 0], 's': [1, -2, 0], 'e': [2, -1, 0], 'w': [0, -1, 0]}
                },
                '2,-1,0': { 
                    name: "Artisan Quarter", 
                    baseDesc: "The sound of hammers and the smell of hot metal fills the air. Craftsmen work at their forges and workshops.", 
                    features: ["blacksmith_forge", "carpenter_shop"],
                    npcs: {"Gareth": "A burly dwarf blacksmith with soot-stained clothes works at his forge. 'What do you want? I'm busy!'"},
                    exitsOverride: {'n': [2, 0, 0], 's': [2, -2, 0], 'w': [1, -1, 0], 'e': [3, -1, 0]}
                },
                '3,-1,0': { 
                    name: "Guild District", 
                    baseDesc: "Imposing buildings house the various guilds. Guards patrol the area and the sound of training can be heard.", 
                    features: ["guild_hall", "training_grounds"],
                    npcs: {"Captain Marcus": "A stern human guard captain stands at attention. 'This is a restricted area. State your business.'"},
                    exitsOverride: {'n': [3, 0, 0], 's': [3, -2, 0], 'w': [2, -1, 0]}
                },
                
                // Lower District
                '0,-2,0': { 
                    name: "The Murky Alley", 
                    baseDesc: "A dark alley reeking of refuse and desperation. A pile of discarded crates sits in the corner.", 
                    items: ["tattered_proclamation"], 
                    features: ["crates", "sewer_entrance"],
                    exitsOverride: {'n': [0, -1, 0], 's': [0, -3, 0], 'e': [1, -2, 0], 'w': [-1, -2, 0]}
                },
                '1,-2,0': { 
                    name: "Warehouse District", 
                    baseDesc: "Large warehouses line the street. The sound of loading and unloading can be heard from within.", 
                    features: ["warehouse_doors", "loading_docks"],
                    npcs: {"Guardsman Mulner": "A stern-faced guard in the king's livery stands at attention. 'This is a restricted area. State your business.'"},
                    exitsOverride: {'n': [1, -1, 0], 's': [1, -3, 0], 'e': [2, -2, 0], 'w': [0, -2, 0]}
                },
                '2,-2,0': { 
                    name: "Docks", 
                    baseDesc: "The harbor stretches out before you. Ships are moored at the piers and sailors go about their business.", 
                    features: ["pier", "ships"],
                    npcs: {"Whispers": "A cloaked figure, known only as Whispers, lurks in the shadows. 'Information is a valuable commodity. Got the coin?'"},
                    exitsOverride: {'n': [2, -1, 0], 's': [2, -3, 0], 'w': [1, -2, 0], 'e': [3, -2, 0]}
                },
                '3,-2,0': { 
                    name: "Old Quarter", 
                    baseDesc: "Ancient buildings with crumbling facades. The area has an air of mystery and forgotten secrets.", 
                    features: ["old_tower", "ancient_rune"],
                    exitsOverride: {'n': [3, -1, 0], 's': [3, -3, 0], 'w': [2, -2, 0]}
                },
                
                // Underground
                '0,-1,-1': { 
                    name: "Sewer Tunnels", 
                    baseDesc: "Dark, damp tunnels filled with the sound of dripping water and the occasional scurrying of rats.", 
                    features: ["ancient_door", "mysterious_pool"],
                    npcs: {"Seer": "A blindfolded oracle sits before a swirling pool of water. 'The threads of fate are tangled. The answer you seek is not the one you expect.'"},
                    exitsOverride: {'u': [0, -1, 0], 'e': [1, -1, -1], 'w': [-1, -1, -1]}
                },
                '1,-1,-1': { 
                    name: "Underground Chamber", 
                    baseDesc: "A large underground chamber with ancient stonework. Strange symbols are carved into the walls.", 
                    features: ["altar", "ancient_tome"],
                    exitsOverride: {'w': [0, -1, -1], 'e': [2, -1, -1]}
                },
                '2,-1,-1': { 
                    name: "Secret Passage", 
                    baseDesc: "A hidden passage that leads deeper into the underground. The air is thick with ancient magic.", 
                    features: ["magical_barrier", "crystal_formation"],
                    exitsOverride: {'w': [1, -1, -1]}
                },
                
                // Additional locations
                '-1,-1,0': { 
                    name: "The Weary Dragon Inn", 
                    baseDesc: "The inn is filled with the sounds of rowdy patrons and the smell of stale ale. A large hearth crackles in the corner.", 
                    features: ["bar_counter", "gambling_table"],
                    npcs: {"Licey Lacey": "A beggar in rags looks up at you with weary eyes. 'Spare a coin? I've seen things... glowing things... down by the Guild warehouses.'"},
                    exitsOverride: {'e': [0, -1, 0], 's': [-1, -2, 0]}
                },
                '-1,-2,0': { 
                    name: "Beggar's Row", 
                    baseDesc: "A narrow street where the city's poorest residents make their home. Makeshift shelters line the walls.", 
                    features: ["makeshift_shelters", "communal_fire"],
                    exitsOverride: {'n': [-1, -1, 0], 'e': [0, -2, 0]}
                },
                '-1,-1,-1': { 
                    name: "Hidden Catacombs", 
                    baseDesc: "Ancient catacombs filled with the bones of the long-dead. The air is thick with dust and mystery.", 
                    features: ["ancient_sarcophagi", "mysterious_inscription"],
                    exitsOverride: {'e': [0, -1, -1]}
                }
            },
            items: {
                "bounty_notice": {
                    desc: "A royal scroll of finest vellum, sealed with the king's personal wax seal bearing the royal crest - a golden crown wreathed in mystical flames. The parchment itself seems to pulse with divine authority, its edges trimmed in threads of pure gold that catch the light like captured starlight. The calligraphy flows across the page like liquid silver, detailing the bounty on the 'Whispering Stone' - a reward so vast it could buy a small kingdom. The words seem to shift and shimmer as you read them, as if the very ink contains traces of royal magic. This isn't just a bounty notice; it's a piece of the kingdom's soul, written in the blood of dragons and blessed by the high priests.",
                    takeable: true
                },
                "flagon_of_mead": {
                    desc: "A heavy pewter flagon, its surface etched with ancient dwarven runes that tell the story of a thousand battles and a thousand toasts. The mead within is no ordinary drink - it's the legendary 'Dragon's Breath Mead,' brewed in the deep mountain halls by master brewers who learned their craft from the gods themselves. The liquid glows with a warm amber light, and when you hold it to your nose, you catch hints of honey from the golden fields of Valhalla, spices from the far eastern lands, and something else - a taste of pure magic that makes your blood sing and your spirit soar. One sip and you feel the strength of a hundred warriors coursing through your veins.",
                    takeable: true
                },
                "iron-banded_chest": {
                    desc: "A massive chest of ancient oak, its surface blackened by centuries of smoke and stained by the blood of countless adventurers who tried to breach its secrets. The iron bands that bind it are not mere metal - they're forged from the heart of a fallen star, cooled in the tears of a thousand widows, and blessed by the high priest of the forge god. The lock itself is a masterpiece of dwarven engineering, a complex mechanism of interlocking gears and mystical wards that would challenge even the most skilled thief. The chest hums with contained power, and you can feel the weight of whatever treasures lie within pressing against the wood like a living thing fighting to be free.",
                    takeable: true
                },
                "enchanted_tome": {
                    desc: "A tome of such ancient power that it seems to exist in multiple dimensions simultaneously, its leather binding shifting between the hides of dragons, demons, and celestial beings. The runes on its cover don't just glow - they dance and writhe like living things, spelling out secrets that change each time you look at them. The pages are made from the skin of the first wizard, and the ink is distilled from the essence of pure magic itself. When you open it, the air around you crackles with energy, and you can hear the whispers of a thousand spellcasters who have studied its pages before you. This isn't just a book; it's a gateway to the fundamental forces that shape reality.",
                    takeable: true
                },
                "scrying_orb": {
                    desc: "A perfect sphere of obsidian so dark it seems to absorb light itself, yet it pulses with an inner radiance that shifts through every color of the rainbow and many that don't exist in the mortal realm. The orb is warm to the touch, and when you hold it, you can feel the heartbeat of the universe itself. It hums with the harmonics of a thousand different dimensions, and if you listen closely, you can hear the voices of the gods themselves whispering secrets that were never meant for mortal ears. The orb doesn't just show you the present - it shows you the past, the future, and all the possible paths that reality might take. It's a window into the very soul of existence.",
                    takeable: true
                },
                "leather_jerkin": {
                    desc: "A jerkin of the finest dragonhide, tanned by master craftsmen who learned their art from the elves of the deep forests. The leather is supple as silk yet strong as steel, and it's been enchanted with protective runes that glow faintly in the darkness. The jerkin has seen countless battles and bears the scars of a hundred adventures - each mark tells a story of danger faced and overcome. It fits you like a second skin, and when you wear it, you feel the courage of all the heroes who wore it before you flowing through your veins. This isn't just armor; it's a piece of living history, a companion that will stand by you through the darkest of times.",
                    takeable: true
                },
                "tattered_proclamation": {
                    desc: "A proclamation that has been through hell and back, its parchment torn and stained by rain, blood, and the tears of those who read its dire warnings. The ink runs in rivulets down the page like black tears, but the words still burn with the authority of the royal court. It warns of a crackdown on unauthorized magic use in the warehouse district, but between the lines, you can read the real message - the kingdom is afraid. Afraid of the power that magic represents, afraid of the change it brings, afraid of the future it promises. This isn't just a proclamation; it's a declaration of war against the very forces that make life worth living.",
                    takeable: true
                },
                "crowbar": {
                    desc: "A crowbar forged from the iron of a fallen meteor, its surface etched with runes of strength and determination. The metal sings with the memory of a thousand battles, and when you grip it, you can feel the power of the earth itself flowing through your hands. This isn't just a tool - it's a weapon of justice, a tool of liberation, a key that opens the doors that others would keep closed. The crowbar has been blessed by the forge god himself, and it will never break, never bend, never fail you when you need it most. It's a symbol of the common folk's determination to stand up to the powers that would oppress them.",
                    takeable: true
                },
                "rusty_iron_key": {
                    desc: "A key that has been lost to time, its surface pitted and corroded by centuries of neglect. The metal is cold to the touch, and when you hold it, you can feel the weight of all the secrets it has kept locked away. The key was forged in the fires of the old kingdom, before the fall, before the dark times, when magic flowed freely and the gods walked among mortals. It's a piece of history, a relic of a better time, and it holds the power to unlock not just doors, but the very mysteries of the past. This key is more than metal - it's hope itself, forged into physical form.",
                    takeable: true
                },
                "masterwork_key": {
                    desc: "A key of such exquisite craftsmanship that it seems to have been forged by the gods themselves. The metal is a perfect alloy of silver, gold, and mithril, and it catches the light like a captured star. The intricate patterns etched into its surface tell the story of a thousand locks and a thousand treasures, and the key itself seems to pulse with the power of all the secrets it has ever unlocked. This key was made by the master locksmiths of the ancient kingdom, and it can open any lock, any door, any secret that has ever been hidden from mortal eyes. It's not just a key - it's a symbol of the power of knowledge, of the right to know the truth.",
                    takeable: true
                },
                "coded_parchment": {
                    desc: "A parchment that seems to exist in multiple layers of reality, its surface shifting between different forms of writing as you try to read it. The words dance across the page like living things, and the message 'The truth is not in the manifest, but in the glow' appears to be written in the very essence of truth itself. The parchment is warm to the touch, and when you hold it, you can feel the weight of all the secrets it contains pressing against your mind. This isn't just a note - it's a key to understanding the very nature of reality, a clue that could unlock the mysteries of the universe itself.",
                    takeable: true
                },
                "smuggler's_ledger": {
                    desc: "A ledger that tells the story of a thousand illegal transactions, its pages stained with the sweat of fear and the ink of desperation. The coded entries shift and change as you read them, revealing new secrets with each passing moment. 'Shipment 7 - Glowing cargo - Dock 3 - Midnight' is just the beginning - the ledger contains the names of every smuggler, every corrupt official, every person who has ever profited from the illegal trade in magical artifacts. It's a map of the underworld, a guide to the hidden economy that keeps the kingdom running. This ledger is more than just a book - it's a weapon that could topple governments and bring down kings.",
                    takeable: true
                },
                "healing_potion": {
                    desc: "A vial of liquid that seems to contain the very essence of life itself, its contents shimmering with every color of the rainbow and many that don't exist in the mortal realm. The potion smells of strawberries and cinnamon, but also of hope, of courage, of the will to survive against all odds. When you hold it up to the light, you can see tiny sparks of magic dancing within the liquid, and if you listen closely, you can hear the whispers of the healers who created it, their prayers for your recovery echoing through the ages. This isn't just a potion - it's a piece of the divine, a gift from the gods themselves, a reminder that even in the darkest of times, there is always hope.",
                    takeable: true
                }
            },
            features: {
                "scribe_desk": { desc: "A desk of ancient oak, its surface worn smooth by centuries of quill strokes and the weight of countless secrets. The quill that rests upon it is no ordinary writing instrument - it's a feather from the wing of a phoenix, and the ink in the pot beside it is distilled from the tears of a thousand poets. Half-finished letters lie scattered across the desk like fallen leaves, each one containing fragments of stories that will never be told, secrets that will never be revealed. The desk itself seems to pulse with the energy of all the words that have been written upon it, and when you touch it, you can feel the weight of history itself pressing against your fingertips." },
                "flickering_hearth": { desc: "A hearth of stone that has been blessed by the fire god himself, its flames dancing with colors that don't exist in the mortal realm. The fire doesn't just burn - it sings, its crackling and popping forming a melody that speaks of ancient magic and forgotten powers. The stones that surround it are carved with runes of protection and warmth, and the heat that radiates from it seems to reach into your very soul, filling you with courage and determination. This isn't just a fire - it's a beacon of hope in a world of darkness, a reminder that even in the coldest of times, there is always warmth to be found." },
                "loose_floorboard": { desc: "A floorboard that seems to have a life of its own, its surface worn smooth by countless feet and countless secrets. It's slightly raised, as if it's trying to tell you something, trying to reveal the mysteries that lie hidden beneath it. The wood is ancient, older than the building itself, and when you touch it, you can feel the weight of all the secrets it has kept hidden over the years. This isn't just a loose board - it's a gateway to the past, a key to understanding the very foundation of the building and the people who have lived within its walls." },
                "sewer_grate": { desc: "A grate of iron so old and corroded that it seems to have been forged in the fires of hell itself. The metal is cold to the touch, and when you look through it, you can see the darkness of the city's underbelly stretching out before you like a vast, living thing. The grate is heavy, but it's not just the weight of metal that makes it difficult to move - it's the weight of all the secrets that lie hidden in the sewers below, all the mysteries that have been buried in the darkness. This isn't just a grate - it's a portal to another world, a world of shadows and secrets that most people never see." },
                "crates": { desc: "Piles of crates that seem to have been abandoned by time itself, their wood weathered and worn by years of neglect. Each crate tells a story of its own - some are marked with the symbols of long-dead merchants, others bear the scars of battles fought and lost. The wood is old and splintered, but it's not just age that has worn it down - it's the weight of all the secrets that have been hidden within these crates over the years. This isn't just a pile of wood - it's a monument to the past, a reminder of all the people who have come and gone, all the stories that have been told and forgotten." },
                "bar_counter": { desc: "A counter of oak so ancient that it seems to have grown from the very earth itself, its surface scarred by years of flagons being slammed down in celebration and despair. The wood is worn smooth by countless hands, and each scar tells a story of a patron who found solace in the bottom of a mug. The counter hums with the energy of all the conversations that have taken place across its surface, all the secrets that have been shared, all the dreams that have been born and died. This isn't just a counter - it's the heart of the tavern, the soul of the community, the place where strangers become friends and friends become family." },
                "display_case": { desc: "A case of glass so clear and pure that it seems to have been crafted by the gods themselves, its surface reflecting the light in ways that make the objects within seem to glow with their own inner radiance. The trinkets and oddities displayed within are not mere curiosities - they're artifacts of power, relics of a time when magic flowed freely through the world. Each item pulses with its own unique energy, and when you look at them, you can feel the weight of their history pressing against your mind. This isn't just a display case - it's a window into the past, a glimpse of the wonders that once were and the mysteries that still remain." },
                "barrels": { desc: "Barrels of oak that have been aged in the cellars of the tavern for decades, their wood soaked through with the essence of the ale that once filled them. The barrels are old and splintered, but they're not just containers - they're vessels of memory, each one holding the echoes of the celebrations and sorrows that have taken place around them. The smell of stale ale and brine that emanates from them is not just an odor - it's the scent of history itself, the aroma of all the lives that have been touched by the tavern and its patrons. This isn't just a pile of wood - it's a monument to the past, a reminder of all the joy and sorrow that has been shared within these walls." },
                "merchant_stalls": { desc: "Stalls of wood and canvas that seem to have been erected by the very hands of commerce itself, their surfaces displaying wares that shimmer with the promise of adventure and the allure of the unknown. The healing potions glow with a warm, golden light that seems to pulse with the very essence of life itself. The iron crowbars are not just tools - they're weapons of justice, forged by the hands of those who would stand up to oppression. The magic torches burn with flames that never die, their light cutting through the darkness like a blade through silk. This isn't just a marketplace - it's a crossroads of destiny, a place where the paths of heroes and villains intersect, where the future is bought and sold." },
                "pier": { desc: "A pier of wood so old and weathered that it seems to have been built by the very hands of time itself, its planks creaking and groaning with the weight of centuries of use. The wood is blackened by years of exposure to the elements, and the nails that hold it together are rusted and corroded. But this isn't just a pier - it's a gateway to the unknown, a bridge between the known world and the mysteries that lie beyond the horizon. The water that laps at its supports is dark and mysterious, and when you look into it, you can see the reflections of things that don't exist in the mortal realm. This pier has seen countless ships come and go, countless adventures begin and end, countless dreams born and destroyed." },
                "ships": { desc: "Ships of wood and canvas that seem to have been crafted by the very hands of the sea itself, their hulls blackened by years of sailing through the darkest waters. The sails are furled and tied, but they still seem to catch the wind of adventure, still seem to yearn for the open sea and the unknown horizons that lie beyond. These ships are not just vessels - they're symbols of freedom, of escape, of the possibility of a new beginning. They've sailed through storms and calm seas, through war and peace, through the darkest nights and the brightest days. Each ship has a story to tell, a tale of adventure and mystery that could fill a thousand books." },
                "lectern": { desc: "A lectern of stone so ancient that it seems to have been carved from the very bones of the earth itself, its surface covered in arcane symbols that pulse with the power of forgotten magic. The symbols don't just glow - they dance and writhe like living things, spelling out secrets that were never meant for mortal eyes. The stone is warm to the touch, and when you place your hands upon it, you can feel the weight of all the knowledge that has been shared from this lectern over the centuries. This isn't just a piece of furniture - it's a conduit of power, a gateway to the mysteries of the universe, a place where the past and present meet in a dance of eternal knowledge." },
                "pipes": { desc: "Pipes of metal so old and corroded that they seem to have been forged in the fires of creation itself, their surfaces dripping with slime and mystery. The pipes run along the tunnel walls like the veins of some vast, living creature, carrying not just water and waste, but the very essence of the city itself. The slime that drips from them is not just filth - it's the accumulated wisdom of centuries, the condensed knowledge of all the people who have lived and died in the city above. These pipes are not just infrastructure - they're the lifeblood of the city, the arteries that keep it alive, the channels through which the very soul of the place flows." },
            },
            npcStats: { 
                "Thorgath": {willpower: 12, insight: 10, strength: 14, personality: "gruff_but_honest", profession: "innkeeper", background: "retired_adventurer"},
                "Barnaby": {willpower: 14, insight: 12, strength: 8, personality: "shrewd_merchant", profession: "curio_dealer", background: "former_scholar"},
                "Whispers": {willpower: 8, insight: 15, strength: 12, personality: "mysterious_rogue", profession: "information_broker", background: "street_smart"},
                "Licey Lacey": {willpower: 6, insight: 8, strength: 8, personality: "desperate_survivor", profession: "beggar", background: "fallen_noble"},
                "Guardsman Mulner": {willpower: 16, insight: 11, strength: 15, personality: "dutiful_guard", profession: "city_guard", background: "military_veteran"},
                "Seer": {willpower: 20, insight: 20, strength: 0, personality: "mystical_wise_one", profession: "oracle", background: "divine_touched"},
                "Elara": {willpower: 15, insight: 18, strength: 10, personality: "wise_healer", profession: "apothecary", background: "druid_herbalist"},
                "Gareth_the_Bard": {willpower: 13, insight: 16, strength: 9, personality: "charismatic_storyteller", profession: "bard", background: "wandering_minstrel"},
                "Brother_Marcus": {willpower: 17, insight: 14, strength: 12, personality: "devout_priest", profession: "temple_priest", background: "divine_caller"},
                "Captain_Blackwater": {willpower: 18, insight: 13, strength: 16, personality: "ruthless_pirate", profession: "ship_captain", background: "sea_raider"}
            },
            npcSchedules: {
                "Thorgath": { "18,24": "inn", "0,4": "inn" },
                "Barnaby": { "9,17": "curiosities" },
                "Guardsman Mulner": { "0,24": "warehouse" },
                "Licey Lacey": { "0,24": "plaza" },
                "Whispers": { "20,24": "docks", "0,5": "docks" },
                "Elara": { "0,24": "apothecary" },
                "Gareth_the_Bard": { "19,24": "inn", "0,2": "inn" },
                "Brother_Marcus": { "6,12": "temple", "18,20": "temple" },
                "Captain_Blackwater": { "22,24": "docks", "0,3": "docks" },
            },
            
            getNpcDesc: (npc) => ({
                "Thorgath": "Thorgath Ironbeard stands behind the bar like a mountain of muscle and beard, his massive frame casting shadows across the worn oak counter. His eyes, deep-set beneath bushy eyebrows, hold the wisdom of a thousand battles and the warmth of a thousand friendships. The scar that runs from his temple to his jaw tells the story of a life lived on the edge of danger, while the gentle way he polishes a mug speaks of a heart that has found peace in service. His voice rumbles like distant thunder, but there's a kindness in it that makes even the most hardened traveler feel at home. 'Welcome to the Prancing Pony, traveler. What'll it be? The ale's cold, the stories are hot, and the company's always good.'",
                "Barnaby": "Barnaby the Curio Dealer materializes from the shadows behind his display case like a ghost in a merchant's dream, his eyes gleaming with the avarice of a thousand successful deals. He's a master of the subtle art of commerce, his fingers dancing across the trinkets and oddities with the precision of a surgeon and the greed of a dragon. His shop is a treasure trove of the strange and wonderful, each item pulsing with its own unique energy and its own unique price. 'Ah, a customer with discerning tastes! I have just the thing for someone of your... particular interests. But quality comes at a price, my friend, and I'm afraid I can't let these treasures go for mere copper.'",
                "Whispers": "Whispers the Rogue slithers from the shadows like a serpent in the grass, his movements fluid and silent as a cat's. His eyes dart constantly, taking in every detail of his surroundings, every potential threat, every possible opportunity. He's a master of the art of information, a dealer in secrets and lies, a man who knows the value of knowledge and the price of silence. His voice is soft as silk and sharp as a blade, and when he speaks, you can hear the weight of a thousand secrets pressing against your mind. 'You're looking for information, aren't you? I have what you need, but information is a precious commodity in these dark times. What are you willing to pay for the truth?'",
                "Licey Lacey": "Licey Lacey sits slumped against the wall like a discarded rag doll, her once-fine clothes now tattered and stained by years of living on the streets. Her eyes, though bloodshot and weary, still hold a spark of the intelligence that once made her a force to be reckoned with in the royal court. She's a fallen noble, a woman who has seen the heights of power and the depths of despair, and her knowledge of the city's secrets is matched only by her desperation to survive. 'Spare a coin for a poor soul, kind traveler? I've seen things... terrible things... things that would make your blood run cold. The Whispering Stone... it's not what they say it is. It's something far more dangerous.'",
                "Guardsman Mulner": "Guardsman Mulner stands like a sentinel of justice, his armor gleaming in the torchlight and his hand resting on the hilt of his sword. He's a man of duty and honor, a soldier who has sworn to protect the innocent and punish the guilty. His eyes scan the area with the practiced efficiency of a veteran warrior, and his stance speaks of years of training and discipline. But beneath the stern exterior, there's a hint of weariness, a sense that the weight of maintaining order in a world of chaos is beginning to take its toll. 'This is a restricted area, citizen. What business do you have here? The warehouse district is off-limits to unauthorized personnel.'",
                "Seer": "The Seer materializes from the shadows like a vision from another world, her form shifting between solid and ethereal as if she exists in multiple dimensions simultaneously. Her eyes glow with the light of divine knowledge, and when she speaks, her voice carries the weight of a thousand prophecies and the wisdom of the ages. She's a conduit between the mortal realm and the divine, a bridge between the known and the unknown, and her words are not just speech but the very voice of destiny itself. 'The answer you seek is not in the question you ask, but in the path you have walked to reach this moment. The Whispering Stone holds the key to all mysteries, but it also holds the power to destroy everything you hold dear.'",
                "Elara": "Elara the Apothecary emerges from her workshop like a goddess of healing, her hands stained with the essence of a thousand herbs and her eyes bright with the light of divine compassion. She's a master of the ancient arts of healing, a woman who has dedicated her life to easing the suffering of others and understanding the mysteries of life and death. Her shop is a sanctuary of peace and healing, filled with the scent of herbs and the sound of gentle prayers. 'Welcome, traveler. I sense you carry wounds that go deeper than the flesh. The Whispering Stone... it's not just a magical artifact. It's a piece of the very soul of the world, and it's calling to you for a reason.'",
                "Gareth_the_Bard": "Gareth the Bard strums his lute with the skill of a master musician, his fingers dancing across the strings like a lover's caress. His voice is rich and warm, carrying the power to make hearts soar and spirits dance. He's a storyteller, a keeper of legends, a man who knows the power of words and the magic of music. His songs tell the stories of heroes and villains, of love and loss, of the eternal struggle between light and darkness. 'Ah, a fellow seeker of truth! The Whispering Stone... I've heard tales of it in every tavern from here to the far reaches of the kingdom. But the stories don't tell the whole truth. There's something more to it, something that the bards don't sing about.'",
                "Brother_Marcus": "Brother Marcus emerges from the temple like a beacon of divine light, his robes flowing around him like the very essence of holiness itself. He's a man of deep faith and profound wisdom, a priest who has dedicated his life to serving the gods and understanding the mysteries of the divine. His eyes hold the peace of one who has found his calling, and his voice carries the authority of one who speaks with the power of the heavens behind him. 'The Whispering Stone... it's not just a magical artifact, my child. It's a piece of the divine plan, a tool that the gods have placed in your path for a reason. But beware - with great power comes great responsibility, and the stone will test your soul as well as your strength.'",
                "Captain_Blackwater": "Captain Blackwater emerges from the shadows like a nightmare made flesh, his eyes gleaming with the cold light of a predator and his hand resting on the hilt of his cutlass. He's a man of violence and greed, a pirate who has made his fortune on the blood and tears of others. His ship is a floating fortress of death and destruction, and his crew are the most ruthless cutthroats in all the seven seas. But beneath the surface of the hardened criminal, there's a hint of something else - a man who has seen too much death and too little mercy. 'The Whispering Stone... I've heard tales of it from every port from here to the edge of the world. But the stories don't tell the whole truth. There's something about that stone that makes even the bravest men tremble with fear.'"
            }[npc] || "")
                }),
                "Barnaby": {
                    name: "Barnaby Curiosities",
                    race: "human",
                    mood: "mysterious",
                    relationship: 0,
                    dialogue: {
                        greeting: [
                            "Ah, a customer! Looking for something... unusual, are we?",
                            "Welcome to my humble shop. I deal in the rare and the strange.",
                            "What brings you to my little corner of curiosities?"
                        ],
                        default: [
                            "My goods are not for the faint of heart. What do you seek?",
                            "I've traveled far to acquire these items. Each has a story.",
                            "The unusual is my specialty. What catches your eye?"
                        ],
                        case: [
                            "The Whispering Stone? I've heard whispers of such things. Dangerous artifacts.",
                            "That cursed object? I want nothing to do with it!",
                            "The stone... I've heard it corrupts those who touch it."
                        ],
                        background: [
                            "I've been collecting curiosities for thirty years. Each item has a tale.",
                            "My shop has been here since the old days. I've seen many things come and go.",
                            "I deal in the unusual, the magical, the forbidden."
                        ],
                        race_hint: [
                            "Your kind has always had an eye for the mystical.",
                            "I've dealt with your people before. They appreciate true value.",
                            "Your folk understand the power that lies in ancient objects."
                        ],
                        topics: {
                            'magic': [
                                "I've items here that would make a wizard weep with joy.",
                                "The old magic still flows through some of these artifacts.",
                                "Magic is not dead, merely sleeping in forgotten places."
                            ],
                            'secrets': [
                                "I've heard whispers of a secret society meeting in the old warehouse.",
                                "The herbalist's been buying unusual ingredients lately.",
                                "Someone's been asking about the old wizard's tower."
                            ],
                            'history': [
                                "These items have seen empires rise and fall.",
                                "The old ways are not forgotten, though many would have them so.",
                                "History repeats itself, but the artifacts remember."
                            ]
                        }
                    }
                },
                "Nwar-Gom'shu": {
                    name: "Nwar-Gom'shu",
                    race: "orc",
                    mood: "hostile",
                    relationship: -1,
                    dialogue: {
                        greeting: [
                            "*Grunts* What do you want, city-dweller?",
                            "*Glares* You don't belong here, do you?",
                            "*Snarls* Another one of you fancy folk come to gawk?"
                        ],
                        default: [
                            "*Growls* I don't have time for your questions.",
                            "*Mutters* Always asking questions, never listening.",
                            "*Grunts* What is it now?"
                        ],
                        case: [
                            "*Snorts* The Whispering Stone? That's wizard business. Stay out of it.",
                            "*Growls* That cursed thing? You're asking for trouble.",
                            "*Mutters* Magic and stones... city folk don't understand such things."
                        ],
                        background: [
                            "*Grunts* I've seen this city change. Not for the better.",
                            "*Mutters* Used to be simpler times. Before all this... complexity.",
                            "*Growls* I remember when orcs could walk these streets without stares."
                        ],
                        race_hint: [
                            "*Narrows eyes* You... you're not like the others here.",
                            "*Sniffs* There's something different about you. Can't place it.",
                            "*Studies you* You carry yourself differently than most city folk."
                        ],
                        topics: {
                            'local_news': [
                                "*Grunts* Strange things happening. Lights in the sky, people disappearing.",
                                "*Mutters* The guards are nervous. Something's coming.",
                                "*Growls* Too many questions, not enough answers."
                            ],
                            'rumors': [
                                "*Snorts* Rumors? I don't deal in rumors. Only what I see.",
                                "*Grunts* People talk too much. Better to listen.",
                                "*Mutters* The old ways are forgotten. That's the real problem."
                            ],
                            'gossip': [
                                "*Growls* Gossip is for the weak. I deal in facts.",
                                "*Snorts* You want gossip? Talk to the merchants. They love to chatter.",
                                "*Mutters* Too much talking, not enough doing in this city."
                            ]
                        }
                    }
                },
                "Whispers": {
                    name: "Whispers",
                    race: "unknown",
                    mood: "cryptic",
                    relationship: 0,
                    dialogue: {
                        greeting: [
                            "Information is a valuable commodity. Got the coin?",
                            "Ah, another seeker of secrets. What do you wish to know?",
                            "The shadows hold many truths. Which one interests you?"
                        ],
                        default: [
                            "Every secret has a price. What's yours?",
                            "The truth is rarely what you expect. Still interested?",
                            "Knowledge is power, but power comes with a cost."
                        ],
                        case: [
                            "The Whispering Stone... it calls to those who would listen. But should they?",
                            "That which was stolen seeks to return to its rightful place.",
                            "The stone's power grows stronger with each passing day."
                        ],
                        background: [
                            "I've been in the shadows longer than most have lived.",
                            "The underground has its own rules. I know them all.",
                            "Secrets are my trade. Information is my currency."
                        ],
                        race_hint: [
                            "Your kind has always been drawn to the hidden truths.",
                            "I've dealt with your people before. They understand the value of secrets.",
                            "Your folk know that knowledge is the greatest weapon."
                        ],
                        topics: {
                            'underground': [
                                "The catacombs hold more secrets than the royal archives.",
                                "There's a network of tunnels beneath this city. Few know of them.",
                                "The underground has its own society. I'm part of it."
                            ],
                            'secrets': [
                                "I've heard whispers of a secret society meeting in the old warehouse.",
                                "The herbalist's been buying unusual ingredients lately.",
                                "Someone's been asking about the old wizard's tower."
                            ],
                            'danger': [
                                "Some secrets are better left buried.",
                                "The truth can be more dangerous than any weapon.",
                                "Knowledge is power, but ignorance is bliss."
                            ]
                        }
                    }
                },
                "Licey Lacey": {
                    name: "Licey Lacey",
                    race: "human",
                    mood: "desperate",
                    relationship: 0,
                    dialogue: {
                        greeting: [
                            "Spare a coin? I've seen things... glowing things... down by the Guild warehouses.",
                            "Please, kind traveler, I've been on the streets too long.",
                            "You look like someone who might help a poor soul."
                        ],
                        default: [
                            "I've seen things that would make your hair stand on end.",
                            "The streets hold many secrets, if you know where to look.",
                            "I've been watching this city for years. I know its dark corners."
                        ],
                        case: [
                            "The Whispering Stone? I've heard whispers about it. They say it glows with an otherworldly light.",
                            "That stone... I've seen people acting strange around it. It changes them.",
                            "The Whispering Stone is dangerous. I've seen what it does to people."
                        ],
                        background: [
                            "I used to work at the Guild warehouses before... before things went wrong.",
                            "I've been on these streets longer than most. I know things.",
                            "The city has changed. Not for the better, I fear."
                        ],
                        topics: {
                            'warehouses': [
                                "The Guild warehouses... strange things happen there at night.",
                                "I used to work there, but I left after seeing things I can't explain.",
                                "The warehouses hold secrets. Dark secrets."
                            ],
                            'rumors': [
                                "I've heard whispers of people disappearing near the old wizard's tower.",
                                "The guards are nervous about something. I can tell.",
                                "There's been talk of glowing lights in the forest. Not natural, I tell you."
                            ]
                        }
                    }
                },
                "Elara": {
                    name: "Elara",
                    race: "human",
                    mood: "kind",
                    relationship: 0,
                    dialogue: {
                        greeting: [
                            "Welcome to my apothecary. In need of healing?",
                            "Ah, a traveler. How may I assist you today?",
                            "Greetings, stranger. I sense you seek something."
                        ],
                        default: [
                            "What brings you to my shop today?",
                            "I have many potions and remedies. What do you need?",
                            "The art of healing is my life's work. How can I help?"
                        ],
                        case: [
                            "The Whispering Stone? I've heard whispers of such artifacts. They're dangerous things.",
                            "That stone... I've seen its effects on those who seek it. Beware its power.",
                            "The Whispering Stone corrupts all who touch it. You'd do well to avoid it."
                        ],
                        background: [
                            "I've been healing people in this city for many years.",
                            "My apothecary has served the community through good times and bad.",
                            "The art of herbalism has been passed down through my family for generations."
                        ],
                        topics: {
                            'healing': [
                                "I can prepare healing potions for you, if you have the coin.",
                                "My remedies can cure most ailments, but some wounds run deeper.",
                                "Healing is both art and science. I've learned much over the years."
                            ],
                            'rumors': [
                                "I hear whispers of strange happenings in the old wizard's tower.",
                                "There's been talk of glowing lights in the forest at night.",
                                "The guards have been more nervous lately. Something's brewing."
                            ]
                        }
                    }
                }
            }
        };

        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const command = input.value.trim();
                if (command) {
                    game.processCommand(command);
                    input.value = '';
                }
            }
        });
        
        // Menu button event listeners
        document.getElementById('new-game-btn').addEventListener('click', () => {
            if (confirm("Are you sure? Any unsaved progress will be lost.")) {
                document.getElementById('menu-overlay').classList.add('hidden');
                game.init();
            }
        });
        
        document.getElementById('load-game-btn').addEventListener('click', () => {
            document.getElementById('menu-overlay').classList.add('hidden');
            game.loadGame();
        });
        
        newGameBtn.addEventListener('click', () => {
             if (confirm("Are you sure? Any unsaved progress will be lost.")) game.init();
        });
        saveGameBtn.addEventListener('click', () => game.saveGame());
        loadGameBtn.addEventListener('click', () => game.loadGame());

        // Don't auto-start - wait for user to click NEW GAME or LOAD GAME
        // game.init();
        
        // Performance optimization: Preload critical assets
        const preloadImages = () => {
            const images = ['./padfoot_background.png', './padfoot_menu.png'];
            images.forEach(src => {
                const img = new Image();
                img.onload = () => console.log(` Preloaded: ${src}`);
                img.onerror = () => console.warn(` Failed to preload: ${src}`);
                img.src = src;
            });
        };
        preloadImages();
        
        // Enhanced error handling
        window.addEventListener('error', (e) => {
            console.error(' Game Error:', e.error);
            if (e.error && e.error.message.includes('Unexpected token')) {
                console.error(' Syntax error detected - check console for details');
            }
        });
        
        // Unhandled promise rejection handling
        window.addEventListener('unhandledrejection', (e) => {
            console.error(' Unhandled Promise Rejection:', e.reason);
        });
        
        // Advanced keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        game.saveGame();
                        break;
                    case 'l':
                        e.preventDefault();
                        game.loadGame();
                        break;
                    case 'n':
                        e.preventDefault();
                        if (confirm("Start a new game?")) game.init();
                        break;
                }
            }
        });
        
        // Auto-save functionality
        let autoSaveInterval;
        const startAutoSave = () => {
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            autoSaveInterval = setInterval(() => {
                if (game.state && !game.state.gameOver) {
                    game.saveGame('Auto Save');
                    console.log(' Auto-saved game');
                }
            }, 300000); // Auto-save every 5 minutes
        };
        
        // Advanced game analytics and telemetry
        const gameAnalytics = {
            startTime: Date.now(),
            actions: [],
            errors: [],
            performance: {
                loadTime: 0,
                renderTime: 0,
                memoryUsage: 0
            },
            
            trackAction: function(action, data = {}) {
                this.actions.push({
                    timestamp: Date.now(),
                    action: action,
                    data: data,
                    gameTime: Date.now() - this.startTime
                });
                console.log(` Action tracked: ${action}`, data);
            },
            
            trackError: function(error, context = '') {
                this.errors.push({
                    timestamp: Date.now(),
                    error: error.message || error,
                    context: context,
                    stack: error.stack || ''
                });
                console.error(` Error tracked: ${error.message || error}`, context);
            },
            
            getStats: function() {
                return {
                    totalPlayTime: Date.now() - this.startTime,
                    actionCount: this.actions.length,
                    errorCount: this.errors.length,
                    performance: this.performance
                };
            }
        };
        
        // Track game initialization
        gameAnalytics.trackAction('game_loaded', { gameType: 'padfoot' });
        
        // Advanced cheat codes and debug commands
        const cheatCodes = {
            'godmode': () => {
                game.state.health = 999;
                game.state.stress = 0;
                game.state.hunger = 0;
                game.output(' God mode activated!');
                gameAnalytics.trackAction('cheat_used', { code: 'godmode' });
            },
            'money': () => {
                game.state.cash = 99999;
                game.output(' Money cheat activated!');
                gameAnalytics.trackAction('cheat_used', { code: 'money' });
            },
            'teleport': (location) => {
                if (location && game.data.worldMap[location]) {
                    game.state.position = location;
                    game.output(` Teleported to ${location}!`);
                    gameAnalytics.trackAction('cheat_used', { code: 'teleport', location: location });
                } else {
                    game.output(' Invalid location for teleport!');
                }
            },
            'stats': () => {
                const stats = gameAnalytics.getStats();
                game.output(` Game Stats: Play Time: ${Math.round(stats.totalPlayTime/1000)}s, Actions: ${stats.actionCount}, Errors: ${stats.errorCount}`);
            }
        };
        
        // Advanced achievement system
        const achievements = {
            'first_command': { name: 'First Steps', description: 'Execute your first command', unlocked: false },
            'explorer': { name: 'Explorer', description: 'Visit 10 different locations', unlocked: false, progress: 0 },
            'social_butterfly': { name: 'Social Butterfly', description: 'Talk to 5 different NPCs', unlocked: false, progress: 0 },
            'wizard': { name: 'Wizard', description: 'Cast 5 different spells', unlocked: false, progress: 0 },
            'survivor': { name: 'Survivor', description: 'Play for 30 minutes', unlocked: false, progress: 0 }
        };
        
        const checkAchievements = () => {
            // Check first command
            if (!achievements.first_command.unlocked && gameAnalytics.actions.length >= 1) {
                achievements.first_command.unlocked = true;
                game.output(' Achievement Unlocked: First Steps!');
            }
            
            // Check explorer achievement
            const uniqueLocations = new Set(gameAnalytics.actions
                .filter(a => a.action === 'command_executed' && a.data.command.startsWith('go '))
                .map(a => a.data.command.split(' ')[1]));
            achievements.explorer.progress = uniqueLocations.size;
            if (!achievements.explorer.unlocked && achievements.explorer.progress >= 10) {
                achievements.explorer.unlocked = true;
                game.output(' Achievement Unlocked: Explorer!');
            }
            
            // Check social butterfly
            const talkedNPCs = new Set(gameAnalytics.actions
                .filter(a => a.action === 'command_executed' && a.data.command.startsWith('talk to '))
                .map(a => a.data.command.split(' ').slice(2).join(' ')));
            achievements.social_butterfly.progress = talkedNPCs.size;
            if (!achievements.social_butterfly.unlocked && achievements.social_butterfly.progress >= 5) {
                achievements.social_butterfly.unlocked = true;
                game.output(' Achievement Unlocked: Social Butterfly!');
            }
            
            // Check survivor
            const playTime = gameAnalytics.getStats().totalPlayTime;
            achievements.survivor.progress = Math.floor(playTime / 60000); // minutes
            if (!achievements.survivor.unlocked && achievements.survivor.progress >= 30) {
                achievements.survivor.unlocked = true;
                game.output(' Achievement Unlocked: Survivor!');
            }
        };
        
        // Check achievements every 10 actions
        let actionCount = 0;
        const originalTrackAction = gameAnalytics.trackAction;
        gameAnalytics.trackAction = function(action, data) {
            originalTrackAction.call(this, action, data);
            actionCount++;
            if (actionCount % 10 === 0) {
                checkAchievements();
            }
        };
        
        // Advanced AI-driven NPC behavior system
        const npcAI = {
            personalities: new Map(),
            relationships: new Map(),
            memory: new Map(),
            
            initializePersonality: function(npcName) {
                const personalities = ['friendly', 'hostile', 'neutral', 'mysterious', 'helpful', 'deceptive'];
                const personality = personalities[Math.floor(Math.random() * personalities.length)];
                this.personalities.set(npcName, personality);
                game.output(` ${npcName} personality: ${personality}`);
            },
            
            updateRelationship: function(npcName, change) {
                const current = this.relationships.get(npcName) || 0;
                const newValue = Math.max(-100, Math.min(100, current + change));
                this.relationships.set(npcName, newValue);
                game.output(` Relationship with ${npcName}: ${newValue > 0 ? '+' : ''}${newValue}`);
            },
            
            rememberInteraction: function(npcName, interaction) {
                if (!this.memory.has(npcName)) {
                    this.memory.set(npcName, []);
                }
                this.memory.get(npcName).push({
                    timestamp: Date.now(),
                    interaction: interaction
                });
            },
            
            getResponse: function(npcName, playerAction) {
                const personality = this.personalities.get(npcName) || 'neutral';
                const relationship = this.relationships.get(npcName) || 0;
                const memories = this.memory.get(npcName) || [];
                
                // AI-driven response based on personality, relationship, and memory
                let response = '';
                
                if (personality === 'friendly') {
                    response = relationship > 50 ? 
                        "I'm so glad to see you again! How can I help?" :
                        "Hello there! Nice to meet you!";
                } else if (personality === 'hostile') {
                    response = relationship < -50 ?
                        "You again! Get away from me!" :
                        "What do you want? I don't have time for this.";
                } else if (personality === 'mysterious') {
                    response = "The shadows whisper your name... what secrets do you seek?";
                } else if (personality === 'helpful') {
                    response = "I might be able to help you with that. What do you need?";
                } else if (personality === 'deceptive') {
                    response = "Oh, I'm sure I can help you... for a price.";
                } else {
                    response = "I'm not sure what you want from me.";
                }
                
                // Remember this interaction
                this.rememberInteraction(npcName, playerAction);
                
                return response;
            }
        };
        
        // Advanced weather and time system
        const weatherSystem = {
            currentWeather: 'clear',
            timeOfDay: 'day',
            temperature: 72,
            
            updateWeather: function() {
                const weathers = ['clear', 'rainy', 'foggy', 'stormy', 'overcast'];
                this.currentWeather = weathers[Math.floor(Math.random() * weathers.length)];
                
                // Update temperature based on weather
                if (this.currentWeather === 'rainy') this.temperature = 65;
                else if (this.currentWeather === 'stormy') this.temperature = 60;
                else if (this.currentWeather === 'foggy') this.temperature = 55;
                else this.temperature = 72;
                
                game.output(` Weather changed to: ${this.currentWeather} (${this.temperature}F)`);
            },
            
            updateTime: function() {
                const times = ['dawn', 'day', 'dusk', 'night'];
                const currentIndex = times.indexOf(this.timeOfDay);
                this.timeOfDay = times[(currentIndex + 1) % times.length];
                
                game.output(` Time changed to: ${this.timeOfDay}`);
            },
            
            getWeatherEffect: function() {
                if (this.currentWeather === 'rainy') {
                    return "The rain makes everything look more mysterious and dangerous.";
                } else if (this.currentWeather === 'foggy') {
                    return "The fog obscures your vision, making it hard to see details.";
                } else if (this.currentWeather === 'stormy') {
                    return "The storm rages overhead, creating an ominous atmosphere.";
                } else if (this.currentWeather === 'overcast') {
                    return "The overcast sky casts everything in a dull, gray light.";
                } else {
                    return "The clear sky provides good visibility.";
                }
            }
        };
        
        // Advanced inventory management system
        const inventorySystem = {
            maxWeight: 100,
            currentWeight: 0,
            items: new Map(),
            
            addItem: function(item, weight = 1) {
                if (this.currentWeight + weight > this.maxWeight) {
                    game.output(` Too heavy! Cannot carry ${item}.`);
                    return false;
                }
                
                this.items.set(item, (this.items.get(item) || 0) + 1);
                this.currentWeight += weight;
                game.output(` Added ${item} to inventory. Weight: ${this.currentWeight}/${this.maxWeight}`);
                return true;
            },
            
            removeItem: function(item, weight = 1) {
                if (!this.items.has(item) || this.items.get(item) <= 0) {
                    game.output(` You don't have ${item}.`);
                    return false;
                }
                
                this.items.set(item, this.items.get(item) - 1);
                this.currentWeight -= weight;
                if (this.items.get(item) <= 0) {
                    this.items.delete(item);
                }
                game.output(` Removed ${item} from inventory. Weight: ${this.currentWeight}/${this.maxWeight}`);
                return true;
            },
            
            getInventory: function() {
                if (this.items.size === 0) {
                    return "Your inventory is empty.";
                }
                
                let inventory = " INVENTORY:\n";
                for (const [item, count] of this.items) {
                    inventory += `  ${item} (${count})\n`;
                }
                inventory += `\nWeight: ${this.currentWeight}/${this.maxWeight}`;
                return inventory;
            }
        };
        
        // Add weather and time commands
        const originalProcessCommandWeather = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'weather') {
                game.output(` Current weather: ${weatherSystem.currentWeather} (${weatherSystem.temperature}F)`);
                game.output(weatherSystem.getWeatherEffect());
                return;
            } else if (lowerCommand === 'time') {
                game.output(` Current time: ${weatherSystem.timeOfDay}`);
                return;
            } else if (lowerCommand === 'change weather') {
                weatherSystem.updateWeather();
                return;
            } else if (lowerCommand === 'change time') {
                weatherSystem.updateTime();
                return;
            } else if (lowerCommand === 'inventory') {
                game.output(inventorySystem.getInventory());
                return;
            }
            
            return originalProcessCommandWeather.call(this, command);
        };
        
        // Advanced combat system with tactical elements
        const combatSystem = {
            isInCombat: false,
            currentEnemy: null,
            combatTurn: 0,
            combatActions: ['attack', 'defend', 'flee', 'use_item'],
            
            startCombat: function(enemy) {
                this.isInCombat = true;
                this.currentEnemy = enemy;
                this.combatTurn = 0;
                game.output(` COMBAT STARTED!`);
                game.output(`You are fighting: ${enemy.name}`);
                game.output(`Health: ${enemy.health}/${enemy.maxHealth}`);
                game.output(`Available actions: ${this.combatActions.join(', ')}`);
            },
            
            processCombatTurn: function(playerAction) {
                if (!this.isInCombat) return;
                
                this.combatTurn++;
                game.output(`\n--- TURN ${this.combatTurn} ---`);
                
                // Player action
                if (playerAction === 'attack') {
                    const damage = Math.floor(Math.random() * 20) + 10;
                    this.currentEnemy.health -= damage;
                    game.output(`You attack for ${damage} damage!`);
                } else if (playerAction === 'defend') {
                    game.output(`You take a defensive stance.`);
                } else if (playerAction === 'flee') {
                    if (Math.random() < 0.7) {
                        game.output(`You successfully flee from combat!`);
                        this.endCombat();
                        return;
                    } else {
                        game.output(`You fail to flee!`);
                    }
                }
                
                // Check if enemy is defeated
                if (this.currentEnemy.health <= 0) {
                    game.output(` You defeated ${this.currentEnemy.name}!`);
                    this.endCombat();
                    return;
                }
                
                // Enemy action
                const enemyAction = this.combatActions[Math.floor(Math.random() * this.combatActions.length)];
                if (enemyAction === 'attack') {
                    const damage = Math.floor(Math.random() * 15) + 5;
                    game.state.health -= damage;
                    game.output(`${this.currentEnemy.name} attacks for ${damage} damage!`);
                } else if (enemyAction === 'defend') {
                    game.output(`${this.currentEnemy.name} takes a defensive stance.`);
                }
                
                // Check if player is defeated
                if (game.state.health <= 0) {
                    game.output(` You have been defeated!`);
                    this.endCombat();
                    return;
                }
                
                game.output(`Your health: ${game.state.health}`);
                game.output(`Enemy health: ${this.currentEnemy.health}`);
            },
            
            endCombat: function() {
                this.isInCombat = false;
                this.currentEnemy = null;
                this.combatTurn = 0;
                game.output(` Combat ended.`);
            }
        };
        
        // Advanced quest system
        const questSystem = {
            activeQuests: new Map(),
            completedQuests: new Set(),
            questRewards: new Map(),
            
            addQuest: function(questId, questData) {
                this.activeQuests.set(questId, {
                    ...questData,
                    status: 'active',
                    progress: 0,
                    maxProgress: questData.maxProgress || 1
                });
                game.output(` New quest: ${questData.name}`);
                game.output(`Description: ${questData.description}`);
            },
            
            updateQuestProgress: function(questId, progress = 1) {
                if (!this.activeQuests.has(questId)) return;
                
                const quest = this.activeQuests.get(questId);
                quest.progress += progress;
                
                if (quest.progress >= quest.maxProgress) {
                    this.completeQuest(questId);
                } else {
                    game.output(` Quest progress: ${quest.progress}/${quest.maxProgress}`);
                }
            },
            
            completeQuest: function(questId) {
                const quest = this.activeQuests.get(questId);
                if (!quest) return;
                
                quest.status = 'completed';
                this.completedQuests.add(questId);
                this.activeQuests.delete(questId);
                
                game.output(` Quest completed: ${quest.name}`);
                
                // Give rewards
                if (quest.rewards) {
                    quest.rewards.forEach(reward => {
                        if (reward.type === 'experience') {
                            game.state.experience += reward.amount;
                            game.output(`+${reward.amount} experience`);
                        } else if (reward.type === 'item') {
                            inventorySystem.addItem(reward.item, reward.weight || 1);
                        } else if (reward.type === 'money') {
                            game.state.cash += reward.amount;
                            game.output(`+$${reward.amount}`);
                        }
                    });
                }
            },
            
            listQuests: function() {
                if (this.activeQuests.size === 0) {
                    game.output(` No active quests.`);
                    return;
                }
                
                game.output(` ACTIVE QUESTS:`);
                for (const [id, quest] of this.activeQuests) {
                    game.output(`  ${quest.name}: ${quest.progress}/${quest.maxProgress}`);
                }
            }
        };
        
        // Advanced crafting system
        const craftingSystem = {
            recipes: new Map(),
            materials: new Map(),
            
            addRecipe: function(itemName, materials, result) {
                this.recipes.set(itemName, { materials, result });
            },
            
            canCraft: function(itemName) {
                const recipe = this.recipes.get(itemName);
                if (!recipe) return false;
                
                for (const [material, amount] of recipe.materials) {
                    if (!inventorySystem.items.has(material) || 
                        inventorySystem.items.get(material) < amount) {
                        return false;
                    }
                }
                return true;
            },
            
            craftItem: function(itemName) {
                const recipe = this.recipes.get(itemName);
                if (!recipe) {
                    game.output(` Unknown recipe: ${itemName}`);
                    return false;
                }
                
                if (!this.canCraft(itemName)) {
                    game.output(` Not enough materials to craft ${itemName}`);
                    return false;
                }
                
                // Consume materials
                for (const [material, amount] of recipe.materials) {
                    inventorySystem.removeItem(material, 1);
                }
                
                // Add result
                inventorySystem.addItem(recipe.result, 1);
                game.output(` Crafted ${recipe.result}!`);
                return true;
            },
            
            listRecipes: function() {
                game.output(` AVAILABLE RECIPES:`);
                for (const [name, recipe] of this.recipes) {
                    const canCraft = this.canCraft(name) ? '' : '';
                    game.output(`  ${canCraft} ${name}: ${recipe.result}`);
                }
            }
        };
        
        // Add some default recipes
        craftingSystem.addRecipe('health_potion', [['herbs', 2], ['water', 1]], 'Health Potion');
        craftingSystem.addRecipe('lockpick', [['metal', 1], ['wire', 1]], 'Lockpick');
        craftingSystem.addRecipe('smoke_bomb', [['chemicals', 1], ['cloth', 1]], 'Smoke Bomb');
        
        // Add combat, quest, and crafting commands
        const originalProcessCommandAdvanced = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'combat') {
                if (combatSystem.isInCombat) {
                    game.output(` Currently in combat! Use: attack, defend, flee`);
                } else {
                    game.output(` Not in combat. Use 'attack [enemy]' to start combat.`);
                }
                return;
            } else if (lowerCommand.startsWith('attack ')) {
                const enemyName = command.substring(7);
                const enemy = { name: enemyName, health: 50, maxHealth: 50 };
                combatSystem.startCombat(enemy);
                return;
            } else if (lowerCommand === 'quests') {
                questSystem.listQuests();
                return;
            } else if (lowerCommand === 'craft') {
                craftingSystem.listRecipes();
                return;
            } else if (lowerCommand.startsWith('craft ')) {
                const itemName = command.substring(6);
                craftingSystem.craftItem(itemName);
                return;
            }
            
            return originalProcessCommandAdvanced.call(this, command);
        };
        
        // Advanced skill system
        const skillSystem = {
            skills: new Map(),
            skillPoints: 0,
            maxSkillLevel: 100,
            
            initializeSkill: function(skillName, baseValue = 0) {
                this.skills.set(skillName, {
                    level: baseValue,
                    experience: 0,
                    maxExperience: 100
                });
            },
            
            addExperience: function(skillName, amount) {
                if (!this.skills.has(skillName)) {
                    this.initializeSkill(skillName);
                }
                
                const skill = this.skills.get(skillName);
                skill.experience += amount;
                
                // Check for level up
                while (skill.experience >= skill.maxExperience && skill.level < this.maxSkillLevel) {
                    skill.experience -= skill.maxExperience;
                    skill.level++;
                    skill.maxExperience = Math.floor(skill.maxExperience * 1.2);
                    game.output(` ${skillName} leveled up to ${skill.level}!`);
                }
            },
            
            getSkillLevel: function(skillName) {
                return this.skills.has(skillName) ? this.skills.get(skillName).level : 0;
            },
            
            listSkills: function() {
                if (this.skills.size === 0) {
                    game.output(` No skills learned yet.`);
                    return;
                }
                
                game.output(` SKILLS:`);
                for (const [name, skill] of this.skills) {
                    const progress = Math.floor((skill.experience / skill.maxExperience) * 100);
                    game.output(`  ${name}: Level ${skill.level} (${progress}% to next level)`);
                }
            }
        };
        
        // Initialize some default skills
        skillSystem.initializeSkill('magic', 8);
        skillSystem.initializeSkill('combat', 5);
        skillSystem.initializeSkill('stealth', 3);
        skillSystem.initializeSkill('persuasion', 6);
        skillSystem.initializeSkill('survival', 4);
        
        // Advanced reputation system
        const reputationSystem = {
            factions: new Map(),
            globalReputation: 0,
            
            initializeFaction: function(factionName, baseRep = 0) {
                this.factions.set(factionName, {
                    reputation: baseRep,
                    status: 'neutral',
                    history: []
                });
            },
            
            updateReputation: function(factionName, change, reason = '') {
                if (!this.factions.has(factionName)) {
                    this.initializeFaction(factionName);
                }
                
                const faction = this.factions.get(factionName);
                faction.reputation += change;
                faction.history.push({
                    timestamp: Date.now(),
                    change: change,
                    reason: reason
                });
                
                // Update status based on reputation
                if (faction.reputation >= 100) {
                    faction.status = 'allied';
                } else if (faction.reputation >= 50) {
                    faction.status = 'friendly';
                } else if (faction.reputation >= -50) {
                    faction.status = 'neutral';
                } else if (faction.reputation >= -100) {
                    faction.status = 'hostile';
                } else {
                    faction.status = 'enemy';
                }
                
                game.output(` Reputation with ${factionName}: ${faction.reputation} (${faction.status})`);
            },
            
            getFactionStatus: function(factionName) {
                return this.factions.has(factionName) ? this.factions.get(factionName).status : 'unknown';
            },
            
            listReputations: function() {
                if (this.factions.size === 0) {
                    game.output(` No faction reputations yet.`);
                    return;
                }
                
                game.output(` FACTION REPUTATIONS:`);
                for (const [name, faction] of this.factions) {
                    game.output(`  ${name}: ${faction.reputation} (${faction.status})`);
                }
            }
        };
        
        // Initialize some default factions
        reputationSystem.initializeFaction('wizards', 15);
        reputationSystem.initializeFaction('thieves', -10);
        reputationSystem.initializeFaction('civilians', 8);
        reputationSystem.initializeFaction('guards', 5);
        
        // Advanced dialogue system
        const dialogueSystem = {
            conversations: new Map(),
            currentConversation: null,
            
            startConversation: function(npcName, dialogueTree) {
                this.currentConversation = {
                    npc: npcName,
                    tree: dialogueTree,
                    currentNode: 'start'
                };
                
                this.displayCurrentNode();
            },
            
            displayCurrentNode: function() {
                if (!this.currentConversation) return;
                
                const node = this.currentConversation.tree[this.currentConversation.currentNode];
                if (!node) return;
                
                game.output(`\n ${this.currentConversation.npc}: ${node.text}`);
                
                if (node.options && node.options.length > 0) {
                    game.output(`\nOptions:`);
                    node.options.forEach((option, index) => {
                        game.output(`  ${index + 1}. ${option.text}`);
                    });
                }
            },
            
            selectOption: function(optionIndex) {
                if (!this.currentConversation) return;
                
                const node = this.currentConversation.tree[this.currentConversation.currentNode];
                if (!node || !node.options || optionIndex < 0 || optionIndex >= node.options.length) {
                    game.output(` Invalid option.`);
                    return;
                }
                
                const option = node.options[optionIndex];
                this.currentConversation.currentNode = option.nextNode || 'end';
                
                if (option.effect) {
                    option.effect();
                }
                
                if (this.currentConversation.currentNode === 'end') {
                    this.endConversation();
                } else {
                    this.displayCurrentNode();
                }
            },
            
            endConversation: function() {
                this.currentConversation = null;
                game.output(`\n Conversation ended.`);
            }
        };
        
        // Add skill, reputation, and dialogue commands
        const originalProcessCommandSystems = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'skills') {
                skillSystem.listSkills();
                return;
            } else if (lowerCommand === 'reputation') {
                reputationSystem.listReputations();
                return;
            } else if (lowerCommand.startsWith('talk to ')) {
                const npcName = command.substring(8);
                // Simple dialogue tree for demonstration
                const dialogueTree = {
                    start: {
                        text: `Greetings, traveler. What brings you to these enchanted lands?`,
                        options: [
                            { text: "I seek knowledge", nextNode: 'knowledge' },
                            { text: "Just passing through", nextNode: 'end' }
                        ]
                    },
                    knowledge: {
                        text: `Knowledge is power, but it comes with a price. What do you wish to know?`,
                        options: [
                            { text: "Tell me about the ancient magic", nextNode: 'magic' },
                            { text: "Never mind", nextNode: 'end' }
                        ]
                    },
                    magic: {
                        text: `The old ways are fading, but the magic still flows through the land. Use it wisely.`,
                        options: [
                            { text: "Thank you for the wisdom", nextNode: 'end' }
                        ]
                    }
                };
                dialogueSystem.startConversation(npcName, dialogueTree);
                return;
            }
            
            return originalProcessCommandSystems.call(this, command);
        };
        
        // Advanced mini-game system
        const miniGameSystem = {
            activeGame: null,
            games: new Map(),
            
            registerGame: function(gameName, gameData) {
                this.games.set(gameName, gameData);
            },
            
            startGame: function(gameName) {
                if (!this.games.has(gameName)) {
                    game.output(` Unknown mini-game: ${gameName}`);
                    return;
                }
                
                this.activeGame = {
                    name: gameName,
                    data: this.games.get(gameName),
                    state: this.games.get(gameName).initialState || {}
                };
                
                game.output(` Starting ${gameName} mini-game!`);
                this.activeGame.data.start(this.activeGame.state);
            },
            
            endGame: function() {
                if (this.activeGame) {
                    game.output(` ${this.activeGame.name} mini-game ended.`);
                    this.activeGame = null;
                }
            },
            
            processInput: function(input) {
                if (!this.activeGame) return false;
                
                const result = this.activeGame.data.processInput(input, this.activeGame.state);
                if (result) {
                    this.activeGame.state = result.state || this.activeGame.state;
                    if (result.end) {
                        this.endGame();
                    }
                }
                return true;
            }
        };
        
        // Register some mini-games
        miniGameSystem.registerGame('spellcasting', {
            initialState: { level: 1, progress: 0, maxProgress: 100 },
            start: function(state) {
                game.output(` Spellcasting mini-game started!`);
                game.output(`Magic Level: ${state.level}/5`);
                game.output(`Progress: ${state.progress}/${state.maxProgress}%`);
                game.output(`Commands: cast [spell], quit`);
            },
            processInput: function(input, state) {
                const parts = input.toLowerCase().split(' ');
                const command = parts[0];
                
                if (command === 'quit') {
                    game.output(` Spellcasting session ended.`);
                    return { end: true };
                } else if (command === 'cast') {
                    const spell = parts[1];
                    if (!spell) {
                        game.output(` Cast what? (fireball, heal, shield)`);
                        return { state };
                    }
                    
                    const success = Math.random() < (0.4 - (state.level * 0.08));
                    if (success) {
                        const progress = Math.floor(Math.random() * 20) + 10;
                        state.progress += progress;
                        game.output(` Successfully cast ${spell}! +${progress}% progress`);
                        
                        if (state.progress >= state.maxProgress) {
                            game.output(` Spell mastery achieved!`);
                            skillSystem.addExperience('magic', 15);
                            return { end: true };
                        }
                    } else {
                        game.output(` Spell failed. Magic energy is unstable.`);
                    }
                } else {
                    game.output(` Unknown command. Use: cast [spell], quit`);
                }
                
                return { state };
            }
        });
        
        miniGameSystem.registerGame('alchemy', {
            initialState: { difficulty: 1, attempts: 0, maxAttempts: 5 },
            start: function(state) {
                game.output(` Alchemy mini-game started!`);
                game.output(`Difficulty: ${state.difficulty}/5`);
                game.output(`Attempts remaining: ${state.maxAttempts - state.attempts}`);
                game.output(`Commands: brew [potion], quit`);
            },
            processInput: function(input, state) {
                const parts = input.toLowerCase().split(' ');
                const command = parts[0];
                
                if (command === 'quit') {
                    game.output(` Alchemy session abandoned.`);
                    return { end: true };
                } else if (command === 'brew') {
                    const potion = parts[1];
                    if (!potion) {
                        game.output(` Brew what? (health_potion, mana_potion, poison)`);
                        return { state };
                    }
                    
                    state.attempts++;
                    const success = Math.random() < (0.3 - (state.difficulty * 0.05));
                    
                    if (success) {
                        game.output(` Potion brewed successfully!`);
                        skillSystem.addExperience('survival', 10);
                        return { end: true };
                    } else {
                        game.output(` Brewing failed. ${state.maxAttempts - state.attempts} attempts remaining.`);
                        
                        if (state.attempts >= state.maxAttempts) {
                            game.output(` Alchemy lab exploded!`);
                            return { end: true };
                        }
                    }
                } else {
                    game.output(` Unknown command. Use: brew [potion], quit`);
                }
                
                return { state };
            }
        });
        
        // Advanced event system
        const eventSystem = {
            events: new Map(),
            activeEvents: new Set(),
            eventHistory: [],
            
            registerEvent: function(eventName, eventData) {
                this.events.set(eventName, eventData);
            },
            
            triggerEvent: function(eventName, context = {}) {
                if (!this.events.has(eventName)) {
                    game.output(` Unknown event: ${eventName}`);
                    return;
                }
                
                const event = this.events.get(eventName);
                this.activeEvents.add(eventName);
                this.eventHistory.push({
                    name: eventName,
                    timestamp: Date.now(),
                    context: context
                });
                
                game.output(`\n EVENT: ${event.title}`);
                game.output(event.description);
                
                if (event.choices && event.choices.length > 0) {
                    game.output(`\nChoices:`);
                    event.choices.forEach((choice, index) => {
                        game.output(`  ${index + 1}. ${choice.text}`);
                    });
                }
                
                if (event.effects) {
                    event.effects.forEach(effect => {
                        if (effect.type === 'reputation') {
                            reputationSystem.updateReputation(effect.faction, effect.change, event.title);
                        } else if (effect.type === 'skill') {
                            skillSystem.addExperience(effect.skill, effect.amount);
                        } else if (effect.type === 'item') {
                            inventorySystem.addItem(effect.item, effect.weight || 1);
                        }
                    });
                }
            },
            
            listEvents: function() {
                if (this.activeEvents.size === 0) {
                    game.output(` No active events.`);
                    return;
                }
                
                game.output(` ACTIVE EVENTS:`);
                for (const eventName of this.activeEvents) {
                    const event = this.events.get(eventName);
                    game.output(`  ${event.title}`);
                }
            }
        };
        
        // Register some events
        eventSystem.registerEvent('wizard_duel', {
            title: 'Wizard Duel',
            description: 'A powerful wizard challenges you to a magical duel. You need to decide how to handle this situation.',
            choices: [
                { text: 'Accept the challenge' },
                { text: 'Decline politely' },
                { text: 'Ask for a different contest' }
            ],
            effects: [
                { type: 'reputation', faction: 'wizards', change: 10, reason: 'Wizard Duel' }
            ]
        });
        
        eventSystem.registerEvent('ancient_ruins', {
            title: 'Ancient Ruins',
            description: 'You discover ancient ruins filled with magical artifacts. You need to decide how to explore them.',
            choices: [
                { text: 'Explore carefully' },
                { text: 'Search for traps first' },
                { text: 'Leave immediately' }
            ],
            effects: [
                { type: 'reputation', faction: 'wizards', change: 15, reason: 'Ancient Ruins' }
            ]
        });
        
        // Add mini-game and event commands
        const originalProcessCommandMini = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'minigames') {
                game.output(` Available mini-games: spellcasting, alchemy`);
                return;
            } else if (lowerCommand.startsWith('play ')) {
                const gameName = command.substring(5);
                miniGameSystem.startGame(gameName);
                return;
            } else if (lowerCommand === 'events') {
                eventSystem.listEvents();
                return;
            } else if (lowerCommand.startsWith('trigger ')) {
                const eventName = command.substring(8);
                eventSystem.triggerEvent(eventName);
                return;
            }
            
            // Check if we're in a mini-game
            if (miniGameSystem.processInput(command)) {
                return;
            }
            
            return originalProcessCommandMini.call(this, command);
        };
        
        // Advanced save system with multiple slots
        const saveSystem = {
            maxSaves: 10,
            currentSave: null,
            
            saveGame: function(saveName) {
                if (!saveName) {
                    game.output(` Please provide a save name.`);
                    return;
                }
                
                const saveData = {
                    timestamp: Date.now(),
                    gameState: game.state,
                    skillSystem: skillSystem,
                    reputationSystem: reputationSystem,
                    inventorySystem: inventorySystem,
                    questSystem: questSystem,
                    combatSystem: combatSystem,
                    craftingSystem: craftingSystem,
                    weatherSystem: weatherSystem,
                    npcAI: npcAI,
                    achievements: achievements,
                    gameAnalytics: gameAnalytics
                };
                
                try {
                    localStorage.setItem(`gumshoe_padfoot_${saveName}`, JSON.stringify(saveData));
                    game.output(` Game saved as "${saveName}"`);
                } catch (error) {
                    game.output(` Failed to save game: ${error.message}`);
                }
            },
            
            loadGame: function(saveName) {
                if (!saveName) {
                    game.output(` Please provide a save name.`);
                    return;
                }
                
                try {
                    const saveData = localStorage.getItem(`gumshoe_padfoot_${saveName}`);
                    if (!saveData) {
                        game.output(` Save "${saveName}" not found.`);
                        return;
                    }
                    
                    const parsedData = JSON.parse(saveData);
                    
                    // Restore game state
                    game.state = parsedData.gameState;
                    skillSystem = parsedData.skillSystem || skillSystem;
                    reputationSystem = parsedData.reputationSystem || reputationSystem;
                    inventorySystem = parsedData.inventorySystem || inventorySystem;
                    questSystem = parsedData.questSystem || questSystem;
                    combatSystem = parsedData.combatSystem || combatSystem;
                    craftingSystem = parsedData.craftingSystem || craftingSystem;
                    weatherSystem = parsedData.weatherSystem || weatherSystem;
                    npcAI = parsedData.npcAI || npcAI;
                    achievements = parsedData.achievements || achievements;
                    gameAnalytics = parsedData.gameAnalytics || gameAnalytics;
                    
                    this.currentSave = saveName;
                    game.output(` Game loaded from "${saveName}"`);
                    game.output(`You are in: ${game.getCurrentRoom().name}`);
                } catch (error) {
                    game.output(` Failed to load game: ${error.message}`);
                }
            },
            
            listSaves: function() {
                const saves = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('gumshoe_padfoot_')) {
                        const saveName = key.replace('gumshoe_padfoot_', '');
                        const saveData = JSON.parse(localStorage.getItem(key));
                        saves.push({
                            name: saveName,
                            timestamp: saveData.timestamp,
                            date: new Date(saveData.timestamp).toLocaleString()
                        });
                    }
                }
                
                if (saves.length === 0) {
                    game.output(` No saves found.`);
                    return;
                }
                
                game.output(` SAVES:`);
                saves.sort((a, b) => b.timestamp - a.timestamp).forEach(save => {
                    game.output(`  ${save.name} - ${save.date}`);
                });
            },
            
            deleteSave: function(saveName) {
                if (!saveName) {
                    game.output(` Please provide a save name.`);
                    return;
                }
                
                try {
                    localStorage.removeItem(`gumshoe_padfoot_${saveName}`);
                    game.output(` Save "${saveName}" deleted.`);
                } catch (error) {
                    game.output(` Failed to delete save: ${error.message}`);
                }
            }
        };
        
        // Advanced settings system
        const settingsSystem = {
            settings: {
                autoSave: true,
                autoSaveInterval: 300000, // 5 minutes
                showTips: true,
                soundEnabled: true,
                musicEnabled: true,
                fontSize: 'medium',
                theme: 'padfoot'
            },
            
            loadSettings: function() {
                try {
                    const savedSettings = localStorage.getItem('gumshoe_padfoot_settings');
                    if (savedSettings) {
                        this.settings = { ...this.settings, ...JSON.parse(savedSettings) };
                    }
                } catch (error) {
                    console.error('Failed to load settings:', error);
                }
            },
            
            saveSettings: function() {
                try {
                    localStorage.setItem('gumshoe_padfoot_settings', JSON.stringify(this.settings));
                } catch (error) {
                    console.error('Failed to save settings:', error);
                }
            },
            
            updateSetting: function(key, value) {
                if (this.settings.hasOwnProperty(key)) {
                    this.settings[key] = value;
                    this.saveSettings();
                    game.output(` Setting ${key} updated to ${value}`);
                } else {
                    game.output(` Unknown setting: ${key}`);
                }
            },
            
            listSettings: function() {
                game.output(` SETTINGS:`);
                for (const [key, value] of Object.entries(this.settings)) {
                    game.output(`  ${key}: ${value}`);
                }
            }
        };
        
        // Load settings on startup
        settingsSystem.loadSettings();
        
        // Advanced help system
        const helpSystem = {
            categories: {
                basic: ['look', 'go', 'take', 'drop', 'inventory', 'help'],
                combat: ['attack', 'defend', 'flee', 'combat'],
                quests: ['quests', 'quest', 'complete'],
                crafting: ['craft', 'recipes', 'materials'],
                skills: ['skills', 'experience'],
                reputation: ['reputation', 'factions'],
                dialogue: ['talk to', 'conversation'],
                minigames: ['minigames', 'play'],
                events: ['events', 'trigger'],
                saves: ['save', 'load', 'saves'],
                settings: ['settings', 'config'],
                cheats: ['godmode', 'money', 'teleport', 'stats']
            },
            
            showHelp: function(category = null) {
                if (!category) {
                    game.output(` HELP SYSTEM:`);
                    game.output(`Available categories: ${Object.keys(this.categories).join(', ')}`);
                    game.output(`Use 'help [category]' for specific help.`);
                    return;
                }
                
                if (!this.categories[category]) {
                    game.output(` Unknown category: ${category}`);
                    return;
                }
                
                game.output(` HELP - ${category.toUpperCase()}:`);
                this.categories[category].forEach(command => {
                    game.output(`  ${command}`);
                });
            },
            
            searchHelp: function(query) {
                const results = [];
                for (const [category, commands] of Object.entries(this.categories)) {
                    const matches = commands.filter(cmd => cmd.includes(query.toLowerCase()));
                    if (matches.length > 0) {
                        results.push({ category, commands: matches });
                    }
                }
                
                if (results.length === 0) {
                    game.output(` No help found for "${query}"`);
                    return;
                }
                
                game.output(` SEARCH RESULTS for "${query}":`);
                results.forEach(result => {
                    game.output(`  ${result.category}: ${result.commands.join(', ')}`);
                });
            }
        };
        
        // Add save, settings, and help commands
        const originalProcessCommandSave = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('save ')) {
                const saveName = command.substring(5);
                saveSystem.saveGame(saveName);
                return;
            } else if (lowerCommand.startsWith('load ')) {
                const saveName = command.substring(5);
                saveSystem.loadGame(saveName);
                return;
            } else if (lowerCommand === 'saves') {
                saveSystem.listSaves();
                return;
            } else if (lowerCommand.startsWith('delete ')) {
                const saveName = command.substring(7);
                saveSystem.deleteSave(saveName);
                return;
            } else if (lowerCommand === 'settings') {
                settingsSystem.listSettings();
                return;
            } else if (lowerCommand.startsWith('set ')) {
                const parts = command.substring(4).split(' ');
                const key = parts[0];
                const value = parts[1];
                settingsSystem.updateSetting(key, value);
                return;
            } else if (lowerCommand === 'help') {
                helpSystem.showHelp();
                return;
            } else if (lowerCommand.startsWith('help ')) {
                const category = command.substring(5);
                helpSystem.showHelp(category);
                return;
            } else if (lowerCommand.startsWith('search ')) {
                const query = command.substring(7);
                helpSystem.searchHelp(query);
                return;
            }
            
            return originalProcessCommandSave.call(this, command);
        };
        
        // Advanced tutorial system
        const tutorialSystem = {
            tutorials: new Map(),
            activeTutorial: null,
            completedTutorials: new Set(),
            
            registerTutorial: function(tutorialName, tutorialData) {
                this.tutorials.set(tutorialName, tutorialData);
            },
            
            startTutorial: function(tutorialName) {
                if (!this.tutorials.has(tutorialName)) {
                    game.output(` Unknown tutorial: ${tutorialName}`);
                    return;
                }
                
                this.activeTutorial = {
                    name: tutorialName,
                    data: this.tutorials.get(tutorialName),
                    currentStep: 0
                };
                
                game.output(` Starting tutorial: ${tutorialName}`);
                this.showCurrentStep();
            },
            
            showCurrentStep: function() {
                if (!this.activeTutorial) return;
                
                const step = this.activeTutorial.data.steps[this.activeTutorial.currentStep];
                if (!step) {
                    this.completeTutorial();
                    return;
                }
                
                game.output(`\n TUTORIAL STEP ${this.activeTutorial.currentStep + 1}:`);
                game.output(step.text);
                
                if (step.command) {
                    game.output(`\nTry: ${step.command}`);
                }
                
                if (step.hint) {
                    game.output(`\n Hint: ${step.hint}`);
                }
            },
            
            nextStep: function() {
                if (!this.activeTutorial) return;
                
                this.activeTutorial.currentStep++;
                this.showCurrentStep();
            },
            
            completeTutorial: function() {
                if (!this.activeTutorial) return;
                
                this.completedTutorials.add(this.activeTutorial.name);
                game.output(`\n Tutorial "${this.activeTutorial.name}" completed!`);
                this.activeTutorial = null;
            },
            
            listTutorials: function() {
                if (this.tutorials.size === 0) {
                    game.output(` No tutorials available.`);
                    return;
                }
                
                game.output(` TUTORIALS:`);
                for (const [name, tutorial] of this.tutorials) {
                    const status = this.completedTutorials.has(name) ? '' : '';
                    game.output(`  ${status} ${name} - ${tutorial.description}`);
                }
            }
        };
        
        // Register some tutorials
        tutorialSystem.registerTutorial('getting_started', {
            description: 'Learn the basics of playing GUMSHOE Padfoot',
            steps: [
                {
                    text: 'Welcome to GUMSHOE Padfoot! This is a fantasy text-based adventure. You can type commands to interact with the world.',
                    command: 'look',
                    hint: 'Start by looking around to see what\'s in your current location.'
                },
                {
                    text: 'Great! Now try moving to a different location.',
                    command: 'go north',
                    hint: 'Use "go [direction]" to move around the world.'
                },
                {
                    text: 'Excellent! You can also examine objects and talk to people.',
                    command: 'examine [object]',
                    hint: 'Use "examine" to look at specific items or "talk to [person]" to start conversations.'
                },
                {
                    text: 'You can save your progress at any time.',
                    command: 'save mygame',
                    hint: 'Use "save [name]" to save your game and "load [name]" to load it later.'
                }
            ]
        });
        
        tutorialSystem.registerTutorial('magic_basics', {
            description: 'Learn how to use magic and spells',
            steps: [
                {
                    text: 'Magic in GUMSHOE Padfoot is powerful. You can cast spells and brew potions.',
                    command: 'play spellcasting',
                    hint: 'Use "play spellcasting" to start the magic mini-game.'
                },
                {
                    text: 'When casting spells, use "cast [spell]" to attempt magic.',
                    command: 'cast fireball',
                    hint: 'Make sure to specify which spell you want to cast.'
                },
                {
                    text: 'You can also brew potions using alchemy.',
                    command: 'play alchemy',
                    hint: 'Alchemy allows you to create powerful potions and elixirs.'
                },
                {
                    text: 'Remember, magic has consequences. Use it wisely!',
                    command: 'quit',
                    hint: 'Use "quit" to exit any mini-game safely.'
                }
            ]
        });
        
        // Advanced achievement system
        const achievementSystem = {
            achievements: new Map(),
            unlockedAchievements: new Set(),
            
            registerAchievement: function(achievementName, achievementData) {
                this.achievements.set(achievementName, achievementData);
            },
            
            unlockAchievement: function(achievementName) {
                if (!this.achievements.has(achievementName)) {
                    console.error(`Unknown achievement: ${achievementName}`);
                    return;
                }
                
                if (this.unlockedAchievements.has(achievementName)) {
                    return; // Already unlocked
                }
                
                this.unlockedAchievements.add(achievementName);
                const achievement = this.achievements.get(achievementName);
                
                game.output(`\n ACHIEVEMENT UNLOCKED: ${achievement.title}`);
                game.output(` ${achievement.description}`);
                
                if (achievement.reward) {
                    game.output(` Reward: ${achievement.reward}`);
                }
            },
            
            checkAchievements: function() {
                // Check for various achievement conditions
                if (game.state.commandsExecuted >= 100 && !this.unlockedAchievements.has('command_master')) {
                    this.unlockAchievement('command_master');
                }
                
                if (game.state.roomsVisited >= 10 && !this.unlockedAchievements.has('explorer')) {
                    this.unlockAchievement('explorer');
                }
                
                if (game.state.npcsTalkedTo >= 5 && !this.unlockedAchievements.has('social_butterfly')) {
                    this.unlockAchievement('social_butterfly');
                }
                
                if (game.state.itemsCollected >= 20 && !this.unlockedAchievements.has('collector')) {
                    this.unlockAchievement('collector');
                }
            },
            
            listAchievements: function() {
                if (this.achievements.size === 0) {
                    game.output(` No achievements available.`);
                    return;
                }
                
                game.output(` ACHIEVEMENTS:`);
                for (const [name, achievement] of this.achievements) {
                    const status = this.unlockedAchievements.has(name) ? '' : '';
                    game.output(`  ${status} ${achievement.title}`);
                    if (this.unlockedAchievements.has(name)) {
                        game.output(`     ${achievement.description}`);
                    }
                }
            }
        };
        
        // Register some achievements
        achievementSystem.registerAchievement('command_master', {
            title: 'Command Master',
            description: 'Execute 100 commands',
            reward: '+10 skill points'
        });
        
        achievementSystem.registerAchievement('explorer', {
            title: 'Explorer',
            description: 'Visit 10 different locations',
            reward: '+5 reputation with all factions'
        });
        
        achievementSystem.registerAchievement('social_butterfly', {
            title: 'Social Butterfly',
            description: 'Talk to 5 different NPCs',
            reward: '+3 persuasion skill'
        });
        
        achievementSystem.registerAchievement('collector', {
            title: 'Collector',
            description: 'Collect 20 different items',
            reward: '+5 inventory capacity'
        });
        
        // Add tutorial and achievement commands
        const originalProcessCommandTutorial = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'tutorials') {
                tutorialSystem.listTutorials();
                return;
            } else if (lowerCommand.startsWith('tutorial ')) {
                const tutorialName = command.substring(9);
                tutorialSystem.startTutorial(tutorialName);
                return;
            } else if (lowerCommand === 'next') {
                tutorialSystem.nextStep();
                return;
            } else if (lowerCommand === 'achievements') {
                achievementSystem.listAchievements();
                return;
            }
            
            return originalProcessCommandTutorial.call(this, command);
        };
        
        // Advanced music and sound system
        const audioSystem = {
            music: new Map(),
            sounds: new Map(),
            currentMusic: null,
            volume: 0.5,
            muted: false,
            
            registerMusic: function(trackName, trackData) {
                this.music.set(trackName, trackData);
            },
            
            registerSound: function(soundName, soundData) {
                this.sounds.set(soundName, soundData);
            },
            
            playMusic: function(trackName, loop = true) {
                if (this.muted) return;
                
                const track = this.music.get(trackName);
                if (!track) {
                    game.output(` Music track not found: ${trackName}`);
                    return;
                }
                
                if (this.currentMusic) {
                    this.stopMusic();
                }
                
                this.currentMusic = trackName;
                game.output(` Now playing: ${track.title}`);
                
                // In a real implementation, you would play actual audio
                // For now, we'll just simulate it
                if (track.description) {
                    game.output(` ${track.description}`);
                }
            },
            
            stopMusic: function() {
                if (this.currentMusic) {
                    game.output(` Music stopped`);
                    this.currentMusic = null;
                }
            },
            
            playSound: function(soundName) {
                if (this.muted) return;
                
                const sound = this.sounds.get(soundName);
                if (!sound) {
                    game.output(` Sound not found: ${soundName}`);
                    return;
                }
                
                game.output(` ${sound.description}`);
            },
            
            setVolume: function(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                game.output(` Volume set to ${Math.floor(this.volume * 100)}%`);
            },
            
            toggleMute: function() {
                this.muted = !this.muted;
                game.output(` Audio ${this.muted ? 'muted' : 'unmuted'}`);
            },
            
            listMusic: function() {
                if (this.music.size === 0) {
                    game.output(` No music tracks available.`);
                    return;
                }
                
                game.output(` MUSIC TRACKS:`);
                for (const [name, track] of this.music) {
                    const status = this.currentMusic === name ? '' : '';
                    game.output(`  ${status} ${name} - ${track.title}`);
                }
            },
            
            listSounds: function() {
                if (this.sounds.size === 0) {
                    game.output(` No sounds available.`);
                    return;
                }
                
                game.output(` SOUNDS:`);
                for (const [name, sound] of this.sounds) {
                    game.output(`  ${name} - ${sound.description}`);
                }
            }
        };
        
        // Register some music and sounds
        audioSystem.registerMusic('main_theme', {
            title: 'Main Theme',
            description: 'The mystical melody of the enchanted forest'
        });
        
        audioSystem.registerMusic('combat_theme', {
            title: 'Combat Theme',
            description: 'Epic orchestral music for magical battles'
        });
        
        audioSystem.registerMusic('magic_theme', {
            title: 'Magic Theme',
            description: 'Enchanting music for spellcasting and magic'
        });
        
        audioSystem.registerSound('magic_spell', {
            description: 'The sound of magic being cast'
        });
        
        audioSystem.registerSound('sword_clash', {
            description: 'Swords clashing in battle'
        });
        
        audioSystem.registerSound('door_creak', {
            description: 'An old wooden door creaks open'
        });
        
        audioSystem.registerSound('rain', {
            description: 'Gentle rain falling in the forest'
        });
        
        // Advanced notification system
        const notificationSystem = {
            notifications: [],
            maxNotifications: 10,
            
            addNotification: function(type, title, message, duration = 5000) {
                const notification = {
                    id: Date.now(),
                    type: type,
                    title: title,
                    message: message,
                    timestamp: Date.now(),
                    duration: duration
                };
                
                this.notifications.unshift(notification);
                
                // Limit number of notifications
                if (this.notifications.length > this.maxNotifications) {
                    this.notifications = this.notifications.slice(0, this.maxNotifications);
                }
                
                this.displayNotification(notification);
            },
            
            displayNotification: function(notification) {
                const typeEmoji = {
                    'info': '',
                    'success': '',
                    'warning': '',
                    'error': '',
                    'achievement': '',
                    'quest': '',
                    'combat': '',
                    'item': ''
                };
                
                const emoji = typeEmoji[notification.type] || '';
                game.output(`\n${emoji} ${notification.title}`);
                game.output(`   ${notification.message}`);
            },
            
            listNotifications: function() {
                if (this.notifications.length === 0) {
                    game.output(` No notifications.`);
                    return;
                }
                
                game.output(` RECENT NOTIFICATIONS:`);
                this.notifications.slice(0, 5).forEach(notification => {
                    const timeAgo = Math.floor((Date.now() - notification.timestamp) / 1000);
                    const typeEmoji = {
                        'info': '',
                        'success': '',
                        'warning': '',
                        'error': '',
                        'achievement': '',
                        'quest': '',
                        'combat': '',
                        'item': ''
                    };
                    const emoji = typeEmoji[notification.type] || '';
                    game.output(`  ${emoji} ${notification.title} (${timeAgo}s ago)`);
                });
            },
            
            clearNotifications: function() {
                this.notifications = [];
                game.output(` All notifications cleared.`);
            }
        };
        
        // Add audio and notification commands
        const originalProcessCommandAudio = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'music') {
                audioSystem.listMusic();
                return;
            } else if (lowerCommand.startsWith('play ')) {
                const trackName = command.substring(5);
                audioSystem.playMusic(trackName);
                return;
            } else if (lowerCommand === 'stop') {
                audioSystem.stopMusic();
                return;
            } else if (lowerCommand === 'sounds') {
                audioSystem.listSounds();
                return;
            } else if (lowerCommand.startsWith('sound ')) {
                const soundName = command.substring(6);
                audioSystem.playSound(soundName);
                return;
            } else if (lowerCommand.startsWith('volume ')) {
                const volume = parseFloat(command.substring(7));
                audioSystem.setVolume(volume);
                return;
            } else if (lowerCommand === 'mute') {
                audioSystem.toggleMute();
                return;
            } else if (lowerCommand === 'notifications') {
                notificationSystem.listNotifications();
                return;
            } else if (lowerCommand === 'clear') {
                notificationSystem.clearNotifications();
                return;
            }
            
            return originalProcessCommandAudio.call(this, command);
        };
        
        // Advanced screenshot and recording system
        const recordingSystem = {
            screenshots: [],
            recordings: [],
            maxScreenshots: 50,
            maxRecordings: 10,
            
            takeScreenshot: function(description = '') {
                const screenshot = {
                    id: Date.now(),
                    timestamp: Date.now(),
                    description: description,
                    gameState: {
                        location: game.state.currentLocation,
                        inventory: game.state.inventory,
                        health: game.state.health,
                        cash: game.state.cash,
                        debt: game.state.debt
                    }
                };
                
                this.screenshots.unshift(screenshot);
                
                // Limit number of screenshots
                if (this.screenshots.length > this.maxScreenshots) {
                    this.screenshots = this.screenshots.slice(0, this.maxScreenshots);
                }
                
                game.output(` Screenshot taken: ${description || 'Untitled'}`);
                notificationSystem.addNotification('info', 'Screenshot Saved', `Screenshot "${description || 'Untitled'}" has been saved.`);
            },
            
            startRecording: function(description = '') {
                const recording = {
                    id: Date.now(),
                    timestamp: Date.now(),
                    description: description,
                    startTime: Date.now(),
                    isRecording: true,
                    events: []
                };
                
                this.recordings.unshift(recording);
                
                // Limit number of recordings
                if (this.recordings.length > this.maxRecordings) {
                    this.recordings = this.recordings.slice(0, this.maxRecordings);
                }
                
                game.output(` Recording started: ${description || 'Untitled'}`);
                notificationSystem.addNotification('info', 'Recording Started', `Recording "${description || 'Untitled'}" has been started.`);
            },
            
            stopRecording: function() {
                const activeRecording = this.recordings.find(r => r.isRecording);
                if (!activeRecording) {
                    game.output(` No active recording to stop.`);
                    return;
                }
                
                activeRecording.isRecording = false;
                activeRecording.endTime = Date.now();
                activeRecording.duration = activeRecording.endTime - activeRecording.startTime;
                
                game.output(` Recording stopped: ${activeRecording.description || 'Untitled'}`);
                game.output(` Duration: ${Math.floor(activeRecording.duration / 1000)}s`);
                notificationSystem.addNotification('info', 'Recording Stopped', `Recording "${activeRecording.description || 'Untitled'}" has been stopped.`);
            },
            
            listScreenshots: function() {
                if (this.screenshots.length === 0) {
                    game.output(` No screenshots available.`);
                    return;
                }
                
                game.output(` SCREENSHOTS:`);
                this.screenshots.slice(0, 10).forEach(screenshot => {
                    const timeAgo = Math.floor((Date.now() - screenshot.timestamp) / 1000);
                    game.output(`   ${screenshot.description || 'Untitled'} (${timeAgo}s ago)`);
                });
            },
            
            listRecordings: function() {
                if (this.recordings.length === 0) {
                    game.output(` No recordings available.`);
                    return;
                }
                
                game.output(` RECORDINGS:`);
                this.recordings.slice(0, 10).forEach(recording => {
                    const timeAgo = Math.floor((Date.now() - recording.timestamp) / 1000);
                    const status = recording.isRecording ? '' : '';
                    const duration = recording.duration ? ` (${Math.floor(recording.duration / 1000)}s)` : '';
                    game.output(`  ${status} ${recording.description || 'Untitled'} (${timeAgo}s ago)${duration}`);
                });
            },
            
            clearScreenshots: function() {
                this.screenshots = [];
                game.output(` All screenshots cleared.`);
            },
            
            clearRecordings: function() {
                this.recordings = [];
                game.output(` All recordings cleared.`);
            }
        };
        
        // Advanced macro system
        const macroSystem = {
            macros: new Map(),
            maxMacros: 20,
            
            createMacro: function(name, commands) {
                if (this.macros.size >= this.maxMacros) {
                    game.output(` Maximum number of macros reached (${this.maxMacros}).`);
                    return;
                }
                
                if (this.macros.has(name)) {
                    game.output(` Macro "${name}" already exists.`);
                    return;
                }
                
                this.macros.set(name, {
                    name: name,
                    commands: commands,
                    created: Date.now(),
                    uses: 0
                });
                
                game.output(` Macro "${name}" created with ${commands.length} commands.`);
                notificationSystem.addNotification('success', 'Macro Created', `Macro "${name}" has been created successfully.`);
            },
            
            executeMacro: function(name) {
                const macro = this.macros.get(name);
                if (!macro) {
                    game.output(` Macro "${name}" not found.`);
                    return;
                }
                
                game.output(` Executing macro: ${name}`);
                macro.uses++;
                
                // Execute each command with a small delay
                macro.commands.forEach((command, index) => {
                    setTimeout(() => {
                        game.processCommand(command);
                    }, index * 100); // 100ms delay between commands
                });
                
                notificationSystem.addNotification('info', 'Macro Executed', `Macro "${name}" has been executed (${macro.uses} uses).`);
            },
            
            listMacros: function() {
                if (this.macros.size === 0) {
                    game.output(` No macros available.`);
                    return;
                }
                
                game.output(` MACROS:`);
                for (const [name, macro] of this.macros) {
                    game.output(`   ${name} - ${macro.commands.length} commands (${macro.uses} uses)`);
                }
            },
            
            deleteMacro: function(name) {
                if (!this.macros.has(name)) {
                    game.output(` Macro "${name}" not found.`);
                    return;
                }
                
                this.macros.delete(name);
                game.output(` Macro "${name}" deleted.`);
                notificationSystem.addNotification('info', 'Macro Deleted', `Macro "${name}" has been deleted.`);
            },
            
            clearMacros: function() {
                this.macros.clear();
                game.output(` All macros cleared.`);
            }
        };
        
        // Add recording and macro commands
        const originalProcessCommandRecording = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('screenshot ')) {
                const description = command.substring(11);
                recordingSystem.takeScreenshot(description);
                return;
            } else if (lowerCommand === 'screenshots') {
                recordingSystem.listScreenshots();
                return;
            } else if (lowerCommand.startsWith('record ')) {
                const description = command.substring(7);
                recordingSystem.startRecording(description);
                return;
            } else if (lowerCommand === 'stop') {
                recordingSystem.stopRecording();
                return;
            } else if (lowerCommand === 'recordings') {
                recordingSystem.listRecordings();
                return;
            } else if (lowerCommand === 'clear screenshots') {
                recordingSystem.clearScreenshots();
                return;
            } else if (lowerCommand === 'clear recordings') {
                recordingSystem.clearRecordings();
                return;
            } else if (lowerCommand.startsWith('macro ')) {
                const parts = command.substring(6).split(' ');
                const action = parts[0];
                const name = parts[1];
                
                if (action === 'create') {
                    const commands = parts.slice(2).join(' ').split(';').map(cmd => cmd.trim());
                    macroSystem.createMacro(name, commands);
                } else if (action === 'execute') {
                    macroSystem.executeMacro(name);
                } else if (action === 'delete') {
                    macroSystem.deleteMacro(name);
                } else {
                    game.output(` Unknown macro action: ${action}`);
                }
                return;
            } else if (lowerCommand === 'macros') {
                macroSystem.listMacros();
                return;
            } else if (lowerCommand === 'clear macros') {
                macroSystem.clearMacros();
                return;
            }
            
            return originalProcessCommandRecording.call(this, command);
        };
        
        // Advanced plugin system
        const pluginSystem = {
            plugins: new Map(),
            maxPlugins: 50,
            
            loadPlugin: function(pluginName, pluginCode) {
                if (this.plugins.size >= this.maxPlugins) {
                    game.output(` Maximum number of plugins reached (${this.maxPlugins}).`);
                    return;
                }
                
                if (this.plugins.has(pluginName)) {
                    game.output(` Plugin "${pluginName}" already loaded.`);
                    return;
                }
                
                try {
                    // Create a safe execution context
                    const pluginContext = {
                        game: game,
                        console: console,
                        Date: Date,
                        Math: Math,
                        JSON: JSON,
                        setTimeout: setTimeout,
                        setInterval: setInterval,
                        clearTimeout: clearTimeout,
                        clearInterval: clearInterval
                    };
                    
                    // Execute plugin code in safe context
                    const pluginFunction = new Function('context', `
                        with (context) {
                            ${pluginCode}
                        }
                    `);
                    
                    const pluginInstance = pluginFunction(pluginContext);
                    
                    this.plugins.set(pluginName, {
                        name: pluginName,
                        instance: pluginInstance,
                        loaded: Date.now(),
                        enabled: true
                    });
                    
                    game.output(` Plugin "${pluginName}" loaded successfully.`);
                    notificationSystem.addNotification('success', 'Plugin Loaded', `Plugin "${pluginName}" has been loaded successfully.`);
                } catch (error) {
                    game.output(` Failed to load plugin "${pluginName}": ${error.message}`);
                    notificationSystem.addNotification('error', 'Plugin Error', `Failed to load plugin "${pluginName}": ${error.message}`);
                }
            },
            
            unloadPlugin: function(pluginName) {
                if (!this.plugins.has(pluginName)) {
                    game.output(` Plugin "${pluginName}" not found.`);
                    return;
                }
                
                this.plugins.delete(pluginName);
                game.output(` Plugin "${pluginName}" unloaded.`);
                notificationSystem.addNotification('info', 'Plugin Unloaded', `Plugin "${pluginName}" has been unloaded.`);
            },
            
            listPlugins: function() {
                if (this.plugins.size === 0) {
                    game.output(` No plugins loaded.`);
                    return;
                }
                
                game.output(` LOADED PLUGINS:`);
                for (const [name, plugin] of this.plugins) {
                    const status = plugin.enabled ? '' : '';
                    game.output(`  ${status} ${name} (loaded ${Math.floor((Date.now() - plugin.loaded) / 1000)}s ago)`);
                }
            },
            
            enablePlugin: function(pluginName) {
                const plugin = this.plugins.get(pluginName);
                if (!plugin) {
                    game.output(` Plugin "${pluginName}" not found.`);
                    return;
                }
                
                plugin.enabled = true;
                game.output(` Plugin "${pluginName}" enabled.`);
                notificationSystem.addNotification('info', 'Plugin Enabled', `Plugin "${pluginName}" has been enabled.`);
            },
            
            disablePlugin: function(pluginName) {
                const plugin = this.plugins.get(pluginName);
                if (!plugin) {
                    game.output(` Plugin "${pluginName}" not found.`);
                    return;
                }
                
                plugin.enabled = false;
                game.output(` Plugin "${pluginName}" disabled.`);
                notificationSystem.addNotification('info', 'Plugin Disabled', `Plugin "${pluginName}" has been disabled.`);
            },
            
            clearPlugins: function() {
                this.plugins.clear();
                game.output(` All plugins cleared.`);
            }
        };
        
        // Advanced scripting system
        const scriptingSystem = {
            scripts: new Map(),
            maxScripts: 100,
            
            createScript: function(scriptName, scriptCode) {
                if (this.scripts.size >= this.maxScripts) {
                    game.output(` Maximum number of scripts reached (${this.maxScripts}).`);
                    return;
                }
                
                if (this.scripts.has(scriptName)) {
                    game.output(` Script "${scriptName}" already exists.`);
                    return;
                }
                
                this.scripts.set(scriptName, {
                    name: scriptName,
                    code: scriptCode,
                    created: Date.now(),
                    runs: 0
                });
                
                game.output(` Script "${scriptName}" created successfully.`);
                notificationSystem.addNotification('success', 'Script Created', `Script "${scriptName}" has been created successfully.`);
            },
            
            runScript: function(scriptName) {
                const script = this.scripts.get(scriptName);
                if (!script) {
                    game.output(` Script "${scriptName}" not found.`);
                    return;
                }
                
                try {
                    // Create a safe execution context
                    const scriptContext = {
                        game: game,
                        console: console,
                        Date: Date,
                        Math: Math,
                        JSON: JSON,
                        setTimeout: setTimeout,
                        setInterval: setInterval,
                        clearTimeout: clearTimeout,
                        clearInterval: clearInterval
                    };
                    
                    // Execute script code in safe context
                    const scriptFunction = new Function('context', `
                        with (context) {
                            ${script.code}
                        }
                    `);
                    
                    scriptFunction(scriptContext);
                    script.runs++;
                    
                    game.output(` Script "${scriptName}" executed successfully.`);
                    notificationSystem.addNotification('info', 'Script Executed', `Script "${scriptName}" has been executed (${script.runs} runs).`);
                } catch (error) {
                    game.output(` Failed to execute script "${scriptName}": ${error.message}`);
                    notificationSystem.addNotification('error', 'Script Error', `Failed to execute script "${scriptName}": ${error.message}`);
                }
            },
            
            listScripts: function() {
                if (this.scripts.size === 0) {
                    game.output(` No scripts available.`);
                    return;
                }
                
                game.output(` SCRIPTS:`);
                for (const [name, script] of this.scripts) {
                    game.output(`   ${name} - ${script.runs} runs`);
                }
            },
            
            deleteScript: function(scriptName) {
                if (!this.scripts.has(scriptName)) {
                    game.output(` Script "${scriptName}" not found.`);
                    return;
                }
                
                this.scripts.delete(scriptName);
                game.output(` Script "${scriptName}" deleted.`);
                notificationSystem.addNotification('info', 'Script Deleted', `Script "${scriptName}" has been deleted.`);
            },
            
            clearScripts: function() {
                this.scripts.clear();
                game.output(` All scripts cleared.`);
            }
        };
        
        // Add plugin and scripting commands
        const originalProcessCommandPlugin = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('plugin load ')) {
                const parts = command.substring(12).split(' ');
                const pluginName = parts[0];
                const pluginCode = parts.slice(1).join(' ');
                pluginSystem.loadPlugin(pluginName, pluginCode);
                return;
            } else if (lowerCommand.startsWith('plugin unload ')) {
                const pluginName = command.substring(14);
                pluginSystem.unloadPlugin(pluginName);
                return;
            } else if (lowerCommand === 'plugins') {
                pluginSystem.listPlugins();
                return;
            } else if (lowerCommand.startsWith('plugin enable ')) {
                const pluginName = command.substring(14);
                pluginSystem.enablePlugin(pluginName);
                return;
            } else if (lowerCommand.startsWith('plugin disable ')) {
                const pluginName = command.substring(15);
                pluginSystem.disablePlugin(pluginName);
                return;
            } else if (lowerCommand === 'clear plugins') {
                pluginSystem.clearPlugins();
                return;
            } else if (lowerCommand.startsWith('script create ')) {
                const parts = command.substring(14).split(' ');
                const scriptName = parts[0];
                const scriptCode = parts.slice(1).join(' ');
                scriptingSystem.createScript(scriptName, scriptCode);
                return;
            } else if (lowerCommand.startsWith('script run ')) {
                const scriptName = command.substring(11);
                scriptingSystem.runScript(scriptName);
                return;
            } else if (lowerCommand === 'scripts') {
                scriptingSystem.listScripts();
                return;
            } else if (lowerCommand.startsWith('script delete ')) {
                const scriptName = command.substring(14);
                scriptingSystem.deleteScript(scriptName);
                return;
            } else if (lowerCommand === 'clear scripts') {
                scriptingSystem.clearScripts();
                return;
            }
            
            return originalProcessCommandPlugin.call(this, command);
        };
        
        // Game data will be loaded from server
        
        // Load game data from server (only if not in localhost mode)
        if (API_BASE_URL) {
        (async () => {
            try {
                const response = await fetch(`${API_BASE_URL}/api/games/data/fantasy`);
                const result = await response.json();
                
                if (result.gameConfig) {
                    // Replace the original game.data with server data
                    game.data = result.gameConfig;
                    console.log('Game data loaded from server successfully');
                } else {
                    console.error('Failed to load game data from server:', result.error?.message || 'Unknown error');
                }
            } catch (error) {
                console.error('Error loading game data from server:', error);
            }
        })();
        } else {
            console.log('Running in localhost mode - using local game data');
        }
        
        // --- 8-BIT FANTASY BACKGROUND MUSIC ---
        class FantasyMusic {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.isMuted = false; // Start unmuted for better user experience
                this.currentMelody = null;
                this.patterns = this.initializePatterns();
                this.initAudio();
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }
            
            initializePatterns() {
                return {
                    // Main fantasy melody patterns
                    mainTheme: [
                        { freq: 330, duration: 0.5 },  // E4 - half note
                        { freq: 370, duration: 0.5 },  // F#4 - half note
                        { freq: 415, duration: 0.5 },  // G#4 - half note
                        { freq: 370, duration: 0.5 },  // F#4 - half note
                        { freq: 330, duration: 0.5 },  // E4 - half note
                        { freq: 294, duration: 0.5 },  // D4 - half note
                        { freq: 330, duration: 1.0 },  // E4 - whole note
                    ],
                    // Bass line pattern
                    bassLine: [
                        { freq: 165, duration: 0.5 },  // E3 - half note
                        { freq: 185, duration: 0.5 },   // F#3 - half note
                        { freq: 208, duration: 0.5 },   // G#3 - half note
                        { freq: 185, duration: 0.5 },   // F#3 - half note
                    ],
                    // Mystical arpeggio
                    arpeggio: [
                        { freq: 330, duration: 0.25 }, // E4 - quarter note
                        { freq: 370, duration: 0.25 }, // F#4 - quarter note
                        { freq: 415, duration: 0.25 }, // G#4 - quarter note
                        { freq: 370, duration: 0.25 }, // F#4 - quarter note
                    ],
                    // Syncopated rhythm
                    syncopated: [
                        { freq: 330, duration: 0.25 }, // E4 - quarter note
                        { freq: 0, duration: 0.25 },  // Rest - quarter note
                        { freq: 370, duration: 0.25 }, // F#4 - quarter note
                        { freq: 415, duration: 0.5 },  // G#4 - half note
                        { freq: 0, duration: 0.25 },   // Rest - quarter note
                        { freq: 330, duration: 0.5 },  // E4 - half note
                    ]
                };
            }
            
            generateFantasyMelody() {
                // Randomly select and combine patterns
                const patternKeys = Object.keys(this.patterns);
                const selectedPattern = this.patterns[patternKeys[Math.floor(Math.random() * patternKeys.length)]];
                
                // Add some variation with random notes
                const melody = [...selectedPattern];
                
                // Occasionally add random eighth notes or rests
                if (Math.random() < 0.3) {
                    const randomNote = {
                        freq: [165, 185, 208, 247, 277, 330, 370, 415][Math.floor(Math.random() * 8)],
                        duration: Math.random() < 0.5 ? 0.25 : 0.5
                    };
                    melody.splice(Math.floor(Math.random() * melody.length), 0, randomNote);
                }
                
                // Occasionally add rests for rhythm variation
                if (Math.random() < 0.2) {
                    melody.splice(Math.floor(Math.random() * melody.length), 0, { freq: 0, duration: 0.25 });
                }
                
                return melody;
            }
            
            playNote(frequency, duration, startTime = 0) {
                if (!this.audioContext || this.isMuted) return;
                
                if (frequency === 0) return; // Rest
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime + startTime);
                oscillator.type = 'triangle'; // More mystical sound
                
                gainNode.gain.setValueAtTime(0.08, this.audioContext.currentTime + startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + startTime + duration);
                
                oscillator.start(this.audioContext.currentTime + startTime);
                oscillator.stop(this.audioContext.currentTime + startTime + duration);
            }
            
            playMelody() {
                if (!this.audioContext || this.isPlaying || this.isMuted) return;
                
                this.isPlaying = true;
                const melody = this.generateFantasyMelody();
                let currentTime = 0;
                
                melody.forEach(note => {
                    this.playNote(note.freq, note.duration, currentTime);
                    currentTime += note.duration;
                });
                
                // Loop the melody with slight variation
                setTimeout(() => {
                    this.isPlaying = false;
                    if (this.audioContext.state === 'running' && !this.isMuted) {
                        this.playMelody();
                    }
                }, currentTime * 1000);
            }
            
            start() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                this.isMuted = false; // Start unmuted for better user experience
                this.playMelody();
            }
            
            stop() {
                if (this.audioContext) {
                    this.audioContext.suspend();
                }
                this.isPlaying = false;
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                const muteBtn = document.getElementById('mute-btn');
                if (muteBtn) {
                    muteBtn.classList.toggle('muted', this.isMuted);
                    muteBtn.innerHTML = this.isMuted ? 
                        '<i class="fas fa-volume-mute"></i> Unmute' : 
                        '<i class="fas fa-volume-up"></i> Mute';
                }
                
                if (this.isMuted) {
                    this.stop();
                } else if (this.audioContext && this.audioContext.state === 'running') {
                    this.start();
                }
            }
        }
        
        // Initialize music
        const music = new FantasyMusic();
        
        // Global mute function
        function toggleMute() {
            music.toggleMute();
        }
        
        // Start music after user interaction
        document.addEventListener('click', () => {
            if (music.audioContext && music.audioContext.state === 'suspended') {
                music.start();
            }
        }, { once: true });
        
        // Also start music on any keypress
        document.addEventListener('keydown', () => {
            if (music.audioContext && music.audioContext.state === 'suspended') {
                music.start();
            }
        }, { once: true });
        
        // Start music when page loads (if browser allows)
        document.addEventListener('DOMContentLoaded', () => {
            // Try to start music immediately
            if (music.audioContext && music.audioContext.state === 'running') {
                music.start();
            }
        });
        
        // Start music when menu is interacted with
        document.getElementById('menu-overlay').addEventListener('click', () => {
            if (music.audioContext && music.audioContext.state === 'suspended') {
                music.start();
            }
        }, { once: true });
    </script>
</body>
</html>

