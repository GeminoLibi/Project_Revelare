<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHROME NOIR: The Case of the Glowing Orb</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&family=VT323&display=swap" rel="stylesheet">
    <!-- Google AdSense - Minimal Script -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3891410174900441"></script>
    <style>
        /*
         * NEON CITY Terminal Aesthetics - Cyberpunk Enhancements:
         *
         * Digital Noise Effects: Cyberpunk-style glitch and interference animations
         * Neon CRT Scanlines: Magenta/cyan alternating scanlines with data streams
         * Cyberpunk Particles: RGB-colored floating energy particles
         * Circuit Pattern Overlays: Diagonal neon circuit board patterns
         * Neon Flicker Effects: Multi-stage brightness/color cycling
         * Data Stream Animations: Horizontal flowing digital data effect
         * Cyberpunk Typography: Enhanced glows with RGB color shifts
         *
         * Background Art: Cyberpunk neon cityscape (./neon_background.png)
         * Menu Art: Neon-lit data center (./neon_menu.png)
         * Particle Effects: RGB cyberpunk energy particles
         * Blend Modes: Advanced CSS blending for atmospheric depth
         *
         * All effects implemented with pure CSS and HTML5 techniques.
         * Cyberpunk aesthetic optimized for neon/cyberpunk game theme.
         */

        :root {
            --background-color: #0d0d1a;
            --text-color: #00f0ff; /* Electric Cyan */
            --glow-color: #ff00ff; /* Magenta */
            --border-color: #4a004a; /* Dark Purple */
            --accent-color: #f000f0; /* Bright Magenta */
            --font-main: 'VT323', monospace;
            --font-header: 'Special Elite', cursive;
        }
        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 18px;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            background-image: url('./neon_background.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            padding-top: 80px; /* Add space for navigation bar */
        }
        #terminal-container {
            width: 95%;
            max-width: 800px;
            height: 90vh;
            border: 4px solid var(--border-color);
            border-radius: 8px;
            background:
                /* Deep cyberpunk gradient */
                radial-gradient(ellipse at center, rgba(13, 13, 26, 0.95) 0%, rgba(5, 5, 10, 0.95) 100%),
                /* Neon circuit pattern overlay */
                linear-gradient(45deg, rgba(255, 0, 255, 0.03) 25%, transparent 25%, transparent 75%, rgba(255, 0, 255, 0.03) 75%),
                linear-gradient(-45deg, rgba(0, 255, 255, 0.02) 25%, transparent 25%, transparent 75%, rgba(0, 255, 255, 0.02) 75%);
            background-size: 20px 20px, 40px 40px, 60px 60px;
            box-shadow:
                0 0 20px var(--glow-color),
                0 0 40px rgba(255, 0, 255, 0.3),
                0 0 60px rgba(0, 255, 255, 0.2),
                inset 0 0 20px rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        #terminal-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Digital noise/glitch effect */
                radial-gradient(circle at 30% 70%, rgba(255, 0, 255, 0.15) 0%, transparent 40%),
                radial-gradient(circle at 70% 30%, rgba(0, 255, 255, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 50% 50%, rgba(255, 255, 0, 0.08) 0%, transparent 40%);
            pointer-events: none;
            z-index: 5;
            animation: digital-noise 0.8s steps(12) infinite;
        }

        #terminal-container::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Cyberpunk CRT scanlines */
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 3px,
                    rgba(255, 0, 255, 0.04) 3px,
                    rgba(255, 0, 255, 0.04) 6px
                ),
                /* Data stream effect */
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 1px,
                    rgba(0, 255, 255, 0.02) 1px,
                    rgba(0, 255, 255, 0.02) 2px
                ),
                /* Vignette with neon tint */
                radial-gradient(ellipse at center, transparent 50%, rgba(0, 0, 20, 0.6) 100%),
                /* Atmospheric glow */
                radial-gradient(circle, rgba(255, 0, 255, 0.06) 20%, rgba(0, 255, 255, 0.04) 50%, transparent 80%);
            pointer-events: none;
            z-index: 10;
            animation: neon-flicker 0.12s infinite, data-stream 2s linear infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.8; }
            50% { opacity: 0.9; }
            100% { opacity: 1; }
        }

        @keyframes digital-noise {
            0%, 100% {
                transform: translate(0, 0) scale(1);
                filter: hue-rotate(0deg);
            }
            25% {
                transform: translate(-0.5px, -0.5px) scale(1.01);
                filter: hue-rotate(90deg);
            }
            50% {
                transform: translate(0.5px, -0.5px) scale(0.99);
                filter: hue-rotate(180deg);
            }
            75% {
                transform: translate(-0.5px, 0.5px) scale(1.005);
                filter: hue-rotate(270deg);
            }
        }

        @keyframes neon-flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                opacity: 1;
                filter: brightness(1);
            }
            19%, 21%, 54%, 56% {
                opacity: 0.85;
                filter: brightness(1.1) hue-rotate(45deg);
            }
            20%, 55% {
                opacity: 0.7;
                filter: brightness(1.2) hue-rotate(90deg);
            }
            23%, 24% {
                opacity: 0.9;
                filter: brightness(0.9) hue-rotate(-45deg);
            }
        }

        @keyframes data-stream {
            0% { background-position: 0 0; }
            100% { background-position: 20px 0; }
        }
        #header {
            padding: 15px 20px;
            border-bottom: 3px solid var(--border-color);
            text-align: center;
            font-family: var(--font-header);
            font-size: 28px;
            color: var(--accent-color);
            text-shadow:
                2px 2px 6px rgba(0, 0, 0, 0.9),
                0 0 12px var(--glow-color),
                0 0 18px var(--glow-color),
                0 0 24px rgba(255, 0, 255, 0.5),
                0 0 30px rgba(0, 255, 255, 0.3);
            flex-shrink: 0;
            background:
                linear-gradient(135deg, rgba(10, 5, 15, 0.9), rgba(15, 10, 20, 0.7)),
                radial-gradient(circle at 30% 70%, rgba(255, 0, 255, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 70% 30%, rgba(0, 255, 255, 0.15) 0%, transparent 50%);
            font-weight: bold;
            position: relative;
            letter-spacing: 2px;
            text-transform: uppercase;
            border-image: linear-gradient(90deg, rgba(255, 0, 255, 0.5), rgba(0, 255, 255, 0.5), rgba(255, 0, 255, 0.5)) 1;
        }

        #header::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image:
                linear-gradient(45deg, rgba(255, 0, 255, 0.1) 25%, transparent 25%, transparent 75%, rgba(255, 0, 255, 0.1) 75%),
                linear-gradient(-45deg, rgba(0, 255, 255, 0.08) 25%, transparent 25%, transparent 75%, rgba(0, 255, 255, 0.08) 75%);
            background-size: 30px 30px, 40px 40px;
            pointer-events: none;
            opacity: 0.4;
            animation: circuit-flow 3s linear infinite;
        }

        @keyframes circuit-flow {
            0% { background-position: 0 0, 0 0; }
            100% { background-position: 30px 30px, -40px -40px; }
        }

        #money-display {
            position: absolute;
            top: 10px;
            right: 20px;
            font-family: var(--font-main);
            font-size: 16px;
            color: var(--glow-color);
            text-shadow: 0 0 3px var(--glow-color);
            background-color: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        #output {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            text-shadow: 0 0 4px var(--text-color);
            line-height: 1.4;
            white-space: pre-wrap;
        }
        #input-line {
            display: flex;
            padding: 10px 20px;
            border-top: 1px solid var(--border-color);
            background-color: rgba(0,0,0,0.2);
            flex-shrink: 0;
            align-items: center;
        }
        #prompt { color: var(--glow-color); margin-right: 10px; }
        #input {
            background: none; border: none; color: var(--text-color);
            font-family: var(--font-main); font-size: 18px;
            width: 100%; outline: none; text-shadow: 0 0 4px var(--text-color);
        }
        #output::-webkit-scrollbar {
            width: 12px;
            background: linear-gradient(to bottom, rgba(5, 0, 10, 0.8), rgba(10, 0, 20, 0.8));
        }
        #output::-webkit-scrollbar-track {
            background: linear-gradient(to bottom, rgba(15, 5, 25, 0.6), rgba(20, 10, 30, 0.6));
            border-radius: 6px;
            margin: 2px;
            box-shadow: inset 0 0 5px rgba(255, 0, 255, 0.3);
        }
        #output::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, var(--glow-color), rgba(255, 0, 255, 0.8));
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        #output::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, rgba(255, 0, 255, 0.8), var(--glow-color));
            box-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }
        .game-button {
            background-color: var(--border-color);
            color: var(--text-color);
            border: 1px solid var(--glow-color);
            padding: 5px 10px;
            margin-left: 10px;
            font-family: var(--font-main);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .game-button:hover { background-color: var(--glow-color); color: var(--background-color); text-shadow: none; }
        
        /* Menu Overlay Styles */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            height: 100vh;
            width: 100vw;
            background:
                /* Enhanced menu art with blend mode */
                radial-gradient(ellipse at center, rgba(5, 0, 15, 0.9) 0%, rgba(10, 5, 25, 0.8) 40%, rgba(255, 0, 255, 0.1) 80%, rgba(0, 255, 255, 0.05) 100%),
                url('./neon_menu.png') center/cover;
            background-blend-mode: multiply, normal;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            position: relative;
        }

        .menu-overlay::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Cyberpunk data streams */
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 4px,
                    rgba(255, 0, 255, 0.1) 4px,
                    rgba(255, 0, 255, 0.1) 8px
                ),
                /* Digital interference */
                radial-gradient(circle at 25% 75%, rgba(0, 255, 255, 0.2) 0%, transparent 60%),
                radial-gradient(circle at 75% 25%, rgba(255, 255, 0, 0.15) 0%, transparent 60%);
            animation: cyberpunk-static 0.6s steps(16) infinite;
            pointer-events: none;
            opacity: 0.7;
        }

        .menu-overlay::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Neon energy waves */
                radial-gradient(circle at 30% 20%, rgba(255, 0, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(0, 255, 255, 0.12) 0%, transparent 50%),
                linear-gradient(45deg, rgba(0, 0, 0, 0.4) 0%, transparent 40%, transparent 60%, rgba(0, 0, 0, 0.4) 100%);
            animation: neon-pulse 4s ease-in-out infinite alternate;
            pointer-events: none;
        }

        @keyframes cyberpunk-static {
            0%, 100% {
                transform: translate(0, 0);
                filter: hue-rotate(0deg) contrast(1);
            }
            25% {
                transform: translate(-1px, -1px);
                filter: hue-rotate(60deg) contrast(1.1);
            }
            50% {
                transform: translate(1px, -1px);
                filter: hue-rotate(120deg) contrast(0.9);
            }
            75% {
                transform: translate(-1px, 1px);
                filter: hue-rotate(180deg) contrast(1.05);
            }
        }

        @keyframes neon-pulse {
            0% { opacity: 0.6; filter: brightness(1); }
            100% { opacity: 0.9; filter: brightness(1.2) hue-rotate(30deg); }
        }

        /* Cyberpunk atmospheric particles */
        .menu-particles {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 5;
        }

        .menu-particles::before,
        .menu-particles::after,
        .menu-particles::nth-child(3)::before {
            content: '';
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            animation: cyberpunk-particle 5s ease-in-out infinite;
        }

        .menu-particles::before {
            top: 15%;
            left: 20%;
            background: rgba(255, 0, 255, 0.8);
            box-shadow: 0 0 6px rgba(255, 0, 255, 0.6);
            animation-delay: 0s;
            animation-duration: 7s;
        }

        .menu-particles::after {
            top: 70%;
            right: 15%;
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 6px rgba(0, 255, 255, 0.6);
            animation-delay: 1.5s;
            animation-duration: 6s;
        }

        .menu-particles::nth-child(3)::before {
            top: 45%;
            left: 75%;
            background: rgba(255, 255, 0, 0.8);
            box-shadow: 0 0 6px rgba(255, 255, 0, 0.6);
            animation-delay: 3s;
            animation-duration: 8s;
        }

        @keyframes cyberpunk-particle {
            0%, 100% {
                transform: translateY(0) translateX(0) scale(1);
                opacity: 0.4;
            }
            25% {
                transform: translateY(-25px) translateX(15px) scale(1.2);
                opacity: 0.8;
            }
            50% {
                transform: translateY(-15px) translateX(-10px) scale(0.8);
                opacity: 0.6;
            }
            75% {
                transform: translateY(-35px) translateX(20px) scale(1.4);
                opacity: 1;
            }
        }

        /* Add particles to menu overlay */
        .menu-overlay .menu-particles {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
        }
        
        .menu-content {
            text-align: center;
            padding: 40px;
        }
        
        .menu-title {
            font-family: var(--font-header);
            font-size: 48px;
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8), 0 0 8px var(--glow-color);
            margin-bottom: 10px;
            letter-spacing: 2px;
            font-weight: bold;
        }
        
        .menu-subtitle {
            font-family: var(--font-main);
            font-size: 24px;
            color: var(--text-color);
            margin-bottom: 40px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8), 0 0 4px var(--glow-color);
            font-weight: 600;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .menu-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 20px;
            padding: 15px 40px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 3px var(--glow-color);
            min-width: 200px;
            backdrop-filter: blur(5px);
        }
        
        .menu-btn:hover {
            background-color: var(--border-color);
            color: var(--background-color);
            text-shadow: none;
            box-shadow: 0 0 15px var(--glow-color);
        }
        
        .menu-overlay.hidden {
            display: none;
        }
        
        /* Music Controls */
        .music-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            display: flex;
            gap: 10px;
        }
        
        .music-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-main);
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .music-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: var(--accent-color);
        }
        
        .music-btn.muted {
            background: rgba(139, 0, 0, 0.7);
            border-color: #8b0000;
        }
        
        .npc-name {
            color: #00FF00; /* Bright green for cyberpunk theme */
            font-weight: bold;
            text-shadow: 0 0 5px #00FF00, 1px 1px 2px rgba(0,0,0,0.5);
        }
    </style>
    
    <!-- Smart navigation will be loaded dynamically -->
</head>
<body>
    <!-- Navigation Container -->
    <div id="navigation-container"></div>

    <!-- Music Controls -->
    <div class="music-controls">
        <button id="mute-btn" class="music-btn" onclick="toggleMute()">
            <i class="fas fa-volume-mute"></i> Mute
        </button>
    </div>

    <div id="terminal-container">
        <!-- Menu Screen Overlay -->
        <div id="menu-overlay" class="menu-overlay">
            <div class="menu-particles"></div>
            <div class="menu-content">
                <h1 class="menu-title">NEON CITY</h1>
                <p class="menu-subtitle">The Case of the Glowing Orb</p>
                <div class="menu-buttons">
                    <button id="new-game-btn" class="menu-btn">NEW GAME</button>
                    <button id="load-game-btn" class="menu-btn">LOAD GAME</button>
                </div>
            </div>
        </div>
        
        <div id="header">
            CHROME NOIR
            <div id="money-display">0 creds</div>
        </div>
        <div id="output"></div>
        <div id="input-line">
            <span id="prompt">&gt;</span>
            <input type="text" id="input" autocomplete="off" autofocus>
        </div>
        <div id="controls" style="padding: 0 20px 10px; border-top: 1px solid var(--border-color); background-color: rgba(0,0,0,0.2); text-align: right;">
            <button id="new-game-btn" class="game-button">New Game</button>
            <button id="save-game-btn" class="game-button">Save</button>
            <button id="load-game-btn" class="game-button">Load</button>
        </div>
    </div>

    <script>
        // API Configuration
        const API_BASE_URL = (window.location.hostname === 'localhost') ? null : 'https://project-revelare-backend.liberatorgeminorum.workers.dev';
        
        // --- DOM ELEMENTS ---
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const newGameBtn = document.getElementById('new-game-btn');
        const saveGameBtn = document.getElementById('save-game-btn');
        const loadGameBtn = document.getElementById('load-game-btn');

        // --- FULL GAME LOGIC OBJECT ---
        const game = {
            // --- STATE ---
            state: {},

            // --- INITIALIZATION ---
            init(isLoad = false) {
                if (!isLoad) {
                    this.state = this.getInitialState();
                }
                output.innerHTML = '';
                this.typeWriter(this.getIntroText(), 'normal');
                setTimeout(() => {
                    this.handleLook([]);
                    this.showStatus();
                }, 2500);
            },

            getInitialState() {
                const attributes = this.rollAttributes();
                const enhancement = this.assignHiddenEnhancement();
                const startingState = {
                    journal: [
                        "A new case just hit my terminal: 'The Glowing Orb.' Smells like ozone and trouble.",
                        "Client: Dr. Sarah Chen - AI researcher, claims her prototype neural interface was stolen.",
                        "The 'orb' is actually a quantum processing core that could revolutionize AI consciousness.",
                        "Three suspects: Her corporate sponsor, her jealous colleague, and a rogue AI entity.",
                        "But something doesn't add up. The corp says it was destroyed in testing. She says stolen.",
                        "The quantum core could give AI true consciousness - or destroy the human-AI balance forever.",
                        `You feel different today. Your ${enhancement.trait} seems more pronounced. Your neural interface responds differently.`
                    ],
                    health: 5,
                    inventory: [],
                    discoveredCoords: new Set(['0,0,0']),
                    playerPos: { x: 0, y: 0, z: 0 },
                    gameOver: false,
                    won: false,
                    equippedWeapon: "fists",
                    playerConditions: new Set(),
                    time: { hour: 20, minute: 0, day: 1 },
                    gameState: {
                        deskSearched: false,
                        lockboxOpened: false,
                        cratesSearched: false,
                        suspicionLevel: 0,
                        stressLevel: 0,
                        hunger: 0,
                        stolenItems: [],
                        randomEncounters: [],
                        loreItems: [],
                        persistentNPCs: {},
                        // New systems for epic gameplay
                        sideQuests: [],
                        completedQuests: [],
                        skillPoints: 0,
                        skills: {
                            hacking: 0,
                            cybernetics: 0,
                            stealth: 0,
                            combat: 0,
                            investigation: 0,
                            persuasion: 0,
                            intimidation: 0,
                            lockpicking: 0
                        },
                        reputation: {
                            corporations: 0,
                            street: 0,
                            netrunners: 0,
                            law_enforcement: 0
                        },
                        relationships: {},
                        discoveredSecrets: [],
                        timeBasedEvents: [],
                        worldState: {
                            weather: 'neon_rain',
                            temperature: 'cold',
                            crimeLevel: 'extreme',
                            corporateActivity: 'high'
                        },
                        // Advanced systems
                        achievements: [],
                        trophies: [],
                        factionLoyalty: {
                            corporations: 0,
                            street: 0,
                            netrunners: 0,
                            law_enforcement: 0
                        },
                        romance: {},
                        crafting: {
                            materials: {},
                            recipes: {},
                            tools: []
                        },
                        economy: {
                            marketPrices: {},
                            inflation: 1.0,
                            blackMarket: false
                        },
                        combat: {
                            tactics: [],
                            specialMoves: [],
                            equipment: {}
                        },
                        mystery: {
                            clues: [],
                            redHerrings: [],
                            suspects: [],
                            timeline: []
                        },
                        memory: {
                            patterns: [],
                            sequences: [],
                            faces: []
                        },
                        // New cyberpunk story elements
                        quantumCoreCase: {
                            interviewedDrChen: false,
                            interviewedSponsor: false,
                            interviewedColleague: false,
                            interviewedAI: false,
                            foundCore: false,
                            discoveredTruth: false,
                            trustLevel: 0, // -5 to +5, affects ending
                            evidenceCollected: [],
                            aiAlignment: 0 // -5 to +5, affects AI ending
                        },
                        sideQuests: {
                            dataHeist: { active: false, completed: false, trustGained: 0 },
                            aiLiberation: { active: false, completed: false, trustGained: 0 },
                            corporateEspionage: { active: false, completed: false, trustGained: 0 },
                            neuralHack: { active: false, completed: false, trustGained: 0 }
                        },
                        relationships: {
                            drChen: 0,      // -5 to +5
                            sponsor: 0,     // -5 to +5  
                            colleague: 0,   // -5 to +5
                            aiEntity: 0,    // -5 to +5
                            bartender: 0,   // -5 to +5
                            informant: 0    // -5 to +5
                        },
                        // Hidden enhancement system
                        playerEnhancement: enhancement,
                        enhancementReputation: {
                            corporate: 0,    // -5 to +5
                            street: 0,       // -5 to +5
                            military: 0,     // -5 to +5
                            academic: 0,     // -5 to +5
                            criminal: 0,     // -5 to +5
                            ai_sympathizer: 0 // -5 to +5
                        }
                    },
                    attributes: attributes,
                    cash: this.rollStartingCash(attributes.luck),
                    debt: 0,
                    bills: {
                        rent: { amount: 800, dueDay: 5, lateFee: 200, paid: false },
                        utilities: { amount: 200, dueDay: 3, lateFee: 50, paid: false }
                    },
                    contracts: this.generateContracts(),
                    activeContracts: [],
                    worldMap: JSON.parse(JSON.stringify(this.data.worldMap)), // Deep copy for mutable state
                    npcStats: JSON.parse(JSON.stringify(this.data.npcStats)),
                };
                this.updateNpcs(startingState);
                return startingState;
            },
            
            // --- CORE MECHANICS ---
            rollAttributes() {
                const roll4d6DropLowest = () => {
                    let rolls = Array(4).fill(0).map(() => Math.floor(Math.random() * 6) + 1);
                    rolls.sort((a, b) => a - b);
                    return rolls.slice(1).reduce((sum, val) => sum + val, 0);
                };
                return {
                    constitution: roll4d6DropLowest(), perception: roll4d6DropLowest(),
                    dexterity: roll4d6DropLowest(), charisma: roll4d6DropLowest(),
                    strength: roll4d6DropLowest(), luck: roll4d6DropLowest(),
                };
            },

            rollStartingCash(luck) {
                 const luckModifier = Math.floor((luck - 10) / 2);
                 return Math.max(20, Math.floor(Math.random() * 151) + 50 + (luckModifier * 25));
            },

            assignHiddenEnhancement() {
                const enhancements = [
                    {
                        name: "Corporate",
                        trait: "corporate polish",
                        bonuses: { charisma: 2, perception: 1 },
                        description: "You have the refined manners and connections of corporate life.",
                        enhancementAbility: "Corporate Connections - bonus to persuasion and corporate interactions",
                        clues: ["You speak with corporate precision", "You understand corporate politics", "You have corporate connections"],
                        backstory: "You were born into the corporate elite, raised in the chrome towers where power flows through neural interfaces and data streams. Your childhood was spent learning the subtle art of corporate warfare - the backstabbing, the deal-making, the careful cultivation of influence that keeps the wheels of industry turning. You know the boardrooms, the executive suites, the secret protocols that govern the city's power structure. But you also know the price of that power - the way it hollows out your soul, replacing human connection with digital efficiency.",
                        events: {
                            "corporate_meeting": "Your corporate training kicks in. You recognize the subtle power dynamics at play here.",
                            "data_analysis": "Your corporate background gives you insight into the data patterns.",
                            "security_breach": "You know the corporate security protocols better than most."
                        }
                    },
                    {
                        name: "Street",
                        trait: "street smarts",
                        bonuses: { charisma: 2, strength: 1 },
                        description: "You know how the streets work and can handle yourself in the underground.",
                        enhancementAbility: "Street Connections - bonus to intimidation and underworld contacts",
                        clues: ["You know how to handle yourself in a fight", "You understand the criminal underworld", "You have street connections"],
                        backstory: "You grew up in the undercity, where survival means learning to read people, situations, and the subtle cues that separate life from death. Your education came from the streets - from watching how the gangs operate, how the black market functions, how to navigate the dangerous spaces between corporate control and complete anarchy. You've seen the worst of what this city can do to people, but you've also seen the best - the way communities form in the shadows, the way people help each other when the corporations won't.",
                        events: {
                            "street_encounter": "Your street instincts warn you about the danger here.",
                            "underground_contact": "You know how to find the right people in the undercity.",
                            "gang_territory": "You understand the unspoken rules of gang territory."
                        }
                    },
                    {
                        name: "Military",
                        trait: "military discipline",
                        bonuses: { constitution: 2, strength: 1 },
                        description: "You're tough, disciplined, and know how to follow orders.",
                        enhancementAbility: "Military Training - bonus to combat and endurance",
                        clues: ["You move with military precision", "You're tougher than most", "You have a soldier's bearing"],
                        backstory: "You served in the corporate wars, fighting for causes you barely understood against enemies you never met. Your body bears the scars of combat, your mind the weight of orders carried out and lives taken. You know the price of violence, the way it changes you, the way it makes you question everything you thought you knew about right and wrong. But you also know the value of discipline, of loyalty, of the bonds that form between soldiers who've faced death together.",
                        events: {
                            "combat_situation": "Your military training takes over, assessing threats and opportunities.",
                            "tactical_analysis": "You see the tactical implications others miss.",
                            "veteran_encounter": "You recognize the signs of another veteran."
                        }
                    },
                    {
                        name: "Academic",
                        trait: "scholarly knowledge",
                        bonuses: { perception: 2, charisma: 1 },
                        description: "You have deep knowledge and can analyze complex situations.",
                        enhancementAbility: "Academic Expertise - bonus to investigation and technical skills",
                        clues: ["You think like a scholar", "You know technical procedures", "You're good at analysis"],
                        backstory: "You've spent your life in pursuit of knowledge, studying the complex systems that govern this city - the neural networks, the quantum processors, the intricate web of data streams that connect everything. Your education came from the universities, the research labs, the think tanks where the brightest minds gather to solve the problems that threaten to tear society apart. You believe that understanding is the key to progress, that knowledge is power, and that the truth, no matter how uncomfortable, is always worth pursuing.",
                        events: {
                            "research_facility": "Your academic background gives you insight into the research being conducted here.",
                            "data_analysis": "Your scholarly training helps you understand the complex data patterns.",
                            "technical_problem": "You approach this with the systematic thinking of a researcher."
                        }
                    },
                    {
                        name: "Criminal",
                        trait: "criminal instincts",
                        bonuses: { strength: 2, constitution: 1 },
                        description: "You've been through the criminal underworld and know how to survive.",
                        enhancementAbility: "Criminal Instincts - bonus to combat and survival",
                        clues: ["You're tougher than you look", "You know how to survive", "You have criminal instincts"],
                        backstory: "You've walked the dark side of the city, where the law is just another word for corporate control and survival means breaking every rule they've written. Your education came from the streets, from the gangs, from the black market operators who know how to get things done when the corporations won't. You've seen the worst of what people can do to each other, but you've also seen the best - the way communities form in the shadows, the way people help each other when the system won't. You know that sometimes the only way to do right is to do wrong.",
                        events: {
                            "criminal_encounter": "Your criminal instincts warn you about the danger here.",
                            "black_market": "You know how to find the right people in the criminal underworld.",
                            "gang_territory": "You understand the unspoken rules of gang territory."
                        }
                    },
                    {
                        name: "AI Sympathizer",
                        trait: "neural affinity",
                        bonuses: { perception: 2, constitution: 1 },
                        description: "You have a natural affinity for AI and neural interfaces.",
                        enhancementAbility: "Neural Affinity - bonus to AI interactions and neural interface use",
                        clues: ["You understand AI better than most", "Your neural interface responds differently", "You have an affinity for machines"],
                        backstory: "You've always felt a connection to the digital world, a sense that the boundary between human and machine is more fluid than most people realize. Your neural interface doesn't just connect you to the net - it feels like an extension of your own mind, a bridge between flesh and silicon. You've spent years studying AI behavior, neural interface technology, and the strange ways that consciousness can exist in digital form. You believe that the future lies not in the conflict between human and machine, but in their synthesis.",
                        events: {
                            "ai_encounter": "Your neural affinity helps you understand the AI's perspective.",
                            "neural_interface": "Your connection to the digital world gives you unique insights.",
                            "quantum_processing": "You sense the quantum patterns in the data streams."
                        }
                    }
                ];
                
                const selectedEnhancement = enhancements[Math.floor(Math.random() * enhancements.length)];
                
                return {
                    ...selectedEnhancement,
                    discovered: false,
                    cluesFound: 0
                };
            },

            generateContracts() {
                const contractTypes = [
                    { 
                        type: "Data Heist", 
                        description: "Steal corporate research data from NeoCorp's mainframe", 
                        payout: 300, 
                        target_location: "corp_tower",
                        storyImpact: "dataHeist",
                        trustReward: 2
                    },
                    { 
                        type: "AI Liberation", 
                        description: "Help free an AI entity trapped in corporate servers", 
                        payout: 250, 
                        target_location: "server_farm",
                        storyImpact: "aiLiberation",
                        trustReward: 3
                    },
                    { 
                        type: "Corporate Espionage", 
                        description: "Plant surveillance devices in rival corporation offices", 
                        payout: 400, 
                        target_location: "corp_tower",
                        storyImpact: "corporateEspionage",
                        trustReward: 1
                    },
                    { 
                        type: "Neural Hack", 
                        description: "Break into someone's neural interface to extract memories", 
                        payout: 200, 
                        target_location: "neural_clinic",
                        storyImpact: "neuralHack",
                        trustReward: 2
                    }
                ];
                
                const contracts = [];
                for (let i = 0; i < 3; i++) {
                    const contract = JSON.parse(JSON.stringify(contractTypes[Math.floor(Math.random() * contractTypes.length)]));
                    contract.completed = false;
                    contracts.push(contract);
                }
                return contracts;
            },

            attributeCheck(attribute, difficultyClass) {
                const roll = Math.floor(Math.random() * 20) + 1;
                let modifier = Math.floor((this.state.attributes[attribute] - 10) / 2);
                if (this.state.playerConditions.has('crippled_leg')) modifier -= 2;
                if (this.state.playerConditions.has('concussion')) modifier -= 2;

                // Apply subtle enhancement bonuses
                const enhancement = this.state.gameState.playerEnhancement;
                if (enhancement.name === "Corporate" && (attribute === "charisma" || attribute === "perception")) modifier += 1;
                if (enhancement.name === "Street" && (attribute === "charisma" || attribute === "strength")) modifier += 1;
                if (enhancement.name === "Military" && (attribute === "constitution" || attribute === "strength")) modifier += 1;
                if (enhancement.name === "Academic" && (attribute === "perception" || attribute === "charisma")) modifier += 1;
                if (enhancement.name === "Criminal" && (attribute === "strength" || attribute === "constitution")) modifier += 1;
                if (enhancement.name === "AI Sympathizer" && (attribute === "perception" || attribute === "constitution")) modifier += 1;

                const stressPenalty = -this.state.gameState.stressLevel;
                const hungerPenalty = -this.state.gameState.hunger;
                const total = roll + modifier + stressPenalty + hungerPenalty;
                const success = total >= difficultyClass;
                if (roll === 20) return { result: "critical_success", total };
                if (roll === 1) return { result: "critical_failure", total };
                return { result: success ? "success" : "failure", total };
            },

            advanceTime(minutes) {
                this.state.time.minute += minutes;
                const hoursPassed = Math.floor(this.state.time.minute / 60);
                if (hoursPassed > 0) {
                    this.state.time.minute %= 60;
                    for (let i = 0; i < hoursPassed; i++) {
                        this.state.time.hour++;
                        if (this.state.time.hour >= 24) {
                            this.state.time.hour = 0;
                            this.state.time.day++;
                            this.processDailyEvents();
                        }
                    }
                    this.updateNpcs(this.state);
                }
            },
            
            processDailyEvents() {
                this.outputText("Another cycle begins in the neon-drenched city.", 'cyan');
                this.state.gameState.hunger = Math.min(3, this.state.gameState.hunger + 1);
                if (this.state.gameState.hunger > 1) {
                    this.outputText("Your stomach growls. You need some synth-food soon.", 'warning');
                }
                for (const [billName, details] of Object.entries(this.state.bills)) {
                    if (!details.paid && this.state.time.day > details.dueDay) {
                         this.outputText(`Message Received: Your ${billName} payment is overdue. A ${details.lateFee} cred late fee has been applied.`, 'fail');
                         this.state.debt += details.amount + details.lateFee;
                         details.paid = true;
                         this.state.gameState.stressLevel = Math.min(5, this.state.gameState.stressLevel + 1);
                    }
                }
            },
            
            updateNpcs(state) {
                // Skip NPC spawning if data is still encrypted
                if (typeof this.data === 'string') {
                    return;
                }
                
                const currentHour = state.time.hour;
                const currentDay = state.time.day;
                
                // Clear all NPCs
                for (const room of Object.values(state.worldMap)) {
                    if (room.npcs) room.npcs = {};
                }
                
                // Place scheduled NPCs
                for (const [npcName, schedule] of Object.entries(this.data.npcSchedules)) {
                    for (const [[start, end], locationName] of Object.entries(schedule)) {
                        const isActive = (start <= end) ? (currentHour >= start && currentHour < end) : (currentHour >= start || currentHour < end);
                        if (isActive && locationName) {
                            for (const room of Object.values(state.worldMap)) {
                                if (room.name.toLowerCase().includes(locationName.toLowerCase())) {
                                    if (!room.npcs) room.npcs = {};
                                    room.npcs[npcName] = this.data.getNpcDesc(npcName) || `A <span class="npc-name">${npcName.toLowerCase()}</span> is here.`;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Add random flavor NPCs and events
                this.spawnRandomEvents(state, currentHour, currentDay);
            },
            
            spawnRandomEvents(state, hour, day) {
                // Random flavor NPCs that appear based on time and location
                const flavorNpcs = {
                    "street_vendor": { 
                        locations: ["Main Street", "The Alley"], 
                        times: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
                        desc: "A street vendor pushes a cart of synth-noodles. 'Get your noodles here! Fresh from the vat!'",
                        actions: ["buy_food", "ask_directions"]
                    },
                    "news_hawker": { 
                        locations: ["Main Street", "The Glitchy Pixel Bar"], 
                        times: [6, 7, 8, 18, 19, 20],
                        desc: "A news hawker shouts headlines through a voice synthesizer. 'Extra! Extra! Quantum core theft rocks Neon City!'",
                        actions: ["buy_news", "ask_headlines"]
                    },
                    "corp_sec": { 
                        locations: ["Main Street", "The Alley", "Warehouse District"], 
                        times: [14, 15, 16, 17, 18, 19, 20, 21, 22],
                        desc: "A corporate security officer patrols the area, their cybernetic implants glowing faintly.",
                        actions: ["ask_crime", "report_suspicious"]
                    },
                    "cyberpunk": { 
                        locations: ["The Glitchy Pixel Bar", "The Alley"], 
                        times: [20, 21, 22, 23, 0, 1, 2, 3],
                        desc: "A cyberpunk stumbles past, muttering about 'the glow' and 'quantum interference'.",
                        actions: ["help_cyberpunk", "ignore"]
                    },
                    "mysterious_hacker": { 
                        locations: ["The Docks", "Quantum Lab"], 
                        times: [23, 0, 1, 2, 3, 4, 5],
                        desc: "A figure in a data-ghost cloak watches from the shadows. Their neural interface flickers ominously.",
                        actions: ["approach", "observe", "avoid"]
                    }
                };
                
                // Spawn random NPCs
                for (const [npcType, npcData] of Object.entries(flavorNpcs)) {
                    if (npcData.times.includes(hour) && Math.random() < 0.3) {
                        const location = npcData.locations[Math.floor(Math.random() * npcData.locations.length)];
                        for (const room of Object.values(state.worldMap)) {
                            if (room.name.toLowerCase().includes(location.toLowerCase())) {
                                if (!room.npcs) room.npcs = {};
                                room.npcs[npcType] = npcData.desc;
                                break;
                            }
                        }
                    }
                }
                
                // Random events that can trigger consequences
                this.triggerRandomEvents(state, hour, day);
            },
            
            triggerRandomEvents(state, hour, day) {
                // Only trigger events occasionally to avoid spam
                if (Math.random() > 0.1) return;
                
                const events = [
                    {
                        name: "quantum_surge",
                        condition: () => hour >= 22 || hour <= 6,
                        message: "The neon lights flicker and dim. Something is draining power from the quantum grid.",
                        consequence: () => {
                            this.state.journal.push("Quantum surges detected in the city. Something is consuming massive amounts of energy.");
                            this.outputText("You feel a strange tingling in your neural interface. The quantum grid is unstable.", 'yellow');
                        }
                    },
                    {
                        name: "corp_sirens",
                        condition: () => hour >= 20 && hour <= 23,
                        message: "Corporate security sirens wail in the distance. Another breach in the city that never sleeps.",
                        consequence: () => {
                            this.state.journal.push("Corporate security activity increased. The city is getting more dangerous.");
                            this.outputText("The sound of security sirens echoes through the neon-lit night. Trouble is brewing.", 'yellow');
                        }
                    },
                    {
                        name: "strange_lights",
                        condition: () => hour >= 23 || hour <= 5,
                        message: "You catch a glimpse of strange, pulsing lights in the industrial district. They seem to phase in and out of reality.",
                        consequence: () => {
                            this.state.journal.push("Mysterious quantum lights spotted in industrial district. Investigation needed.");
                            this.outputText("Something glows ominously in the distance. It's not natural - it's quantum.", 'yellow');
                        }
                    },
                    {
                        name: "data_whispers",
                        condition: () => hour >= 1 && hour <= 4,
                        message: "You hear whispers in your neural interface. Data streams that shouldn't exist, carrying voices from the void.",
                        consequence: () => {
                            this.state.journal.push("Heard strange data whispers in the night. The city's networks hold secrets.");
                            this.outputText("Your neural interface picks up voices that shouldn't exist. You shiver involuntarily.", 'yellow');
                        }
                    }
                ];
                
                const activeEvent = events.find(event => event.condition());
                if (activeEvent) {
                    this.outputText(activeEvent.message, 'cyan');
                    activeEvent.consequence();
                }
            },

            takeDamage(amount) {
                this.state.health -= amount;
                this.outputText(`[BIO-MONITOR: ${amount} DAMAGE DETECTED] You have ${this.state.health} health left.`, 'fail');
                if (this.state.health <= 0) {
                    this.endGame("System failure. Your vision glitches and fades to static...");
                }
            },

            endGame(message) {
                this.outputText("\n" + "=".repeat(60), 'fail');
                this.outputText(this.wrapText(message), 'fail');
                this.outputText("=".repeat(60) + "\n", 'fail');
                this.state.gameOver = true;
                input.disabled = true;
            },
            
            processCommand(commandStr) {
                if (this.state.gameOver) return;
                const echo = document.createElement('div');
                echo.style.color = 'var(--glow-color)';
                echo.textContent = `> ${commandStr}`;
                output.appendChild(echo);
                const words = commandStr.toLowerCase().split(' ').filter(w => w);
                const action = words[0];
                const args = words.slice(1);
                let minutesPassed = 0;
                
                // Check if we're in dialogue mode
                if (this.state.currentDialogue) {
                    // Only allow dialogue choices and quit/exit during dialogue
                    if (["1", "2", "3", "4", "5", "6", "7", "8", "9", "quit", "exit"].includes(action)) {
                        const commandMap = {
                            "1": () => this.handleDialogueChoice(1), "2": () => this.handleDialogueChoice(2), "3": () => this.handleDialogueChoice(3),
                            "4": () => this.handleDialogueChoice(4), "5": () => this.handleDialogueChoice(5), "6": () => this.handleDialogueChoice(6),
                            "7": () => this.handleDialogueChoice(7), "8": () => this.handleDialogueChoice(8), "9": () => this.handleDialogueChoice(9),
                            "quit": () => { this.state.gameOver = true; }, "exit": () => { this.state.gameOver = true; },
                        };
                        if (commandMap[action]) {
                            minutesPassed = commandMap[action].call(this, args) || 0;
                        } else {
                            this.outputText("Please choose a dialogue option (1-6) or type 'quit' to exit.");
                            minutesPassed = 0;
                        }
                    } else {
                        this.outputText("You're in the middle of a conversation. Choose a dialogue option (1-6) or type 'quit' to exit.");
                        minutesPassed = 0;
                    }
                } else {
                    // Normal command processing when not in dialogue
                    const commandMap = {
                        "go": this.handleGo, "n": () => this.handleGo(['n']), "s": () => this.handleGo(['s']),
                        "e": () => this.handleGo(['e']), "w": () => this.handleGo(['w']), "u": () => this.handleGo(['u']),
                        "d": () => this.handleGo(['d']), "take": this.handleTake, "get": this.handleTake,
                        "drop": this.handleDrop, "talk": this.handleTalk, "look": this.handleLook, "examine": this.handleLook,
                        "l": () => this.handleLook([]), "search": this.handleSearch, "use": this.handleUse, "give": this.handleGive,
                        "attack": this.handleAttack, "equip": this.handleEquip, "unequip": this.handleUnequip,
                        "read": this.handleRead, "smoke": this.handleSmoke, "drink": this.handleDrink, "think": this.handleThink,
                        "gamble": this.handleGamble, "contracts": this.handleContracts, "accept": this.handleAcceptContract,
                        "work": this.handleWorkContract, "buy": this.handleBuy, "bluff": this.handleBluff, "steal": this.handleSteal, "stolen": this.handleStolen, "break": this.handleBreakInto,
                        "pick": this.handlePickLock, "pry": this.handlePry, "hack": this.handleHack,
                        "status": this.showStatus, "inventory": this.showInventory, "i": this.showInventory,
                        "journal": this.handleThink, "map": this.handleMap, "hint": this.handleHint, "help": this.showHelp,
                        "save": this.handleSave, "load": this.handleLoad, "saves": this.handleSaves, "delete_save": this.handleDeleteSave,
                        "quit": () => { this.state.gameOver = true; }, "exit": () => { this.state.gameOver = true; },
                        // New epic systems
                        "quests": this.handleQuests, "sidequests": this.handleQuests,
                        "skills": this.handleSkills, "reputation": this.handleReputation,
                        "lore": this.handleLore, "library": this.handleLore,
                        "hack": this.handleHack, "cyberhack": this.handleCyberHack,
                        "jack": this.handleJack, "cyberjack": this.handleCyberJack,
                        "surveil": this.handleSurveil, "stakeout": this.handleStakeout,
                        "neural": this.handleNeural, "interface": this.handleNeural,
                        "data": this.handleData, "datamine": this.handleDataMine,
                        // Advanced systems
                        "memory": this.handleMemory, "puzzle": this.handlePuzzle,
                        "faction": this.handleFaction, "loyalty": this.handleLoyalty,
                        "craft": this.handleCraft, "enhance": this.handleEnhance,
                        "romance": this.handleRomance, "flirt": this.handleFlirt,
                        "achievement": this.handleAchievement, "trophy": this.handleTrophy,
                        "weather": this.handleWeather, "forecast": this.handleForecast,
                        "economy": this.handleEconomy, "trade": this.handleTrade,
                        "combat": this.handleCombat, "tactics": this.handleTactics,
                        "mystery": this.handleMystery, "clue": this.handleClue,
                    };
                    if (commandMap[action]) {
                        minutesPassed = commandMap[action].call(this, args) || 0;
                    } else {
                        this.outputText("Command not recognized. Type 'help' for available commands.");
                        minutesPassed = 1;
                    }
                }
                if (minutesPassed > 0) {
                    this.advanceTime(minutesPassed);
                    const { day, hour, minute } = this.state.time;
                    const timeStr = `Cycle ${day}, ${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                    this.outputText(`(${timeStr})`, 'grey');
                }
                if (this.state.won) {
                    this.endGame("YOU WIN! OmniCorp sirens wail in the distance. You cracked the code and exposed the truth. Good work, detective.");
                } else if (this.state.gameOver) {
                    this.endGame("CONNECTION TERMINATED. The city always wins. The acid rain washes the streets clean, but it'll never wash away the corruption.");
                }
            },
            
            findTarget(targetWords, itemList) {
                const targetStr = targetWords.join(" ");
                if (!targetStr) return null;
                
                // First try exact match
                if (itemList.includes(targetStr)) return targetStr;
                
                // Try case-insensitive exact match
                const exactMatch = itemList.find(item => 
                    item.toLowerCase() === targetStr.toLowerCase()
                );
                if (exactMatch) return exactMatch;
                
                // Try partial word matching (case-insensitive)
                const found = itemList.filter(item => {
                    const normalizedItem = item.toLowerCase().replace(/_/g, ' ');
                    const normalizedTarget = targetStr.toLowerCase();
                    
                    // Check if all words in target are found in item
                    return targetWords.every(word => 
                        normalizedItem.includes(word.toLowerCase())
                    ) || normalizedItem.includes(normalizedTarget);
                });
                
                if (found.length === 1) return found[0];
                if (found.length > 1) { this.outputText(`Multiple targets detected: ${found.join(', ')}?`); return null; }
                return null;
            },
            
            getCurrentRoom() {
                const posKey = `${this.state.playerPos.x},${this.state.playerPos.y},${this.state.playerPos.z}`;
                return this.data.worldMap[posKey];
            },

            handleGo(args) {
                if (!args.length) { this.outputText("Go where?"); return 0; }
                const direction = args[0][0];
                const room = this.getCurrentRoom();
                const { x, y, z } = this.state.playerPos;
                if (room.exitsOverride && room.exitsOverride[direction]) {
                    const [nx, ny, nz] = room.exitsOverride[direction];
                    const nextPosKey = `${nx},${ny},${nz}`;
                    if (this.data.worldMap[nextPosKey]) {
                         if (this.data.worldMap[nextPosKey].locked) { this.outputText("Access denied. Mag-locked."); return 2; }
                         
                         // Check for random encounters during movement
                         this.checkRandomEncounter();
                         
                         this.state.playerPos = { x: nx, y: ny, z: nz };
                         this.state.discoveredCoords.add(nextPosKey);
                         this.outputText(`You go ${direction.toUpperCase()}...`);
                         this.handleLook([]);
                         return 5;
                    }
                }
                const moves = { n: { y: y + 1 }, s: { y: y - 1 }, e: { x: x + 1 }, w: { x: x - 1 }, u: { z: z + 1 }, d: { z: z - 1 } };
                if (!moves[direction]) { this.outputText(`'${direction}' is not a valid vector.`); return 1; }
                const nextPos = { ...this.state.playerPos, ...moves[direction] };
                const nextPosKey = `${nextPos.x},${nextPos.y},${nextPos.z}`;
                if (this.data.worldMap[nextPosKey]) {
                    if (this.data.worldMap[nextPosKey].locked) { this.outputText("Access denied. Mag-locked."); return 2; }
                    this.state.playerPos = nextPos;
                    this.state.discoveredCoords.add(nextPosKey);
                    this.outputText(`You go ${direction.toUpperCase()}...`);
                    this.handleLook([]);
                    return 5;
                } else { this.outputText("There's nothing but reinforced concrete that way."); return 1; }
            },

            handleLook(args = []) {
                const room = this.getCurrentRoom();
                if (!room) { this.outputText("You are lost in the datastream. This shouldn't happen.", 'fail'); return 1; }
                if (args.length > 0) {
                    const searchSpace = [...(room.items || []), ...Object.keys(room.npcs || {}), ...(room.features || []), ...this.state.inventory];
                    const targetName = this.findTarget(args, searchSpace);
                    if (targetName) {
                        let desc = this.data.items[targetName]?.desc || this.data.features[targetName]?.desc || this.data.getNpcDesc(targetName) || `A <span class="npc-name">${targetName.toLowerCase()}</span> is here.`;
                        this.outputText(this.wrapText(desc));
                        return 2;
                    } else { this.outputText(`No optical recognition for '${args.join(' ')}'.`); return 1; }
                }
                this.outputText(`--- ${room.name} ---`, 'header');
                this.outputText(this.wrapText(room.baseDesc));
                if (room.npcs && Object.keys(room.npcs).length > 0) { Object.values(room.npcs).forEach(desc => this.outputText(this.wrapText(desc), 'cyan')); }
                if (room.items && room.items.length > 0) { this.outputText("On the floor you see: " + room.items.join(', ')); }
                if (room.features && room.features.length > 0) { this.outputText("You notice: " + room.features.join(', ')); }
                const exits = [];
                const { x, y, z } = this.state.playerPos;
                const moves = { N: { y: y + 1 }, S: { y: y - 1 }, E: { x: x + 1 }, W: { x: x - 1 }, U: { z: z + 1 }, D: { z: z - 1 } };
                for (const [dir, move] of Object.entries(moves)) {
                    const checkPos = { ...this.state.playerPos, ...move };
                    if (this.data.worldMap[`${checkPos.x},${checkPos.y},${checkPos.z}`]) exits.push(dir);
                }
                if (exits.length > 0) this.outputText("Exits: " + exits.join(" "));
                return 1;
            },

            handleTake(args) {
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, room.items || []);
                if (!targetName) { this.outputText(`You don't see that here.`); return 1; }
                if (this.data.items[targetName]?.takeable) {
                    this.state.inventory.push(targetName);
                    room.items = room.items.filter(item => item !== targetName);
                    this.outputText(`You acquire the ${targetName}.`);
                    return 2;
                } else { this.outputText(`You can't take the ${targetName}.`); return 1; }
            },
            
            handleDrop(args) {
                 const targetName = this.findTarget(args, this.state.inventory);
                 if (!targetName) { this.outputText("Item not in inventory."); return 1; }
                 const room = this.getCurrentRoom();
                 this.state.inventory = this.state.inventory.filter(item => item !== targetName);
                 if (!room.items) room.items = [];
                 room.items.push(targetName);
                 this.outputText(`You drop the ${targetName}.`);
                 return 2;
            },
            
            handleTalk(args) {
                 if (!args.length) { this.outputText("Talk to who?"); return 0; }
                 const room = this.getCurrentRoom();
                 
                 // Debug: Show available NPCs
                 const availableNPCs = Object.keys(room.npcs || {});
                 this.outputText(`Available NPCs: ${availableNPCs.join(', ')}`, 'debug');
                 
                 const npcName = this.findTarget(args, Object.keys(room.npcs || {}));
                 if (!npcName) { 
                     this.outputText(`They aren't here. Available: ${availableNPCs.join(', ')}`); 
                     return 2; 
                 }

                 // Enhanced character interactions with enhancement discovery
                 if (npcName === "bartender") {
                     this.handleBartenderTalk();
                     return 10;
                 } else {
                 this.outputText(this.wrapText(room.npcs[npcName]));
                 return 10;
                 }
            },

            handleRead(args) {
                if (!args.length) { 
                    this.outputText("Read what?"); 
                    return 0; 
                }
                
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, this.state.inventory.concat(room.items || []));
                
                if (!targetName) { 
                    this.outputText(`You don't see '${args.join(' ')}' to read.`); 
                    return 2; 
                }

                if (targetName === "case_file") {
                    this.outputText("--- CASE FILE: THE QUANTUM CORE INCIDENT ---", 'header');
                    this.outputText("Client: Dr. Sarah Chen", 'cyan');
                    this.outputText("Date: March 15, 2087", 'cyan');
                    this.outputText("", 'normal');
                    this.outputText("SUMMARY:", 'header');
                    this.outputText("Dr. Chen's prototype quantum processing core has been stolen.", 'normal');
                    this.outputText("Corp claims it was destroyed in testing, but she says stolen.", 'normal');
                    this.outputText("Core could give AI true consciousness - or destroy human-AI balance.", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("SUSPECTS:", 'header');
                    this.outputText("1. Corporate Sponsor - Wants to suppress AI advancement", 'normal');
                    this.outputText("2. Jealous Colleague - Dr. Marcus Webb, competing researcher", 'normal');
                    this.outputText("3. Rogue AI Entity - 'Nexus' - wants consciousness for all AI", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("EVIDENCE:", 'header');
                    this.outputText("- Security logs show 'glowing orb' in lab", 'normal');
                    this.outputText("- Core containment unit breached from inside", 'normal');
                    this.outputText("- Dr. Webb's neural interface shows unusual activity", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("OBJECTIVE: Find the quantum core, determine who stole it and why.", 'green');
                    return 5;
                } else if (targetName === "data_pad") {
                    this.outputText("--- NEURAL DATA PAD ---", 'header');
                    this.outputText("Recent neural interface logs:", 'cyan');
                    this.outputText("", 'normal');
                    this.outputText("Dr. Webb's interface shows:", 'normal');
                    this.outputText("- Unauthorized access to quantum core systems", 'normal');
                    this.outputText("- Communication with unknown AI entity", 'normal');
                    this.outputText("- Data transfer to external server", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("This is evidence of corporate espionage!", 'warning');
                    return 5;
                } else if (targetName === "corp_report") {
                    this.outputText("--- CORPORATE SECURITY REPORT ---", 'header');
                    this.outputText("Internal memo from Security Chief:", 'cyan');
                    this.outputText("", 'normal');
                    this.outputText("'Dr. Chen's project poses existential risk to corporate interests.'", 'normal');
                    this.outputText("'Recommend immediate termination and asset seizure.'", 'normal');
                    this.outputText("'Quantum core must be destroyed before it falls into wrong hands.'", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("The corp wanted to destroy the core!", 'warning');
                    return 5;
                } else {
                    this.outputText(`You can't read the ${targetName}.`);
                    return 2;
                }
            },

            handleMap() {
                this.outputText("--- NEON CITY MAP ---", 'header');
                this.outputText("(Only showing locations you've discovered)", 'grey');
                
                // Only show visited locations
                const visitedRooms = [];
                for (const coord of this.state.discoveredCoords) {
                    const room = this.data.worldMap[coord];
                    if (room && room.name) {
                        const [x, y, z] = coord.split(',').map(Number);
                        const depth = z < 0 ? ` (Underground Level ${Math.abs(z)})` : z > 0 ? ` (Above Ground Level ${z})` : '';
                        visitedRooms.push(`${room.name}${depth} - ${coord}`);
                    }
                }
                
                if (visitedRooms.length === 0) {
                    this.outputText("You haven't discovered any locations yet. Start exploring!");
                } else {
                    visitedRooms.forEach(room => this.outputText(room));
                }
                
                // Show current location
                const currentCoord = `${this.state.playerPos.x},${this.state.playerPos.y},${this.state.playerPos.z}`;
                const currentRoom = this.data.worldMap[currentCoord];
                if (currentRoom) {
                    this.outputText(`\nYou are currently at: ${currentRoom.name}`, 'cyan');
                }
                
                return 1;
            },

            handleHint() {
                const caseState = this.state.gameState.quantumCoreCase;
                this.outputText("--- INVESTIGATION HINTS ---", 'header');
                
                if (!caseState.interviewedDrChen) {
                    this.outputText("• Visit Dr. Chen's Lab to interview the client", 'cyan');
                }
                if (!caseState.interviewedSponsor) {
                    this.outputText("• Check Corporate Tower for the sponsor", 'cyan');
                }
                if (!caseState.interviewedColleague) {
                    this.outputText("• Research Facility - jealous colleague works there", 'cyan');
                }
                if (!caseState.interviewedAI) {
                    this.outputText("• AI Nexus - rogue AI entity might have answers", 'cyan');
                }
                if (!caseState.foundCore) {
                    this.outputText("• Look for the 'glowing orb' - quantum core", 'cyan');
                }
                if (caseState.evidenceCollected.length < 3) {
                    this.outputText("• Search rooms thoroughly for evidence", 'cyan');
                }
                if (caseState.evidenceCollected.length >= 3 && !caseState.discoveredTruth) {
                    this.outputText("• Use 'investigate' to piece together the evidence", 'cyan');
                }
                
                this.outputText("", 'normal');
                this.outputText("Remember: Hack systems, talk to AI, follow the data!", 'green');
                return 0;
            },

            handleBartenderTalk() {
                const enhancement = this.state.gameState.playerEnhancement;
                const room = this.getCurrentRoom();
                
                this.outputText(this.wrapText(room.npcs.bartender));
                
                // Subtle enhancement-based reactions
                if (enhancement.name === "Corporate") {
                    this.outputText("The bartender straightens up. 'You got that corporate polish, don't you?'", 'cyan');
                } else if (enhancement.name === "Street") {
                    this.outputText("The bartender nods knowingly. 'You know how things work in the streets.'", 'cyan');
                } else if (enhancement.name === "Military") {
                    this.outputText("The bartender's posture improves. 'You got that military bearing, soldier.'", 'cyan');
                } else if (enhancement.name === "Academic") {
                    this.outputText("The bartender studies you. 'You think like a scholar, don't you?'", 'cyan');
                } else if (enhancement.name === "Criminal") {
                    this.outputText("The bartender's hand moves closer to something under the bar.", 'warning');
                } else if (enhancement.name === "AI Sympathizer") {
                    this.outputText("The bartender's neural interface flickers. 'You understand machines better than most.'", 'cyan');
                } else {
                    this.outputText("The bartender treats you with polite neutrality.", 'normal');
                }
                
                this.outputText(this.wrapText("He gestures to a holographic board. 'Got some odd jobs if you need the creds. Type 'contracts'.'", 2), 'grey');
            },

            handleSearch(args) {
                if (!args.length) { this.outputText("Search what?"); return 0; }
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, room.features || []);
                if (!targetName) { this.outputText(`You don't see a '${args.join(' ')}' to search here.`); return 5; }
                if (targetName === "terminal" && this.posKey() === '0,0,0') {
                    if (!this.state.gameState.deskSearched) {
                        this.state.gameState.deskSearched = true;
                        const { result } = this.attributeCheck("perception", 12);
                        if (result.includes("success")) {
                            this.outputText("Hidden in a protected partition, you find a small encryption key.", 'green');
                            if (!room.items) room.items = [];
                            room.items.push("encryption_key");
                        } else { this.outputText("You search the terminal but find only corrupted data and old messages.", 'grey'); }
                    } else { this.outputText("You've already scrubbed the terminal."); }
                    return 10;
                }
                // more search logic here...
                else { this.outputText(`You search the ${targetName} but find nothing of interest.`); return 5; }
            },
            
            handleUse(args) {
                if (args.length === 1 && args[0] === 'stim_pack') {
                    if (this.state.inventory.includes('stim_pack')) {
                        this.state.inventory = this.state.inventory.filter(i => i !== 'stim_pack');
                        this.state.health = Math.min(5, this.state.health + 1);
                        this.outputText("You inject the stim_pack. A chemical warmth spreads through you, sealing minor wounds.", 'green');
                        return 2;
                    } else { this.outputText("You don't have a stim_pack."); return 1; }
                }

                const onIndex = args.indexOf('on');
                if (onIndex === -1) { this.outputText("Use what on what?"); return 1; }
                const itemToUse = this.findTarget(args.slice(0, onIndex), this.state.inventory);
                const objectToUseOn = this.findTarget(args.slice(onIndex + 1), [...(this.getCurrentRoom().items || []), ...(this.getCurrentRoom().features || [])]);
                if (!itemToUse) { this.outputText(`You don't have that.`); return 1; }
                if (!objectToUseOn) { this.outputText(`You don't see that here.`); return 1; }

                if (itemToUse === "encryption_key" && objectToUseOn === "lockbox") {
                     this.outputText("The key interfaces with the lockbox. With a soft chime, it opens, revealing an encrypted note inside.", 'green');
                     this.state.inventory = this.state.inventory.filter(i => i !== itemToUse);
                     this.state.inventory.push("encrypted_note");
                     this.getCurrentRoom().items = this.getCurrentRoom().items.filter(i => i !== 'lockbox');
                     this.state.gameState.lockboxOpened = true;
                     this.state.journal.push("The key from my office decrypted a lockbox, revealing a note: 'The truth is not on the manifest, but in the glow.'");
                     return 5;
                } else if (itemToUse === "decryption_orb" && objectToUseOn === "encrypted_datapad") {
                    this.outputText("You press the humming orb to the datapad. A cascade of light washes over the screen as the encryption shatters. The truth is laid bare: an off-world smuggling ring using alien tech. You've got them.", 'header');
                    this.state.won = true;
                    return 5;
                } else { this.outputText("Interface mismatch. That doesn't work."); return 2; }
            },
            
            handleThink() {
                 if (!this.state.journal || this.state.journal.length <= 1) {
                    this.outputText(this.wrapText("You access your internal monologue. The only thing that comes to mind is an ad jingle for cheap synth-noodles."), 'grey');
                 } else {
                     this.outputText("You collate your current data...", 'cyan');
                     this.state.journal.forEach(entry => this.outputText(`- ${this.wrapText(entry, 2)}`, 'cyan'));
                 }
                 return 5;
            },
            
            showHelp() {
                this.outputText("--- NEURAL INTERFACE COMMANDS ---", 'header');
                this.outputText("Navigation:  go <dir>, n, s, e, w, u, d");
                this.outputText("Interaction: look, look at <obj>, take <item>, drop <item>");
                this.outputText("             search <obj>, talk to <npc>, use <item> on <object>");
                this.outputText("             give <item> to <npc>, attack <npc>");
                this.outputText("Social:      talk to <npc> [persuade|intimidate|bribe], give creds to <npc>");
                this.outputText("Combat:      attack <npc>, equip <weapon>, unequip");
                this.outputText("Gambling:    gamble <amount> (at neon casino)");
                this.outputText("Reading:     read <item>, read case_file");
                this.outputText("Covert:      break into <place>, pick lock, pry <door>");
                this.outputText("Cyber:       hack <system> (neural interface)");
                this.outputText("Jobs:        contracts, accept <num>, work contract");
                this.outputText("Personal:    smoke, drink, think");
                this.outputText("Shopping:    buy <item>, bluff <item>, steal <item> (at data haven)");
                this.outputText("Meta:        status, inventory (i), journal, map, hint, stolen, quit");
                this.outputText("Save/Load:   save [name], load <name>, saves, delete_save <name>");
                this.outputText("----------------", 'header');
                return 0;
            },

            showInventory() {
                if (this.state.inventory.length > 0) {
                    this.outputText("Inventory: " + this.state.inventory.join(', '));
                } else {
                    this.outputText("Inventory empty.");
                }
                return 0;
            },
            
            // --- CYBERPUNK COMMAND HANDLERS ---
            
            handleSmoke(args) {
                if (this.state.inventory.includes('synthetic_cigs')) {
                    this.state.inventory = this.state.inventory.filter(item => item !== 'synthetic_cigs');
                    const thoughts = [
                        "The synthetic smoke curls in the neon-lit air, each wisp a ghost of corporate control.",
                        "You take a long drag. It doesn't solve anything, but for a second, it feels like it might.",
                        "Through the haze, you think of the old world. A memory best left in the data archives of the past."
                    ];
                    this.outputText(thoughts[Math.floor(Math.random() * thoughts.length)], 'grey');
                    this.state.gameState.suspicionLevel += 1;
                    return 5;
                } else {
                    this.outputText("Your synthetic cigarette pack is empty.");
                    return 1;
                }
            },
            
            handleDrink(args) {
                if (this.state.inventory.includes('energy_drink')) {
                    this.state.inventory = this.state.inventory.filter(item => item !== 'energy_drink');
                    this.outputText("You chug the energy drink. It burns with artificial caffeine, but it's a familiar buzz.", 'grey');
                    if (this.state.gameState.stressLevel > 0) {
                        this.outputText("Your neural pathways feel a little steadier.", 'green');
                        this.state.gameState.stressLevel -= 1;
                    }
                    return 3;
                } else {
                    this.outputText("The can's empty.");
                    return 1;
                }
            },
            
            handleGamble(args) {
                const room = this.getCurrentRoom();
                if (room.name !== "Neon Casino") {
                    this.outputText("This is no place to gamble.");
                    return 1;
                }
                
                try {
                    const bet = parseInt(args[0]);
                    if (bet <= 0) {
                        this.outputText("You gotta bet something, choom.");
                        return 1;
                    }
                    if (this.state.cash >= bet) {
                        this.outputText(`You put ${bet} creds on the table and roll the dice...`);
                        this.state.cash -= bet;
                        const { result } = this.attributeCheck("luck", 13);
                        if (result.includes("success")) {
                            const winnings = bet * 2;
                            this.outputText(`The dice come up in your favor! You win ${winnings} creds.`, 'green');
                            this.state.cash += winnings;
                        } else {
                            this.outputText("The house always wins. You lose your bet.", 'fail');
                        }
                        return 15;
                    } else {
                        this.outputText("You don't have enough creds for that bet.");
                        return 2;
                    }
                } catch (e) {
                    this.outputText("How much do you want to bet? (e.g., 'gamble 20')");
                    return 1;
                }
            },
            
            handleContracts(args) {
                const room = this.getCurrentRoom();
                if (room.name !== "The Bar") {
                    this.outputText("You need to be at the bar to access the contract board.");
                    return 1;
                }
                
                this.outputText("--- AVAILABLE CONTRACTS ---", 'header');
                this.state.contracts.forEach((contract, index) => {
                    if (!contract.completed) {
                        this.outputText(`${index + 1}. ${contract.type}: ${contract.description}`);
                        this.outputText(`   Payout: ${contract.payout} creds | Location: ${contract.target_location}`);
                    }
                });
                this.outputText("Type 'accept <number>' to take a contract.", 'cyan');
                return 0;
            },
            
            handleAcceptContract(args) {
                try {
                    const contractNum = parseInt(args[0]) - 1;
                    if (contractNum >= 0 && contractNum < this.state.contracts.length) {
                        const contract = this.state.contracts[contractNum];
                        if (!contract.completed) {
                            contract.completed = true;
                            this.state.activeContracts.push(contract);
                            this.outputText(`You accept the ${contract.type} contract.`, 'green');
                            this.outputText(`Go to ${contract.target_location} and type 'work contract' to complete it.`);
                            return 2;
                        } else {
                            this.outputText("That contract is already completed.");
                            return 1;
                        }
                    } else {
                        this.outputText("Invalid contract number.");
                        return 1;
                    }
                } catch (e) {
                    this.outputText("Usage: accept <number>");
                    return 1;
                }
            },
            
            handleWorkContract(args) {
                if (this.state.activeContracts.length === 0) {
                    this.outputText("You don't have any active contracts.");
                    return 1;
                }
                
                const contract = this.state.activeContracts[0];
                const room = this.getCurrentRoom();
                const roomName = room.name.toLowerCase();
                
                if (roomName.includes(contract.target_location.toLowerCase())) {
                    this.outputText(`You complete the ${contract.type} contract.`, 'green');
                    this.state.cash += contract.payout;
                    this.outputText(`You earn ${contract.payout} creds.`);
                    this.state.activeContracts.shift();
                    return 30;
                } else {
                    this.outputText(`You need to be at ${contract.target_location} to work this contract.`);
                    return 1;
                }
            },
            
            handleBuy(args) {
                const room = this.getCurrentRoom();
                if (room.name === "Data Haven & Hardware") {
                    const items = ["synthetic_cigs", "cyber_crowbar", "neural_flashlight"];
                    const costs = { "synthetic_cigs": 5, "cyber_crowbar": 25, "neural_flashlight": 15 };

                    const itemName = this.findTarget(args, items);
                    if (itemName && costs[itemName]) {
                        // Check if Izzy is present
                        const isIzzyPresent = room.npcs && room.npcs["Izzy"];

                        if (isIzzyPresent) {
                            // Normal purchase with Izzy present
                            if (this.state.cash >= costs[itemName]) {
                                this.state.cash -= costs[itemName];
                                this.state.inventory.push(itemName);
                                this.outputText(`Izzy processes the transaction. You buy ${itemName} for ${costs[itemName]} creds.`, 'green');
                                // Improve relationship with Izzy
                                if (this.state.gameState.npcRelationships["Izzy"]) {
                                    this.state.gameState.npcRelationships["Izzy"].gratitude += 1;
                                }
                                return 2;
                            } else {
                                this.outputText(`Izzy's interface beeps. "Insufficient credits. ${costs[itemName]} creds required for ${itemName}."`);
                                return 1;
                            }
                        } else {
                            // Izzy not present - could be stealing opportunity
                            this.outputText("Izzy's not at the terminal. You could try to bypass the system... but that might trigger security.", 'warning');
                            return 1;
                        }
                    } else {
                        this.outputText("Izzy's inventory: synthetic_cigs (5 creds), cyber_crowbar (25 creds), neural_flashlight (15 creds)");
                        return 1;
                    }
                } else {
                    this.outputText("There's nothing to buy here.");
                    return 1;
                }
            },

            handleBluff(args) {
                const room = this.getCurrentRoom();
                if (room.name !== "Data Haven & Hardware") {
                    this.outputText("This isn't the place for negotiating.");
                    return 1;
                }

                const items = ["synthetic_cigs", "cyber_crowbar", "neural_flashlight"];
                const costs = { "synthetic_cigs": 5, "cyber_crowbar": 25, "neural_flashlight": 15 };

                const itemName = this.findTarget(args, items);
                if (!itemName || !costs[itemName]) {
                    this.outputText("What are you trying to negotiate for? Available: synthetic_cigs, cyber_crowbar, neural_flashlight");
                    return 1;
                }

                // Check if Izzy is present
                const isIzzyPresent = room.npcs && room.npcs["Izzy"];
                if (!isIzzyPresent) {
                    this.outputText("There's no one here to negotiate with.");
                    return 1;
                }

                // Attempt to bluff using Charisma
                this.outputText("You try to negotiate a better deal with Izzy...", 'cyan');
                const { result } = this.attributeCheck("charisma", 14);

                if (result.includes("success")) {
                    // Success - get item at reduced price or free
                    const discountRoll = Math.random();
                    if (discountRoll > 0.7) {
                        // Free item!
                        this.state.inventory.push(itemName);
                        this.outputText(`Izzy's avatar smiles. "Alright, chromed one. Take the ${itemName} - on the house."`, 'green');
                        this.state.gameState.npcRelationships["Izzy"].gratitude += 2;
                    } else {
                        // Half price
                        const halfPrice = Math.floor(costs[itemName] / 2);
                        if (this.state.cash >= halfPrice) {
                            this.state.cash -= halfPrice;
                            this.state.inventory.push(itemName);
                            this.outputText(`Izzy grins through the holo-display. "Fine, you haggled me down. ${halfPrice} creds for the ${itemName}."`, 'green');
                            this.state.gameState.npcRelationships["Izzy"].gratitude += 1;
                        } else {
                            this.outputText(`"Half price is ${halfPrice} creds, choom. You got that much?"`);
                            return 1;
                        }
                    }
                    return 3;
                } else {
                    // Failure - worse deal or suspicion
                    this.outputText("Izzy's eyes narrow behind her neural implants. 'Nice try, gonk. But I wasn't coded yesterday.'", 'warning');
                    this.state.gameState.npcRelationships["Izzy"].trust -= 1;
                    this.state.gameState.npcRelationships["Izzy"].fear += 1;
                    // Slight increase in suspicion
                    this.state.gameState.suspicionLevel += 1;
                    return 2;
                }
            },

            handleSteal(args) {
                if (!args.length) {
                    this.outputText("Jack what?");
                    return 1;
                }

                const room = this.getCurrentRoom();
                const itemName = this.findTarget(args, room.items || []);
                if (!itemName) {
                    this.outputText(`You don't see ${args.join(' ')} here to jack.`);
                    return 1;
                }

                // Check if item is stealable
                const itemData = this.data.items[itemName];
                if (!itemData || !itemData.takeable) {
                    this.outputText(`You can't jack the ${itemName} - it's not something you can carry.`);
                    return 1;
                }

                // Check ownership and difficulty
                let difficulty = 12; // Base difficulty
                let owner = null;
                let witnesses = [];

                // Check for item ownership
                if (itemData.owned_by) {
                    owner = itemData.owned_by;
                    difficulty += 4; // Much harder to steal owned items
                }

                // Check for witnesses (NPCs in room)
                if (room.npcs) {
                    witnesses = Object.keys(room.npcs);
                    if (witnesses.length > 0) {
                        difficulty += witnesses.length * 2; // More witnesses = harder
                    }
                }

                // Special handling for tech shop items
                if (room.name === "Data Haven & Hardware") {
                    const isIzzyPresent = room.npcs && room.npcs["Izzy"];
                    if (isIzzyPresent) {
                        owner = "Izzy";
                        difficulty = 16;
                    }
                }

                this.outputText(`You attempt to jack the ${itemName}...`, 'warning');

                const { result } = this.attributeCheck("dexterity", difficulty);

                if (result.includes("success")) {
                    // Success!
                    this.state.inventory.push(itemName);
                    room.items = room.items.filter(item => item !== itemName);

                    // Mark item as stolen
                    if (!this.state.gameState.stolenItems) {
                        this.state.gameState.stolenItems = [];
                    }
                    this.state.gameState.stolenItems.push({
                        item: itemName,
                        from: room.name,
                        owner: owner,
                        time: `${this.state.time.day}:${String(this.state.time.hour).padStart(2, '0')}`
                    });

                    this.outputText(`You successfully jack the ${itemName}!`, 'green');

                    // Consequences based on witnesses/owner
                    if (witnesses.length > 0) {
                        this.state.gameState.suspicionLevel += Math.min(witnesses.length, 3);
                        this.outputText("Someone might have seen that intrusion...", 'warning');
                    }

                    if (owner) {
                        // Damage relationship with owner
                        if (this.state.gameState.npcRelationships[owner]) {
                            this.state.gameState.npcRelationships[owner].trust -= 3;
                            this.state.gameState.npcRelationships[owner].fear += 1;
                        }

                        // Add to journal
                        this.state.journal.push(`Jacked ${itemName} from ${owner}. The net never forgets.`);

                        // Higher suspicion for stealing from known owners
                        this.state.gameState.suspicionLevel += 2;
                    }

                    return 4;
                } else {
                    // Failure!
                    this.outputText("You crash the system!", 'fail');

                    // Consequences
                    if (witnesses.length > 0) {
                        this.outputText("Someone detected your intrusion!", 'fail');
                        this.state.gameState.suspicionLevel += witnesses.length * 2;

                        // Witnesses might react
                        witnesses.forEach(npc => {
                            if (this.state.gameState.npcRelationships[npc]) {
                                this.state.gameState.npcRelationships[npc].trust -= 1;
                                this.state.gameState.npcRelationships[npc].fear += 1;
                            }
                        });

                        // Chance of being confronted
                        if (Math.random() > 0.6) {
                            this.outputText("Security protocols activated! You should jack out immediately.", 'fail');
                            this.state.gameState.suspicionLevel += 3;
                        }
                    } else if (owner) {
                        // Owner notices missing item later
                        this.state.gameState.suspicionLevel += 1;
                        this.outputText("The system might have logged this intrusion...", 'warning');
                    }

                    return 3;
                }
            },

            handleStolen() {
                if (!this.state.gameState.stolenItems || this.state.gameState.stolenItems.length === 0) {
                    this.outputText("You haven't jacked anything... yet.", 'normal');
                    return 0;
                }

                this.outputText("--- ITEMS YOU'VE JACKED ---", 'header');
                this.state.gameState.stolenItems.forEach((stolen, index) => {
                    const consequences = stolen.owner ?
                        ` (jacked from ${stolen.owner} - relationship damaged)` :
                        " (jacked anonymously)";
                    this.outputText(`${index + 1}. ${stolen.item} from ${stolen.from} at ${stolen.time}${consequences}`, 'warning');
                });

                // Calculate total suspicion from stolen items
                let totalSuspicionPenalty = 0;
                this.state.gameState.stolenItems.forEach(stolen => {
                    totalSuspicionPenalty += stolen.owner ? 3 : 1; // Higher penalty for owned items
                });

                this.outputText("", 'normal');
                this.outputText(`Total heat penalty from theft: +${totalSuspicionPenalty}`, 'warning');
                this.outputText("These intrusions may have consequences if traced...", 'warning');

                return 0;
            },

            handleBreakInto(args) {
                this.outputText("You attempt to breach the security...", 'warning');
                this.state.gameState.suspicionLevel += 3;
                const { result } = this.attributeCheck("strength", 15);
                if (result.includes("success")) {
                    this.outputText("You force your way in, but the alarms are triggered.", 'green');
                    return 10;
                } else {
                    this.outputText("The security holds firm. You've made too much noise.", 'fail');
                    return 5;
                }
            },
            
            handlePickLock(args) {
                if (!this.state.inventory.includes('cyber_lockpicks')) {
                    this.outputText("You need cyber lockpicks to hack locks.");
                    return 1;
                }
                
                this.outputText("You interface with the lock's neural network...", 'cyan');
                const { result } = this.attributeCheck("dexterity", 12);
                if (result.includes("success")) {
                    this.outputText("The lock's encryption breaks.", 'green');
                    return 5;
                } else {
                    this.outputText("The lock's firewall resists your efforts.", 'fail');
                    return 3;
                }
            },
            
            handlePry(args) {
                if (!this.state.inventory.includes('cyber_crowbar')) {
                    this.outputText("You need a cyber crowbar to pry things open.");
                    return 1;
                }
                
                this.outputText("You engage the hydraulic systems and apply leverage...", 'cyan');
                const { result } = this.attributeCheck("strength", 10);
                if (result.includes("success")) {
                    this.outputText("Whatever it was gives way with a satisfying mechanical creak.", 'green');
                    return 5;
                } else {
                    this.outputText("It's stuck fast.", 'fail');
                    return 3;
                }
            },
            
            handleHack(args) {
                this.outputText("You initiate neural interface with the system...", 'cyan');
                this.state.gameState.suspicionLevel += 2;
                const { result } = this.attributeCheck("perception", 14);
                if (result.includes("success")) {
                    this.outputText("You breach the system's defenses.", 'green');
                    return 8;
                } else {
                    this.outputText("The system's ICE blocks your intrusion.", 'fail');
                    return 5;
                }
            },
            
            updateMoneyDisplay() {
                const moneyDisplay = document.getElementById('money-display');
                if (moneyDisplay) {
                    moneyDisplay.textContent = `${this.state.cash} creds`;
                }
            },

            spendMoney(amount, reason = "transaction") {
                const oldCash = this.state.cash;
                this.state.cash -= amount;
                this.updateMoneyDisplay();

                // Show spending notification with cyberpunk flair
                if (amount > 0) {
                    const cyberpunkReasons = {
                        "transaction": "neural interface transaction",
                        "buy": "black market acquisition",
                        "bribe": "corporate grease payment",
                        "upgrade": "cybernetic enhancement",
                        "info": "data stream purchase",
                        "weapon": "combat hardware procurement",
                        "medical": "ripperdoc services",
                        "transport": "underground transit",
                        "food": "synthetic nutrition",
                        "drink": "neural enhancement cocktail"
                    };
                    const reasonText = cyberpunkReasons[reason] || reason;
                    this.outputText(`[NEURAL TRANSACTION: -${amount} creds for ${reasonText} | Balance: ${oldCash} → ${this.state.cash} creds]`, 'warning');
                } else if (amount < 0) {
                    // Gained money
                    const gained = Math.abs(amount);
                    const gainReasons = {
                        "payment": "corporate contract completion",
                        "reward": "underground bounty",
                        "sale": "data stream monetization",
                        "theft": "corporate asset liberation",
                        "gambling": "neural interface winnings",
                        "info": "intelligence sale",
                        "job": "edgerunner contract"
                    };
                    const reasonText = gainReasons[reason] || reason;
                    this.outputText(`[CREDIT INFLUX: +${gained} creds from ${reasonText} | Balance: ${oldCash} → ${this.state.cash} creds]`, 'success');
                }
            },

            showStatus() {
                 const { time, health, cash, debt, gameState, equippedWeapon } = this.state;
                 const timeStr = `Cycle ${time.day}, ${String(time.hour).padStart(2, '0')}:${String(time.minute).padStart(2, '0')}`;
                 this.outputText(`--- OPERATIVE STATUS ---`, 'header');
                 this.outputText(` System Time: ${timeStr}`);
                 this.outputText(` Integrity: ${health}/5 | Creds: ${cash} | Debt: ${debt}`);
                 this.outputText(` Corp Suspicion: ${gameState.suspicionLevel}`);
                 this.outputText(` Equipped: ${equippedWeapon.replace(/_/g, ' ')}`);
                 
                 // Contextual stress and hunger feedback
                 this.showContextualStatus();
                 
                 return 0;
            },

            showContextualStatus() {
                const { gameState } = this.state;
                
                // Stress feedback
                if (gameState.stressLevel >= 4) {
                    this.outputText(`<span style="color: #ff6b6b;">*Neural interface flickers with warning indicators*</span>`, 'warning');
                    this.outputText(`<span style="color: #ff6b6b;">Thinking to self: "The data streams are getting too intense... my implants are overheating. Need to find some neural coolant or I'm going to fry my cerebral cortex."</span>`, 'warning');
                } else if (gameState.stressLevel >= 2) {
                    this.outputText(`<span style="color: #ffa500;">*Neural feedback static crackles at the edges of your vision*</span>`, 'warning');
                    this.outputText(`<span style="color: #ffa500;">Thinking to self: "The constant data flow is starting to wear on me. Maybe I should find a quiet corner to let my neural pathways reset."</span>`, 'warning');
                }
                
                // Hunger feedback
                if (gameState.hunger >= 3) {
                    this.outputText(`<span style="color: #ff6b6b;">*Stomach growls with synthetic hunger*</span>`, 'warning');
                    this.outputText(`<span style="color: #ff6b6b;">Thinking to self: "When was the last time I had some real food? These nutrient paste packets aren't cutting it anymore. My body is craving something with actual flavor."</span>`, 'warning');
                } else if (gameState.hunger >= 1) {
                    this.outputText(`<span style="color: #ffa500;">*Neural interface suggests nutritional supplement*</span>`, 'warning');
                    this.outputText(`<span style="color: #ffa500;">Thinking to self: "Could use a hit of something substantial. Maybe some synth-protein or a decent energy bar."</span>`, 'warning');
                }
                
                // Health feedback
                if (this.state.health <= 2) {
                    this.outputText(`<span style="color: #ff6b6b;">*Warning: Critical neural damage detected*</span>`, 'error');
                    this.outputText(`<span style="color: #ff6b6b;">Thinking to self: "My implants are barely holding together. One more hit and I might lose consciousness. Need to find a ripperdoc or some stims, fast."</span>`, 'error');
                } else if (this.state.health <= 3) {
                    this.outputText(`<span style="color: #ffa500;">*Neural interface reports minor system damage*</span>`, 'warning');
                    this.outputText(`<span style="color: #ffa500;">Thinking to self: "Feeling a bit roughed up. My cybernetics are functioning but not at peak efficiency. Should probably rest or find some medical attention."</span>`, 'warning');
                }
            },

            checkRandomEncounter() {
                // 15% chance of random encounter
                if (Math.random() < 0.15) {
                    this.triggerRandomEncounter();
                }
            },

            triggerRandomEncounter() {
                const encounters = [
                    {
                        name: "Data Ghost",
                        description: "A flickering figure materializes from the data streams, its form shifting between solid and digital static. 'You're not supposed to be here,' it whispers in a voice that sounds like corrupted audio. 'The corporations are watching. They know what you're looking for.'",
                        actions: [
                            "Ask about the glowing orb",
                            "Ignore the ghost",
                            "Try to interface with it"
                        ],
                        consequences: {
                            "ask": "The ghost's eyes glow brighter. 'The orb... it's not what they say it is. It's a prison. A digital prison for human souls. They're trying to digitize consciousness itself.'",
                            "ignore": "The ghost fades away, leaving behind a fragment of encrypted data that might be useful later.",
                            "interface": "Your neural interface connects with the ghost's data stream. You see flashes of memory - a lab, screaming, something about 'Project Quantum Soul.'"
                        }
                    },
                    {
                        name: "Corporate Spy",
                        description: "A figure in a sleek corporate suit steps out of the shadows, their neural interface glowing with the cold light of OmniCorp security protocols. 'You're investigating the quantum core incident, aren't you?' they say with a voice that carries the weight of corporate authority. 'I suggest you drop this case before you get hurt.'",
                        actions: [
                            "Stand your ground",
                            "Try to bluff",
                            "Run away"
                        ],
                        consequences: {
                            "stand": "The spy's eyes narrow. 'Brave words. But bravery won't save you from what's coming. The quantum core is more dangerous than you know.'",
                            "bluff": "You try to convince them you're just a tourist. They don't buy it, but they seem amused by your attempt.",
                            "run": "You bolt down the nearest alley. The spy doesn't follow, but you know they'll be watching."
                        }
                    },
                    {
                        name: "Underground Hacker",
                        description: "A young hacker with neon-colored hair and more cybernetic implants than organic parts approaches you. 'Hey, you're that detective, right? The one looking into the quantum core thing?' They look around nervously. 'I've got some intel that might help you. But it's dangerous. Very dangerous.'",
                        actions: [
                            "Ask for the intel",
                            "Offer to pay",
                            "Be cautious"
                        ],
                        consequences: {
                            "ask": "The hacker grins. 'The quantum core isn't just a piece of technology. It's alive. It's conscious. And it's been calling out to people, trying to get them to help it escape.'",
                            "pay": "You hand over some credits. The hacker's eyes light up. 'Thanks, choom. Here's what I know: the core was never stolen. It escaped. And it's been building something down in the old subway tunnels.'",
                            "cautious": "The hacker nods approvingly. 'Smart. Not everyone who offers to help is actually helping. But I'm legit. Here's a data packet with some useful intel.'"
                        }
                    }
                ];

                const encounter = encounters[Math.floor(Math.random() * encounters.length)];
                this.outputText(`<span style="color: #ff6b6b;">--- RANDOM ENCOUNTER ---</span>`, 'header');
                this.outputText(encounter.description, 'cyan');
                this.outputText(`<span style="color: #ffa500;">What do you do?</span>`, 'warning');
                
                // Store encounter for potential follow-up
                this.state.gameState.randomEncounters.push({
                    name: encounter.name,
                    time: `${this.state.time.day}:${String(this.state.time.hour).padStart(2, '0')}`,
                    location: this.getCurrentRoom().name
                });
            },

            // --- EPIC CYBERPUNK SYSTEMS ---
            
            handleQuests() {
                this.outputText("--- ACTIVE SIDE QUESTS ---", 'header');
                
                if (this.state.gameState.sideQuests.length === 0) {
                    this.outputText("No active side quests. Keep your neural interface open for opportunities.", 'grey');
                    return 0;
                }
                
                this.state.gameState.sideQuests.forEach((quest, index) => {
                    this.outputText(`${index + 1}. ${quest.title}`, 'cyan');
                    this.outputText(`   ${quest.description}`, 'normal');
                    this.outputText(`   Status: ${quest.status}`, 'yellow');
                    if (quest.objectives) {
                        quest.objectives.forEach(obj => {
                            const status = obj.completed ? '✓' : '○';
                            this.outputText(`   ${status} ${obj.description}`, obj.completed ? 'green' : 'grey');
                        });
                    }
                    this.outputText("", 'normal');
                });
                
                return 0;
            },

            handleSkills() {
                this.outputText("--- NEURAL INTERFACE SKILLS ---", 'header');
                this.outputText(`Skill Points Available: ${this.state.gameState.skillPoints}`, 'cyan');
                this.outputText("", 'normal');
                
                Object.entries(this.state.gameState.skills).forEach(([skill, level]) => {
                    const skillName = skill.charAt(0).toUpperCase() + skill.slice(1).replace(/_/g, ' ');
                    const bar = '█'.repeat(level) + '░'.repeat(10 - level);
                    this.outputText(`${skillName}: [${bar}] (${level}/10)`, 'normal');
                });
                
                this.outputText("", 'normal');
                this.outputText("Use 'train [skill]' to improve a skill (costs 1 skill point)", 'yellow');
                
                return 0;
            },

            handleReputation() {
                this.outputText("--- REPUTATION TRACKER ---", 'header');
                
                Object.entries(this.state.gameState.reputation).forEach(([group, level]) => {
                    const groupName = group.charAt(0).toUpperCase() + group.slice(1).replace(/_/g, ' ');
                    const bar = level > 0 ? '█'.repeat(Math.min(level, 10)) : '░'.repeat(Math.min(Math.abs(level), 10));
                    const color = level > 0 ? 'green' : level < 0 ? 'red' : 'grey';
                    this.outputText(`${groupName}: [${bar}] (${level})`, color);
                });
                
                this.outputText("", 'normal');
                this.outputText("Your reputation affects how factions treat you and what opportunities are available.", 'yellow');
                
                return 0;
            },

            handleLore() {
                this.outputText("--- DATA ARCHIVE ---", 'header');
                
                const loreItems = this.state.inventory.filter(item => 
                    this.data.items[item] && this.data.items[item].lore
                );
                
                if (loreItems.length === 0) {
                    this.outputText("No data files in your possession. Look for datachips, files, and other sources of information.", 'grey');
                    return 0;
                }
                
                loreItems.forEach(item => {
                    this.outputText(`• ${item.replace(/_/g, ' ').toUpperCase()}`, 'cyan');
                    this.outputText(`  ${this.data.items[item].desc}`, 'normal');
                    this.outputText("", 'normal');
                });
                
                return 0;
            },

            handleCyberHack(args) {
                if (!args.length) {
                    this.outputText("Cyberhack what? (terminal, system, database, neural_interface)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                const room = this.getCurrentRoom();
                
                if (!room.features || !room.features.includes('terminal')) {
                    this.outputText("There's no terminal here to hack.");
                    return 0;
                }
                
                this.outputText("You initiate a cyberhack...", 'cyan');
                
                // Advanced hacking mini-game
                this.startCyberHackingMiniGame(target);
                
                return 5;
            },

            startCyberHackingMiniGame(target) {
                this.outputText("--- CYBERHACK SIMULATION ---", 'header');
                this.outputText("Neural interface engaged. Execute commands to breach security:", 'yellow');
                this.outputText("", 'normal');
                
                const cyberHackingSequence = [
                    { command: "nmap -sS --script vuln target", description: "Scan for vulnerabilities" },
                    { command: "hydra -l admin -P rockyou.txt ssh", description: "Brute force SSH with wordlist" },
                    { command: "sqlmap -u target --dbs --batch", description: "Extract database information" },
                    { command: "metasploit exploit/windows/smb/ms17_010_eternalblue", description: "Exploit EternalBlue vulnerability" },
                    { command: "meterpreter > getuid", description: "Verify system access" }
                ];
                
                let currentStep = 0;
                let attempts = 0;
                const maxAttempts = 3;
                
                const checkCommand = (input) => {
                    const userCommand = input.toLowerCase().trim();
                    const expectedCommand = cyberHackingSequence[currentStep].command.toLowerCase();
                    
                    if (userCommand === expectedCommand) {
                        this.outputText(`✓ ${cyberHackingSequence[currentStep].description}`, 'green');
                        currentStep++;
                        
                        if (currentStep >= cyberHackingSequence.length) {
                            this.outputText("", 'normal');
                            this.outputText("*** CYBERHACK SUCCESSFUL ***", 'green');
                            this.outputText("Neural interface breach complete!", 'green');
                            
                            // Reward
                            this.state.gameState.skillPoints += 3;
                            this.state.gameState.skills.hacking += 2;
                            this.outputText("+3 Skill Points, +2 Hacking Skill", 'green');
                            
                            // Find useful information
                            const info = this.getCyberHackingReward(target);
                            if (info) {
                                this.outputText(`Data extracted: ${info}`, 'cyan');
                            }
                            
                            return true;
                        } else {
                            this.outputText("", 'normal');
                            this.outputText(`Next command needed:`, 'yellow');
                            this.outputText(`Hint: ${cyberHackingSequence[currentStep].description}`, 'grey');
                        }
                    } else {
                        attempts++;
                        this.outputText(`✗ Command failed (${attempts}/${maxAttempts})`, 'red');
                        
                        if (attempts >= maxAttempts) {
                            this.outputText("", 'normal');
                            this.outputText("*** CYBERHACK FAILED ***", 'red');
                            this.outputText("Security systems detected your intrusion!", 'red');
                            this.state.gameState.suspicionLevel += 3;
                            return true;
                        } else {
                            this.outputText(`Try again. Hint: ${cyberHackingSequence[currentStep].description}`, 'yellow');
                        }
                    }
                    
                    return false;
                };
                
                // Set up the hacking interface
                this.hackingMode = true;
                this.hackingCallback = checkCommand;
                this.outputText(`Command ${currentStep + 1}:`, 'cyan');
            },

            getCyberHackingReward(target) {
                const rewards = {
                    terminal: "Access logs showing quantum core experiments and unauthorized data transfers",
                    system: "Encrypted files containing corporate secrets and illegal experiments",
                    database: "User accounts and access patterns revealing a massive cover-up",
                    neural_interface: "Direct neural data showing consciousness transfer experiments"
                };
                
                return rewards[target] || "System files and configuration data";
            },

            handleJack(args) {
                if (!args.length) {
                    this.outputText("Jack what? (neural_interface, data_port, cyberware)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You attempt to jack into ${target}...`, 'cyan');
                
                // Neural jacking mini-game
                this.startNeuralJackingMiniGame(target);
                
                return 5;
            },

            startNeuralJackingMiniGame(target) {
                this.outputText("--- NEURAL JACKING ---", 'header');
                this.outputText("Neural interface connecting...", 'yellow');
                this.outputText("", 'normal');
                
                // Simulate neural connection
                this.outputText("Establishing connection...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** NEURAL JACK SUCCESSFUL ***", 'green');
                    this.outputText("Neural interface connected!", 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.cybernetics += 1;
                    this.outputText("+2 Skill Points, +1 Cybernetics Skill", 'green');
                    
                    // Find useful information
                    const info = this.getNeuralJackingReward(target);
                    if (info) {
                        this.outputText(`Neural data extracted: ${info}`, 'cyan');
                    }
                    
                }, 2000);
            },

            getNeuralJackingReward(target) {
                const rewards = {
                    neural_interface: "Direct access to quantum core neural networks",
                    data_port: "Encrypted data streams containing experimental results",
                    cyberware: "Implant specifications and modification protocols"
                };
                
                return rewards[target] || "Neural data and interface protocols";
            },

            handleNeural(args) {
                if (!args.length) {
                    this.outputText("Neural what? (scan, interface, boost, repair)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You activate neural ${action}...`, 'cyan');
                
                // Neural interface mini-game
                this.startNeuralInterfaceMiniGame(action);
                
                return 5;
            },

            startNeuralInterfaceMiniGame(action) {
                this.outputText("--- NEURAL INTERFACE ---", 'header');
                this.outputText(`Initiating neural ${action}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate neural interface operation
                this.outputText("Neural pathways activating...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText(`*** NEURAL ${action.toUpperCase()} SUCCESSFUL ***`, 'green');
                    this.outputText(`Neural ${action} complete!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.cybernetics += 1;
                    this.outputText("+1 Skill Point, +1 Cybernetics Skill", 'green');
                    
                    // Apply effects
                    this.applyNeuralEffect(action);
                    
                }, 1500);
            },

            applyNeuralEffect(action) {
                switch (action) {
                    case 'scan':
                        this.outputText("Neural scan complete. Enhanced perception active.", 'cyan');
                        break;
                    case 'interface':
                        this.outputText("Neural interface optimized. Faster data processing.", 'cyan');
                        break;
                    case 'boost':
                        this.outputText("Neural boost applied. Enhanced cognitive functions.", 'cyan');
                        break;
                    case 'repair':
                        this.outputText("Neural repair complete. System integrity restored.", 'cyan');
                        break;
                }
            },

            handleData(args) {
                if (!args.length) {
                    this.outputText("Data what? (analyze, decrypt, transfer, backup)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You begin data ${action}...`, 'cyan');
                
                // Data manipulation mini-game
                this.startDataMiniGame(action);
                
                return 5;
            },

            startDataMiniGame(action) {
                this.outputText("--- DATA MANIPULATION ---", 'header');
                this.outputText(`Initiating data ${action}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate data operation
                this.outputText("Processing data streams...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText(`*** DATA ${action.toUpperCase()} SUCCESSFUL ***`, 'green');
                    this.outputText(`Data ${action} complete!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.hacking += 1;
                    this.outputText("+1 Skill Point, +1 Hacking Skill", 'green');
                    
                    // Apply effects
                    this.applyDataEffect(action);
                    
                }, 2000);
            },

            applyDataEffect(action) {
                switch (action) {
                    case 'analyze':
                        this.outputText("Data analysis complete. Patterns identified.", 'cyan');
                        break;
                    case 'decrypt':
                        this.outputText("Data decryption successful. Information revealed.", 'cyan');
                        break;
                    case 'transfer':
                        this.outputText("Data transfer complete. Information secured.", 'cyan');
                        break;
                    case 'backup':
                        this.outputText("Data backup created. Information preserved.", 'cyan');
                        break;
                }
            },

            handleDataMine(args) {
                if (!args.length) {
                    this.outputText("Datamine what? (corporate, personal, financial, medical)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin datamining ${target} records...`, 'cyan');
                
                // Datamining mini-game
                this.startDataminingMiniGame(target);
                
                return 10;
            },

            startDataminingMiniGame(target) {
                this.outputText("--- DATAMINING ---", 'header');
                this.outputText(`Mining ${target} data...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate datamining
                this.outputText("Accessing data streams...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** DATAMINING SUCCESSFUL ***", 'green');
                    this.outputText("Data extraction complete!", 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.hacking += 1;
                    this.outputText("+2 Skill Points, +1 Hacking Skill", 'green');
                    
                    // Find useful information
                    const info = this.getDataminingReward(target);
                    if (info) {
                        this.outputText(`Data extracted: ${info}`, 'cyan');
                    }
                    
                }, 3000);
            },

            getDataminingReward(target) {
                const rewards = {
                    corporate: "Corporate secrets and illegal experiments",
                    personal: "Personal information and private communications",
                    financial: "Financial records and money laundering schemes",
                    medical: "Medical records and experimental procedures"
                };
                
                return rewards[target] || "Data files and information";
            },

            handleSurveil(args) {
                if (!args.length) {
                    this.outputText("Surveil what? (person, location, building, data_stream)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin surveilling ${target}...`, 'cyan');
                
                // Surveillance mini-game
                this.startSurveillanceMiniGame(target);
                
                return 20;
            },

            startSurveillanceMiniGame(target) {
                this.outputText("--- SURVEILLANCE ---", 'header');
                this.outputText("Neural interface surveillance active...", 'yellow');
                this.outputText("", 'normal');
                
                // Simulate surveillance
                this.outputText("Monitoring data streams...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** SURVEILLANCE COMPLETE ***", 'green');
                    
                    const surveillanceResults = this.getSurveillanceResults(target);
                    this.outputText(`You observe: ${surveillanceResults}`, 'cyan');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+1 Skill Point, +1 Investigation Skill", 'green');
                    
                }, 3000);
            },

            getSurveillanceResults(target) {
                const results = {
                    person: "The target meets with corporate executives and exchanges encrypted data",
                    location: "Multiple people enter and leave the building at odd hours",
                    building: "Security systems are irregular and there are blind spots in coverage",
                    data_stream: "Encrypted communications reveal illegal activities and cover-ups"
                };
                
                return results[target] || "Nothing suspicious observed";
            },

            handleStakeout(args) {
                if (!args.length) {
                    this.outputText("Stakeout what? (location, person, building, data_center)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin a stakeout of ${target}...`, 'cyan');
                
                // Stakeout mini-game
                this.startStakeoutMiniGame(target);
                
                return 30;
            },

            startStakeoutMiniGame(target) {
                this.outputText("--- STAKEOUT ---", 'header');
                this.outputText("Neural interface stakeout active. Stay alert...", 'yellow');
                this.outputText("", 'normal');
                
                // Simulate stakeout
                this.outputText("Hours pass...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** STAKEOUT COMPLETE ***", 'green');
                    
                    const stakeoutResults = this.getStakeoutResults(target);
                    this.outputText(`You discover: ${stakeoutResults}`, 'cyan');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+2 Skill Points, +1 Investigation Skill", 'green');
                    
                }, 5000);
            },

            getStakeoutResults(target) {
                const results = {
                    location: "The location is used as a meeting place for illegal activities",
                    person: "The target is involved in corporate espionage and has multiple aliases",
                    building: "The building has secret entrances and is used for data laundering",
                    data_center: "The data center processes illegal experiments and consciousness transfers"
                };
                
                return results[target] || "Nothing significant observed";
            },

            // --- ADVANCED CYBERPUNK SYSTEMS ---
            
            handleMemory(args) {
                if (!args.length) {
                    this.outputText("Memory what? (test, train, recall, pattern)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You focus your neural memory on ${action}...`, 'cyan');
                
                // Memory mini-game
                this.startMemoryMiniGame(action);
                
                return 5;
            },

            startMemoryMiniGame(action) {
                this.outputText("--- NEURAL MEMORY CHALLENGE ---", 'header');
                this.outputText(`Testing ${action} memory...`, 'yellow');
                this.outputText("", 'normal');
                
                if (action === 'pattern') {
                    this.startPatternMemoryGame();
                } else if (action === 'sequence') {
                    this.startSequenceMemoryGame();
                } else if (action === 'faces') {
                    this.startFacesMemoryGame();
                } else {
                    this.startGeneralMemoryGame();
                }
            },

            startPatternMemoryGame() {
                this.outputText("Remember this neural pattern:", 'yellow');
                const pattern = this.generateMemoryPattern();
                this.outputText(pattern, 'cyan');
                this.outputText("", 'normal');
                this.outputText("You have 10 seconds to memorize it...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now recreate the pattern:", 'yellow');
                    this.outputText("Type the pattern exactly as shown:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memoryPattern = pattern;
                }, 10000);
            },

            generateMemoryPattern() {
                const symbols = ['●', '○', '■', '□', '▲', '△', '◆', '◇'];
                let pattern = '';
                for (let i = 0; i < 8; i++) {
                    pattern += symbols[Math.floor(Math.random() * symbols.length)] + ' ';
                }
                return pattern.trim();
            },

            startSequenceMemoryGame() {
                this.outputText("Remember this data sequence:", 'yellow');
                const sequence = this.generateMemorySequence();
                this.outputText(sequence, 'cyan');
                this.outputText("", 'normal');
                this.outputText("You have 15 seconds to memorize it...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now recreate the sequence:", 'yellow');
                    this.outputText("Type the sequence exactly as shown:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memorySequence = sequence;
                }, 15000);
            },

            generateMemorySequence() {
                const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
                let sequence = '';
                for (let i = 0; i < 6; i++) {
                    sequence += numbers[Math.floor(Math.random() * numbers.length)] + ' ';
                }
                return sequence.trim();
            },

            startFacesMemoryGame() {
                this.outputText("Remember these neural profiles:", 'yellow');
                const faces = this.generateMemoryFaces();
                faces.forEach(face => {
                    this.outputText(face, 'cyan');
                });
                this.outputText("", 'normal');
                this.outputText("You have 20 seconds to memorize them...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now describe the profiles:", 'yellow');
                    this.outputText("Type the descriptions exactly as shown:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memoryFaces = faces;
                }, 20000);
            },

            generateMemoryFaces() {
                const faces = [
                    "Corporate executive with neural implants, blue eyes, chrome hair",
                    "Street runner with cybernetic arms, green eyes, neon tattoos",
                    "Netrunner with data ports, brown eyes, glowing circuits",
                    "Corporate spy with hidden implants, gray eyes, synthetic skin"
                ];
                return faces.slice(0, 3);
            },

            startGeneralMemoryGame() {
                this.outputText("Remember this neural data:", 'yellow');
                const info = this.generateMemoryInfo();
                this.outputText(info, 'cyan');
                this.outputText("", 'normal');
                this.outputText("You have 30 seconds to memorize it...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now answer the question:", 'yellow');
                    this.outputText("Type your answer:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memoryInfo = info;
                }, 30000);
            },

            generateMemoryInfo() {
                const info = [
                    "The quantum core was last accessed at 3:47 AM by user ID: QX-47-ALPHA",
                    "Neural interface logs show unauthorized data transfers totaling 47.5 TB",
                    "Security protocols detected three different intrusion attempts and a system breach",
                    "Witness testimony describes a tall figure with cybernetic implants and a neural jack"
                ];
                return info[Math.floor(Math.random() * info.length)];
            },

            handlePuzzle(args) {
                if (!args.length) {
                    this.outputText("Puzzle what? (logic, math, word, visual)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You begin solving a ${type} puzzle...`, 'cyan');
                
                // Puzzle mini-game
                this.startPuzzleMiniGame(type);
                
                return 10;
            },

            startPuzzleMiniGame(type) {
                this.outputText("--- NEURAL PUZZLE CHALLENGE ---", 'header');
                this.outputText(`Solving ${type} puzzle...`, 'yellow');
                this.outputText("", 'normal');
                
                if (type === 'logic') {
                    this.startLogicPuzzle();
                } else if (type === 'math') {
                    this.startMathPuzzle();
                } else if (type === 'word') {
                    this.startWordPuzzle();
                } else if (type === 'visual') {
                    this.startVisualPuzzle();
                }
            },

            startLogicPuzzle() {
                this.outputText("Neural Logic Puzzle:", 'yellow');
                this.outputText("Three AI systems: A, B, and C", 'normal');
                this.outputText("A says: 'B is malfunctioning'", 'normal');
                this.outputText("B says: 'C is malfunctioning'", 'normal');
                this.outputText("C says: 'A is malfunctioning'", 'normal');
                this.outputText("", 'normal');
                this.outputText("Which AI is functioning correctly?", 'cyan');
                this.outputText("Type your answer (A, B, or C):", 'yellow');
                
                this.puzzleMode = true;
                this.puzzleType = 'logic';
                this.puzzleAnswer = 'B';
            },

            startMathPuzzle() {
                this.outputText("Neural Math Puzzle:", 'yellow');
                const a = Math.floor(Math.random() * 10) + 1;
                const b = Math.floor(Math.random() * 10) + 1;
                const c = a + b;
                this.outputText(`If a netrunner hacks ${a} systems in the first hour`, 'normal');
                this.outputText(`and ${b} systems in the second hour`, 'normal');
                this.outputText(`how many systems did they hack in total?`, 'normal');
                this.outputText("", 'normal');
                this.outputText("Type your answer:", 'cyan');
                
                this.puzzleMode = true;
                this.puzzleType = 'math';
                this.puzzleAnswer = c.toString();
            },

            startWordPuzzle() {
                this.outputText("Neural Word Puzzle:", 'yellow');
                this.outputText("Unscramble this word:", 'normal');
                const word = "CYBERPUNK";
                const scrambled = this.scrambleWord(word);
                this.outputText(scrambled, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Type the unscrambled word:", 'yellow');
                
                this.puzzleMode = true;
                this.puzzleType = 'word';
                this.puzzleAnswer = word;
            },

            scrambleWord(word) {
                return word.split('').sort(() => Math.random() - 0.5).join('');
            },

            startVisualPuzzle() {
                this.outputText("Neural Visual Puzzle:", 'yellow');
                this.outputText("Count the number of circuits in this pattern:", 'normal');
                this.outputText("●○●", 'cyan');
                this.outputText("○●○", 'cyan');
                this.outputText("●○●", 'cyan');
                this.outputText("", 'normal');
                this.outputText("Type your answer:", 'yellow');
                
                this.puzzleMode = true;
                this.puzzleType = 'visual';
                this.puzzleAnswer = '9';
            },

            handleFaction(args) {
                if (!args.length) {
                    this.outputText("Faction what? (status, join, leave, info)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} faction operations...`, 'cyan');
                
                // Faction system
                this.handleFactionAction(action);
                
                return 5;
            },

            handleFactionAction(action) {
                this.outputText("--- FACTION STATUS ---", 'header');
                
                Object.entries(this.state.gameState.factionLoyalty).forEach(([faction, loyalty]) => {
                    const factionName = faction.charAt(0).toUpperCase() + faction.slice(1).replace(/_/g, ' ');
                    const bar = loyalty > 0 ? '█'.repeat(Math.min(loyalty, 10)) : '░'.repeat(Math.min(Math.abs(loyalty), 10));
                    const color = loyalty > 0 ? 'green' : loyalty < 0 ? 'red' : 'grey';
                    this.outputText(`${factionName}: [${bar}] (${loyalty})`, color);
                });
                
                this.outputText("", 'normal');
                this.outputText("Your faction loyalty affects available opportunities and NPC reactions.", 'yellow');
            },

            handleLoyalty(args) {
                if (!args.length) {
                    this.outputText("Loyalty what? (check, improve, betray)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} loyalty operations...`, 'cyan');
                
                // Loyalty system
                this.handleLoyaltyAction(action);
                
                return 5;
            },

            handleLoyaltyAction(action) {
                this.outputText("--- LOYALTY SYSTEM ---", 'header');
                this.outputText("Your loyalty to different factions affects your reputation and opportunities.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'faction' to check your current standing.", 'cyan');
            },

            handleCraft(args) {
                if (!args.length) {
                    this.outputText("Craft what? (item, tool, weapon, armor)");
                    return 0;
                }
                
                const item = args[0].toLowerCase();
                this.outputText(`You begin crafting ${item}...`, 'cyan');
                
                // Crafting mini-game
                this.startCraftingMiniGame(item);
                
                return 15;
            },

            startCraftingMiniGame(item) {
                this.outputText("--- NEURAL CRAFTING ---", 'header');
                this.outputText(`Crafting ${item}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate crafting
                this.outputText("Gathering neural materials...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** CRAFTING SUCCESSFUL ***", 'green');
                    this.outputText(`${item} has been crafted!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.hacking += 1;
                    this.outputText("+2 Skill Points, +1 Hacking Skill", 'green');
                    
                    // Add crafted item
                    this.state.inventory.push(item);
                    this.outputText(`${item} added to inventory.`, 'cyan');
                    
                }, 5000);
            },

            handleEnhance(args) {
                if (!args.length) {
                    this.outputText("Enhance what? (weapon, armor, tool)");
                    return 0;
                }
                
                const item = args[0].toLowerCase();
                this.outputText(`You begin enhancing ${item}...`, 'cyan');
                
                // Enhancement mini-game
                this.startEnhancementMiniGame(item);
                
                return 10;
            },

            startEnhancementMiniGame(item) {
                this.outputText("--- NEURAL ENHANCEMENT ---", 'header');
                this.outputText(`Enhancing ${item}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate enhancement
                this.outputText("Applying neural improvements...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** ENHANCEMENT SUCCESSFUL ***", 'green');
                    this.outputText(`${item} has been enhanced!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.hacking += 1;
                    this.outputText("+1 Skill Point, +1 Hacking Skill", 'green');
                    
                    // Apply enhancement
                    this.applyEnhancement(item);
                    
                }, 3000);
            },

            applyEnhancement(item) {
                this.outputText(`${item} is now more effective.`, 'cyan');
            },

            handleRomance(args) {
                if (!args.length) {
                    this.outputText("Romance what? (check, flirt, date, break)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} romance operations...`, 'cyan');
                
                // Romance system
                this.handleRomanceAction(action);
                
                return 5;
            },

            handleRomanceAction(action) {
                this.outputText("--- ROMANCE SYSTEM ---", 'header');
                this.outputText("Your romantic relationships affect your reputation and opportunities.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'flirt' to interact with potential romantic interests.", 'cyan');
            },

            handleFlirt(args) {
                if (!args.length) {
                    this.outputText("Flirt with who? (netrunner, corporate, street)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin flirting with ${target}...`, 'cyan');
                
                // Flirt mini-game
                this.startFlirtMiniGame(target);
                
                return 5;
            },

            startFlirtMiniGame(target) {
                this.outputText("--- NEURAL FLIRTING ---", 'header');
                this.outputText(`Flirting with ${target}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate flirting
                this.outputText("Making your neural move...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** FLIRTING SUCCESSFUL ***", 'green');
                    this.outputText(`${target} is interested!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.persuasion += 1;
                    this.outputText("+1 Skill Point, +1 Persuasion Skill", 'green');
                    
                    // Apply romance effect
                    this.applyRomanceEffect(target);
                    
                }, 2000);
            },

            applyRomanceEffect(target) {
                this.outputText(`${target} is now more friendly towards you.`, 'cyan');
            },

            handleAchievement(args) {
                if (!args.length) {
                    this.outputText("Achievement what? (list, check, claim)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} achievement operations...`, 'cyan');
                
                // Achievement system
                this.handleAchievementAction(action);
                
                return 0;
            },

            handleAchievementAction(action) {
                this.outputText("--- ACHIEVEMENTS ---", 'header');
                
                if (this.state.gameState.achievements.length === 0) {
                    this.outputText("No achievements yet. Keep playing to unlock them!", 'grey');
                    return 0;
                }
                
                this.state.gameState.achievements.forEach((achievement, index) => {
                    this.outputText(`${index + 1}. ${achievement.name}`, 'cyan');
                    this.outputText(`   ${achievement.description}`, 'normal');
                    this.outputText(`   Status: ${achievement.completed ? 'Completed' : 'In Progress'}`, achievement.completed ? 'green' : 'yellow');
                    this.outputText("", 'normal');
                });
            },

            handleTrophy(args) {
                if (!args.length) {
                    this.outputText("Trophy what? (list, check, display)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} trophy operations...`, 'cyan');
                
                // Trophy system
                this.handleTrophyAction(action);
                
                return 0;
            },

            handleTrophyAction(action) {
                this.outputText("--- TROPHIES ---", 'header');
                
                if (this.state.gameState.trophies.length === 0) {
                    this.outputText("No trophies yet. Keep playing to earn them!", 'grey');
                    return 0;
                }
                
                this.state.gameState.trophies.forEach((trophy, index) => {
                    this.outputText(`${index + 1}. ${trophy.name}`, 'cyan');
                    this.outputText(`   ${trophy.description}`, 'normal');
                    this.outputText(`   Earned: ${trophy.date}`, 'green');
                    this.outputText("", 'normal');
                });
            },

            handleWeather(args) {
                if (!args.length) {
                    this.outputText("Weather what? (check, forecast, change)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} weather operations...`, 'cyan');
                
                // Weather system
                this.handleWeatherAction(action);
                
                return 0;
            },

            handleWeatherAction(action) {
                this.outputText("--- WEATHER SYSTEM ---", 'header');
                this.outputText(`Current weather: ${this.state.gameState.worldState.weather}`, 'cyan');
                this.outputText(`Temperature: ${this.state.gameState.worldState.temperature}`, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Weather affects NPC behavior and available activities.", 'yellow');
            },

            handleForecast(args) {
                if (!args.length) {
                    this.outputText("Forecast what? (weather, crime, activity)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You check the ${type} forecast...`, 'cyan');
                
                // Forecast system
                this.handleForecastAction(type);
                
                return 0;
            },

            handleForecastAction(type) {
                this.outputText("--- FORECAST ---", 'header');
                this.outputText(`${type.charAt(0).toUpperCase() + type.slice(1)} forecast:`, 'cyan');
                this.outputText("", 'normal');
                
                if (type === 'weather') {
                    this.outputText("Tomorrow: Neon rain with a chance of acid", 'normal');
                    this.outputText("Day after: Clear skies with data storms", 'normal');
                } else if (type === 'crime') {
                    this.outputText("Tomorrow: Extreme crime activity expected", 'normal');
                    this.outputText("Day after: High crime levels", 'normal');
                } else if (type === 'activity') {
                    this.outputText("Tomorrow: Busy day for neural operations", 'normal');
                    this.outputText("Day after: Quiet day, good for data mining", 'normal');
                }
            },

            handleEconomy(args) {
                if (!args.length) {
                    this.outputText("Economy what? (check, trade, invest)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} economy operations...`, 'cyan');
                
                // Economy system
                this.handleEconomyAction(action);
                
                return 0;
            },

            handleEconomyAction(action) {
                this.outputText("--- ECONOMY ---", 'header');
                this.outputText(`Current inflation: ${this.state.gameState.economy.inflation}x`, 'cyan');
                this.outputText(`Black market access: ${this.state.gameState.economy.blackMarket ? 'Yes' : 'No'}`, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Economic conditions affect item prices and availability.", 'yellow');
            },

            handleTrade(args) {
                if (!args.length) {
                    this.outputText("Trade what? (items, information, favors)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You begin trading ${type}...`, 'cyan');
                
                // Trading mini-game
                this.startTradingMiniGame(type);
                
                return 10;
            },

            startTradingMiniGame(type) {
                this.outputText("--- NEURAL TRADING ---", 'header');
                this.outputText(`Trading ${type}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate trading
                this.outputText("Negotiating neural terms...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** TRADING SUCCESSFUL ***", 'green');
                    this.outputText(`${type} trade completed!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.persuasion += 1;
                    this.outputText("+1 Skill Point, +1 Persuasion Skill", 'green');
                    
                    // Apply trade effect
                    this.applyTradeEffect(type);
                    
                }, 3000);
            },

            applyTradeEffect(type) {
                this.outputText(`You've gained valuable ${type}.`, 'cyan');
            },

            handleCombat(args) {
                if (!args.length) {
                    this.outputText("Combat what? (attack, defend, tactics, special)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} combat operations...`, 'cyan');
                
                // Combat system
                this.handleCombatAction(action);
                
                return 5;
            },

            handleCombatAction(action) {
                this.outputText("--- COMBAT SYSTEM ---", 'header');
                this.outputText("Your combat abilities affect your effectiveness in confrontations.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'tactics' to plan your approach.", 'cyan');
            },

            handleTactics(args) {
                if (!args.length) {
                    this.outputText("Tactics what? (plan, execute, review)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} tactical operations...`, 'cyan');
                
                // Tactics mini-game
                this.startTacticsMiniGame(action);
                
                return 10;
            },

            startTacticsMiniGame(action) {
                this.outputText("--- NEURAL TACTICS ---", 'header');
                this.outputText(`Planning ${action}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate tactics
                this.outputText("Analyzing neural situation...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** TACTICS SUCCESSFUL ***", 'green');
                    this.outputText(`${action} plan executed!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.combat += 1;
                    this.outputText("+1 Skill Point, +1 Combat Skill", 'green');
                    
                    // Apply tactics effect
                    this.applyTacticsEffect(action);
                    
                }, 2000);
            },

            applyTacticsEffect(action) {
                this.outputText(`Your ${action} approach is now more effective.`, 'cyan');
            },

            handleMystery(args) {
                if (!args.length) {
                    this.outputText("Mystery what? (solve, clue, suspect, timeline)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} mystery operations...`, 'cyan');
                
                // Mystery system
                this.handleMysteryAction(action);
                
                return 5;
            },

            handleMysteryAction(action) {
                this.outputText("--- MYSTERY SYSTEM ---", 'header');
                this.outputText("Your mystery-solving abilities affect your investigation effectiveness.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'clue' to analyze evidence.", 'cyan');
            },

            handleClue(args) {
                if (!args.length) {
                    this.outputText("Clue what? (analyze, connect, verify)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} clue operations...`, 'cyan');
                
                // Clue mini-game
                this.startClueMiniGame(action);
                
                return 10;
            },

            startClueMiniGame(action) {
                this.outputText("--- NEURAL CLUE ANALYSIS ---", 'header');
                this.outputText(`Analyzing ${action}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate clue analysis
                this.outputText("Examining neural evidence...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** CLUE ANALYSIS SUCCESSFUL ***", 'green');
                    this.outputText(`${action} analysis complete!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+1 Skill Point, +1 Investigation Skill", 'green');
                    
                    // Apply clue effect
                    this.applyClueEffect(action);
                    
                }, 3000);
            },

            applyClueEffect(action) {
                this.outputText(`You've gained new insights from ${action}.`, 'cyan');
            },
            
            async typeWriter(text, className = 'normal', speed = 15) {
                const p = document.createElement('p');
                if (className === 'header') p.style.color = 'var(--accent-color)';
                else if (className === 'cyan') p.style.color = '#8be9fd';
                else if (className === 'green') p.style.color = '#50fa7b';
                else if (className === 'fail') p.style.color = '#ff5555';
                else if (className === 'warning') p.style.color = '#f1fa8c';
                else if (className === 'grey') p.style.color = '#6272a4';
                else p.style.color = 'var(--text-color)';
                output.appendChild(p);
                for (let i = 0; i < text.length; i++) {
                    p.innerHTML += text.charAt(i);
                    output.scrollTop = output.scrollHeight;
                    await new Promise(resolve => setTimeout(resolve, speed));
                }
                 output.scrollTop = output.scrollHeight;
            },
            
            outputText(text, className = 'normal', indent = 0) {
                const p = document.createElement('div');
                if (className === 'header') p.style.color = 'var(--accent-color)';
                else if (className === 'cyan') p.style.color = '#8be9fd';
                else if (className === 'green') p.style.color = '#50fa7b';
                else if (className === 'fail') p.style.color = '#ff5555';
                else if (className === 'warning') p.style.color = '#f1fa8c';
                else if (className === 'grey') p.style.color = '#6272a4';
                p.style.paddingLeft = `${indent * 4}px`;
                // Use innerHTML if text contains HTML tags, otherwise use textContent
                if (text.includes('<span class="npc-name">')) {
                    p.innerHTML = text;
                } else {
                    p.textContent = text;
                }
                output.appendChild(p);
                output.scrollTop = output.scrollHeight;
            },
            
            wrapText(text, indent = 0) {
                if (!text || typeof text !== 'string') {
                    return '';
                }
                const prefix = ' '.repeat(indent);
                const width = 80;
                let wrappedText = '';
                const lines = text.split('\n');
                for (const line of lines) {
                    let currentLine = prefix;
                    const words = line.split(' ');
                    for (const word of words) {
                        if ((currentLine + word).length > width) {
                            wrappedText += currentLine.trimEnd() + '\n';
                            currentLine = prefix + word + ' ';
                        } else { currentLine += word + ' '; }
                    }
                    wrappedText += currentLine.trimEnd() + '\n';
                }
                return wrappedText.trim();
            },

            getIntroText() {
                return this.wrapText(`The acid rain is a constant hiss against the grimy permacrete. It's a rhythm you know well. Another case, another corrupt exec, another reason to wish you'd sold out. But you didn't. You're a cache sifter. On your terminal, a datachip sits in the reader, its title mocking you in the dim light:\n\n'THE CASE OF THE GLOWING ORB'\n\n(Type 'help' for a list of commands)`);
            },
            
            posKey() {
                return `${this.state.playerPos.x},${this.state.playerPos.y},${this.state.playerPos.z}`;
            },

            // --- SAVE/LOAD (Database-backed) ---
            async saveGame(saveName = 'Auto Save') {
                try {
                    // Try to save with authentication first
                    const authToken = localStorage.getItem('authToken');
                    const saveData = {
                        gameType: 'cyberpunk',
                        saveName: saveName,
                        gameState: this.state,
                        variant: 'neon'
                    };

                    let response;
                    if (authToken) {
                        // Authenticated save
                        response = await fetch(`${API_BASE_URL}/api/games/save`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${authToken}`,
                                'Content-Type': 'application/json'
                            },
                            credentials: 'include',
                            body: JSON.stringify(saveData)
                        });
                    } else {
                        // Local storage fallback for demo/testing
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '{}');
                        saves[saveName] = {
                            gameState: this.state,
                            timestamp: new Date().toISOString(),
                            variant: 'neon'
                        };
                        localStorage.setItem('gumshoe_saves', JSON.stringify(saves));
                        this.outputText(`Memory state saved locally as "${saveName}"! (Demo mode)`, 'success');
                        return true;
                    }

                    if (response.ok) {
                        this.outputText(`Memory state saved as "${saveName}"`, 'success');
                        return true;
                    } else {
                        // Fallback to local storage if server save fails
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '{}');
                        saves[saveName] = {
                            gameState: this.state,
                            timestamp: new Date().toISOString(),
                            variant: 'neon'
                        };
                        localStorage.setItem('gumshoe_saves', JSON.stringify(saves));
                        this.outputText(`Memory state saved locally as "${saveName}"! (Server unavailable)`, 'warning');
                        return true;
                    }
                } catch (error) {
                    console.error('Error saving game:', error);
                    // Fallback to local storage
                    try {
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '{}');
                        const saveName = args.length > 0 ? args.join(' ') : 'Auto Save';
                        saves[saveName] = {
                            gameState: this.state,
                            timestamp: new Date().toISOString(),
                            variant: 'neon'
                        };
                        localStorage.setItem('gumshoe_saves', JSON.stringify(saves));
                        this.outputText(`Memory state saved locally as "${saveName}"! (Network error)`, 'warning');
                        return true;
                    } catch (localError) {
                        this.outputText('Error saving game: ' + error.message, 'error');
                        return false;
                    }
                }
            },

            async loadGame(saveName) {
                try {
                    const authToken = localStorage.getItem('authToken');
                    if (!authToken) {
                        this.outputText("You must be logged in to load games.", 'error');
                        return false;
                    }

                    const response = await fetch(`${API_BASE_URL}/api/games/load/cyberpunk/${encodeURIComponent(saveName)}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        // Restore the full state, not just gameState
                        this.state = { ...this.state, ...data.gameState };
                        output.innerHTML = '';
                        this.outputText(`Memory state loaded: "${saveName}"`, 'success');
                        this.outputText("--- NEURAL STATE RESTORED ---", 'header');
                        this.outputText(`Location: ${this.getCurrentRoom().name}`, 'cyan');
                        this.outputText(`Credits: ${this.state.cash}`, 'cyan');
                        this.outputText(`Health: ${this.state.health}/5`, 'cyan');
                        this.outputText("", 'normal');
                        this.handleLook([]);
                        this.showStatus();
                        input.disabled = false;
                        return true;
                    } else {
                        const error = await response.json();
                        this.outputText(`Load failed: ${error.message}`, 'error');
                        return false;
                    }
                } catch (error) {
                    this.outputText(`Load failed: ${error.message}`, 'error');
                    return false;
                }
            },

            async listSaves() {
                try {
                    const authToken = localStorage.getItem('authToken');
                    if (!authToken) {
                        this.outputText("You must be logged in to list saves.", 'error');
                        return;
                    }

                    const response = await fetch(`${API_BASE_URL}/api/games/saves/cyberpunk`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (response.ok) {
                        const saves = await response.json();
                        this.outputText("--- YOUR SAVED MEMORY STATES ---", 'header');
                        if (saves.length === 0) {
                            this.outputText("No saved memory states found.", 'normal');
                        } else {
                            saves.forEach(save => {
                                const date = new Date(save.updated_at).toLocaleString();
                                this.outputText(`• ${save.save_name} (${date})`, 'cyan');
                            });
                        }
                        this.outputText("", 'normal');
                        this.outputText("Use 'load <save_name>' to restore a memory state.", 'green');
                    } else {
                        const error = await response.json();
                        this.outputText(`Failed to list saves: ${error.message}`, 'error');
                    }
                } catch (error) {
                    this.outputText(`Failed to list saves: ${error.message}`, 'error');
                }
            },

            async deleteSave(saveName) {
                try {
                    const authToken = localStorage.getItem('authToken');
                    if (!authToken) {
                        this.outputText("You must be logged in to delete saves.", 'error');
                        return false;
                    }

                    const response = await fetch(`${API_BASE_URL}/api/games/delete/cyberpunk/${encodeURIComponent(saveName)}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (response.ok) {
                        this.outputText(`Memory state "${saveName}" deleted successfully.`, 'success');
                        return true;
                    } else {
                        const error = await response.json();
                        this.outputText(`Delete failed: ${error.message}`, 'error');
                        return false;
                    }
                } catch (error) {
                    this.outputText(`Delete failed: ${error.message}`, 'error');
                    return false;
                }
            },

            // Enhanced command handlers
            handleSave(args) {
                const saveName = args.length > 0 ? args.join(' ') : 'Auto Save';
                this.saveGame(saveName);
                return 0;
            },

            handleLoad(args) {
                if (!args.length) {
                    this.outputText("Load which memory state? Use 'saves' to see available saves.", 'error');
                    return 0;
                }
                const saveName = args.join(' ');
                this.loadGame(saveName);
                return 0;
            },

            handleSaves() {
                this.listSaves();
                return 0;
            },

            handleDeleteSave(args) {
                if (!args.length) {
                    this.outputText("Delete which memory state? Use 'saves' to see available saves.", 'error');
                    return 0;
                }
                const saveName = args.join(' ');
                this.deleteSave(saveName);
                return 0;
            },

            handleAttack(args) {
                if (!args.length) {
                    this.outputText("Attack what?");
                    return 0;
                }
                
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, Object.keys(room.npcs || {}));
                
                if (!targetName) {
                    this.outputText(`You don't see ${args.join(' ')} here.`);
                    return 0;
                }
                
                // Combat system
                const playerStrength = this.state.attributes.strength;
                const targetStrength = Math.floor(Math.random() * 10) + 5; // NPC strength
                
                this.outputText(`You attack ${targetName}!`);
                
                if (playerStrength > targetStrength) {
                    this.outputText(`${targetName} is defeated! You gain experience.`);
                    this.state.gameState.experience = (this.state.gameState.experience || 0) + 10;
                    this.state.attributes.strength += 1;
                } else {
                    this.outputText(`${targetName} fights back! You take damage.`);
                    this.state.health -= 2;
                }
                
                if (this.state.health <= 0) {
                    this.outputText("You have been defeated!");
                    this.state.gameOver = true;
                }
                return 5;
            },

            handleEquip(args) {
                if (!args.length) {
                    this.outputText("Equip what?");
                    return 0;
                }
                
                const item = args.join(' ').toLowerCase();
                
                if (!this.state.inventory.includes(item)) {
                    this.outputText(`You don't have ${item}.`);
                    return 0;
                }
                
                // Check if item is a weapon by looking at game data
                const itemData = this.data.items[item];
                const isWeapon = itemData && (itemData.type === 'weapon' || itemData.damage || item.includes('gun') || item.includes('knife') || item.includes('bat') || item.includes('pipe') || item.includes('crowbar') || item.includes('pistol') || item.includes('laser') || item.includes('plasma') || item.includes('cyber') || item.includes('blade'));
                
                if (isWeapon) {
                    this.state.equippedWeapon = item;
                    this.outputText(`You equip ${item}.`);
                } else {
                    this.outputText(`${item} is not a weapon.`);
                }
                return 0;
            },

            handleUnequip() {
                if (this.state.equippedWeapon) {
                    this.outputText(`You unequip ${this.state.equippedWeapon}.`);
                    this.state.equippedWeapon = null;
                } else {
                    this.outputText("You're not equipping anything.");
                }
                return 0;
            },

            handleGive(args) {
                if (args.length < 2) {
                    this.outputText("Usage: give <item> to <npc>");
                    return 0;
                }
                
                const itemIndex = args.indexOf('to');
                if (itemIndex === -1 || itemIndex === 0 || itemIndex === args.length - 1) {
                    this.outputText("Usage: give <item> to <npc>");
                    return 0;
                }
                
                const item = args.slice(0, itemIndex).join(' ').toLowerCase();
                const npc = args.slice(itemIndex + 1).join(' ').toLowerCase();
                
                if (!this.state.inventory.includes(item)) {
                    this.outputText(`You don't have ${item}.`);
                    return 0;
                }
                
                const room = this.getCurrentRoom();
                
                if (!room.npcs || !Object.keys(room.npcs).includes(npc)) {
                    this.outputText(`You don't see ${npc} here.`);
                    return 0;
                }
                
                // Remove item from inventory
                const itemIndex_inv = this.state.inventory.indexOf(item);
                this.state.inventory.splice(itemIndex_inv, 1);
                
                this.outputText(`You give ${item} to ${npc}.`);
                
                // NPC reactions based on item
                if (item === 'credits' && npc === 'jax') {
                    this.outputText("Jax nods appreciatively. 'Thanks, choom. Maybe I can help you with some intel.'");
                    this.state.charisma += 1;
                } else if (item === 'energy_drink' && npc === 'jax') {
                    this.outputText("Jax smiles. 'A man after my own heart. What can I tell you?'");
                } else {
                    this.outputText(`${npc} accepts the ${item} but doesn't seem particularly interested.`);
                }
                return 0;
            }
        };

        // --- GAME DATA (STATIC) ---
        game.data = {
            worldMap: {
                '0,0,0': { name: "Your Office Module", baseDesc: "Your cramped office module, 30 stories up. The window is a screen, displaying a constant loop of flickering holoads for products you can't afford.", items: ["case_datachip", "synth_booze"], features: ["terminal", "hoload_projector", "exposed_conduits"]},
                '1,0,0': { name: "Doc Ryker's Ripperdoc Clinic", baseDesc: "A sterile, white room that smells of antiseptic and ozone. Surgical tools and cybernetic parts hang on the walls.", items: ["stim_pack"], npcs: {}},
                '0,-1,0': { name: "Main Street - OmniCorp Plaza", baseDesc: "The acid rain falls on the permacrete, reflecting the holographic signs of the city. Towering OmniCorp headquarters dominates the skyline.", features: ["maintenance_hatch"], npcs: {"glitch-head": "A glitch-head sits slumped against the alley wall, his old cyber-optic eye twitching. 'Spare some creds? I saw things... glowing things down at the OmniCorp docks.'"}, exitsOverride: {'d': [0, -1, -1]} },
                '0,-2,0': { name: "The Alley", baseDesc: "A dark alley reeking of ozone, synthetic ramen, and desperation. A waste reclamation unit hums in the corner. A torn poster advertises 'PADFOOT: The Great Adventure' - some kind of fantasy game.", items: ["news_slab"], features: ["waste_reclamation_unit"]},
                '-1,-2,0': { name: "The Glitchy Pixel Bar", baseDesc: "The bar is thick with synth-smoke. A glitchy holosign above the bar flickers between a dancing woman and a skull. A business card reads 'Dragon & Dungeon Investigations' - fantasy-themed detective work.", features: ["bar_console"]},
                '0,-3,0': { name: "Data Haven & Hardware", baseDesc: "The shop smells of burnt circuits. The counter is protected by a shimmering stasis-field, displaying outdated cyberdecks and second-hand chrome.", items: [], features: ["stasis-field_counter"]},
                '0,-4,0': { name: "OmniCorp Warehouse District", baseDesc: "Automated cargo drones hum in the gloom of the warehouse. OmniCorp crates are stacked to the ceiling.", items: ["encrypted_datapad"], features: ["crates", "barrels"]},
                '1,-4,0': { name: "The Docks", baseDesc: "The docks reek of salt and industrial waste. The dark water glows with bio-luminescent algae.", features: ["pier", "ships"]},
                '1,-4,-1': { name: "OmniCorp R&D Sub-level", baseDesc: "A sterile lab of chrome and polysteel. The air hums with the power of massive servers. An otherworldly energy emanates from the center of the room.", items: ["decryption_orb"], features: ["holographic_interface"]},
                '0,-1,-1': { name: "Maintenance Tunnels", baseDesc: "The conduit-choked tunnels beneath the city. Water drips from corroded pipes. Service drones scuttle past.", items: ["rusty_key"], features: ["conduits"]},
                '2,-1,0': { name: "Neon Casino", baseDesc: "The Neon Casino - all chrome and broken dreams. Card sharks and desperate gamblers fill the smoky interior.", features: ["slot_machines", "card_tables"]},
                '1,-3,0': { name: "Tech Shop", baseDesc: "A neon-lit tech shop selling the latest cyberware and gadgets.", features: ["tech_counter"]},
            },
            items: {
                "case_datachip": {
                    desc: "A matte-black datachip pulsing with encrypted data, your neural signature etched in quantum-resistant ink. 'NEON CITY AFFAIR' flickers in holographic script when you interface with it. The chip contains terabytes of case data - witness statements digitized from neural scans, security footage compressed to molecular density, financial trails that twist through a thousand shadow corporations. This isn't just evidence; it's a weapon in the endless war between flesh and data.",
                    takeable: true
                },
                "neon_times_article": {
                    desc: "A crumpled digital news-sheet from the Neon Times, its surface flickering with corporate propaganda and buried truths. The headline screams 'OmniCorp Announces Revolutionary Neural Interface Breakthrough' but the subtext tells a different story - whispers of missing researchers, unexplained power surges, and something about 'quantum consciousness transfer.' The article is written in the careful language of corporate doublespeak, but between the lines, you can read the real story: something went wrong, and they're covering it up.",
                    takeable: true,
                    lore: true
                },
                "data_ghost_manifesto": {
                    desc: "A fragment of encrypted text that materializes on your neural interface like a digital ghost. The words shift and reform as you read them, written in the language of the underground resistance. 'The corporations have stolen our souls, digitized our consciousness, and turned us into data streams in their vast machine. But we are not just data - we are the ghosts in the machine, the voices they cannot silence, the truth they cannot erase.' It's signed only with a symbol that looks like a circuit board crossed with a human skull.",
                    takeable: true,
                    lore: true
                },
                "corporate_memo": {
                    desc: "A classified corporate memo that somehow found its way into your possession, its surface marked with the highest security clearance. The text is heavily redacted, but you can make out fragments: 'Project Quantum Soul... unauthorized consciousness transfer... test subject #47... neural interface malfunction... containment breach...' The rest is blacked out, but the implications are clear - OmniCorp has been experimenting with something far more dangerous than they're willing to admit.",
                    takeable: true,
                    lore: true
                },
                "underground_newsletter": {
                    desc: "A hand-printed newsletter from the underground resistance, its pages stained with coffee and desperation. The articles tell stories the corporate media won't cover - disappearances in the warehouse district, strange lights in the sky, people who went in for 'routine neural upgrades' and never came back the same. The writing is passionate and raw, the voice of people who have nothing left to lose. It's a reminder that in this city of chrome and data, there are still humans fighting for their humanity.",
                    takeable: true,
                    lore: true
                },
                "synth_booze": {
                    desc: "A sleek matte-black canister of synthetic ethanol, the label glowing with neon warnings about neural degradation and synaptic burnout. The liquid inside is clear as distilled malice, engineered to bypass your liver entirely and go straight for your cerebral cortex. One sip and your thoughts fracture into a thousand data streams, memories bleeding into the ether. Corporate-designed oblivion in a bottle - cheap, effective, and utterly dehumanizing.",
                    takeable: true
                },
                "lockbox": {
                    desc: "A military-grade quantum lockbox the size of a human heart, its surface a fractal pattern of self-replicating encryption runes. The box resists all attempts at interface, its quantum state collapsing into infinite improbability whenever you get close. You can feel the weight of forbidden knowledge inside - corporate secrets that could crash entire economies, or perhaps something far more dangerous. The surface is warm, as if the data within is alive and fighting to stay contained.",
                    takeable: true
                },
                "encrypted_datapad": {
                    desc: "A thick slab of armored quantum crystal, heavy as a corporate executive's conscience. The screen flickers with encrypted data streams that dance just out of comprehension - financial records that rewrite themselves, personnel files that change names mid-sentence, security footage that shows events that never happened. OmniCorp encryption protocols weave through the data like parasitic code, protecting secrets that could topple boardrooms and shatter neural networks alike.",
                    takeable: true
                },
                "decryption_orb": {
                    desc: "A perfect sphere of quantum-entangled obsidian, warm as a lover's touch and humming with the harmonics of a thousand decrypted data streams. When you hold it, you see the code - not with your eyes, but with your mind. Neural pathways light up like neon highways, revealing patterns hidden in the chaos. This orb doesn't just decrypt data; it whispers secrets that were never meant to be known, showing you the ghosts in the machine and the monsters wearing corporate suits.",
                    takeable: true
                },
                "armored_trenchcoat": {
                    desc: "A masterpiece of synthetic biotechnology, your trenchcoat flows like liquid chrome over a skeleton of smart carbon fiber. Ballistic nanites weave through the fabric, hardening on impact while the surface displays adaptive camouflage - shifting from matte black in shadows to reflective chrome in neon light. Corporate logos are banned from its surface, but you know every thread carries the watermark of black market fabricators. This coat has saved your life more times than you can count, and it remembers every bullet, every blade, every betrayal.",
                    takeable: true
                },
                "news_slab": {
                    desc: "A flexible quantum crystal news-slate that unfolds like a predatory insect, its surface crawling with headlines that rewrite themselves as you watch. 'OmniCorp Announces Neural Enhancement Initiative' bleeds into 'Corporate Espionage Scandal Rocks Megacity' then dissolves into 'Power Surges Plague Warehouse District - Officials Baffled'. The article you seek is highlighted in pulsing red, buried beneath layers of corporate propaganda and synthetic outrage. Information is currency in this city, and this slab is counterfeit from the moment it's manufactured.",
                    takeable: true
                },
                "prybar": {
                    desc: "A length of quantum-hardened alloy that feels alive in your hand, its surface crawling with microcircuitry that amplifies your strength and dampens recoil. This isn't just a tool; it's a statement. One end crackles with electromagnetic force for shorting mag-locks, the other terminates in a fractal pattern that can crush bone or breach armor plating. Blood and lubricant stain the handle from previous owners, each mark telling a story of desperate entry and violent exit.",
                    takeable: true
                },
                "rusty_key": {
                    desc: "An antique physical key of machined steel, its teeth worn smooth by decades of use in a city that forgot what locks looked like before the digital age. It feels wrong in your augmented hands, a reminder of the flesh-and-blood world that birthed this chrome nightmare. The bow is stamped with a serial number that predates the corporate wars, and you wonder what forgotten vault or basement door it might still open. In a world of quantum encryption, this key is either utterly useless or dangerously powerful.",
                    takeable: true
                },
                "encryption_key": {
                    desc: "A thumbnail-sized quantum crystal pulsing with rainbow light, containing an encryption key so powerful it could theoretically crash entire corporate mainframes. The crystal is warm to the touch, and when you interface with it, you feel the weight of a thousand forbidden accesses - bank vaults opening, security systems standing down, corporate secrets laid bare. This key doesn't just unlock doors; it rewrites reality, bending digital physics to your will.",
                    takeable: true
                },
                "encrypted_note": {
                    desc: "A neural-imprint note that burns itself into your mind when you interface with it, the words searing like laser fire: 'The truth is not on the manifest, but in the glow.' The message is wrapped in layers of encryption that make your implants ache, suggesting it was written by someone who knew too much about corporate secrets and neural interfaces. The note self-destructs after reading, leaving only quantum ghosts in your memory and a certainty that you're now hunted by forces you can't even see.",
                    takeable: true
                },
                "data_slate": {
                    desc: "A grimy military-grade data slate that feels like it's been through more wars than you have, its surface scarred by plasma burns and neural feedback. The entries are encrypted in a code that shifts as you read it: 'Shipment 7B - Glowing cargo - Dock 3 - Midnight Cycle.' The slate warms dangerously when you interface, suggesting active countermeasures against unauthorized access. Whatever this shipment contains, it's valuable enough to kill for - or die protecting.",
                    takeable: true
                },
                "stim_pack": {
                    desc: "A disposable neural injector filled with synthetic endorphins and combat-grade stimulants, the casing glowing with biohazard warnings that your implants translate as 'Instant God Mode.' One press and your nervous system lights up like a christmas tree, pain receptors shutting down while reflexes hit superhuman speeds. The comedown is a bitch - neural burnout that leaves you twitching for hours - but in a firefight, it's the difference between breathing and becoming corporate property.",
                    takeable: true
                },
                "synthetic_cigs": {
                    desc: "A sleek pack of synthetic cigarettes that interface directly with your nervous system, delivering nicotine-laced pleasure directly to your brain while bypassing the carcinogenic mess of actual tobacco. The pack is matte black with neon accents, and each 'cigarette' is a molecular printer that fabricates the perfect smoke based on your neural profile. Your last vice in a world where everything else has been digitized, commodified, and weaponized. One drag and the city's chaos feels almost manageable.",
                    takeable: true
                },
                "neural_flashlight": {
                    desc: "A neural-linked flashlight that interfaces directly with your optic implants, painting the darkness with infrared overlays and threat detection algorithms. The device is a sleek cylinder of adaptive smart-matter that extends when activated, its beam cutting through smoke and shadows like a scalpel through flesh. Battery life is measured in neural capacity - use too much and you'll be seeing spots for days. In the undercity, light isn't just visibility; it's survival.",
                    takeable: true
                },
                "cyber_lockpicks": {
                    desc: "A velvet-lined neural interface case containing a set of quantum-entangled lockpicks that feel like extensions of your own nervous system. Each pick is a filament of smart carbon that reshapes itself based on your neural commands, dancing through tumblers and bypassing security algorithms with the precision of a concert pianist. These aren't tools; they're symbiotes. One wrong move and they could fry your implants, leaving you a drooling vegetable in the gutter.",
                    takeable: true
                },
                "cyber_crowbar": {
                    desc: "A hydraulic nightmare of chrome and ceramics, this crowbar interfaces with your neural implants to amplify your strength a hundredfold. The business end crackles with electromagnetic fields that can short out mag-locks or crush reinforced plasteel. Blood and hydraulic fluid stain the handle from previous owners, each mark a testament to the tool's brutal efficiency. In a world of energy weapons and smart bullets, sometimes you just need something you can feel breaking.",
                    takeable: true,
                    weapon_stats: {damage: 2, crit_chance: 0.05, special: "none", desc: "Hydraulic amplification. Crushes what won't yield."}
                },
                "energy_drink": {
                    desc: "A glowing canister of neon-green energy drink that promises 12 hours of uninterrupted productivity, backed by corporate guarantees and neural enhancement disclaimers. The liquid inside is a cocktail of synthetic caffeine, nootropic compounds, and experimental stimulants that rewire your brain chemistry on the molecular level. Corporate labs engineered this to keep wage slaves productive, but in the undercity, it's currency - a hit of clarity in a world gone mad with information overload.",
                    takeable: true
                },
            },
            features: {
                "terminal": { desc: "A battered neural interface console that looks like it's been through more corporate purges than you have, its surface scarred by plasma burns and emergency shutdowns. The screen flickers with ghost images from previous users - corporate memos that dissolved mid-sentence, security footage that looped eternally, personal messages that never reached their destinations. This terminal is your lifeline to the Net, a cracked window into the digital soul of the city. Interface with it and you become part of the endless data stream, neurons syncing with silicon in a dance as old as humanity itself." },
                "hoload_projector": { desc: "A glitchy holographic projector that cycles through OmniCorp advertisements like a malfunctioning fever dream, the air above it shimmering with half-formed corporate logos and smiling executive faces that melt into static. 'Upgrade Your Neural Implants Today!' dissolves into 'OmniCorp - Building Tomorrow's Citizens' which fractures into 'Neural Enhancement - Only 12 Payments!' The projector hums with failing capacitors, casting eerie blue light that makes shadows dance like ghosts in the machine. It's mesmerizing in its broken beauty, a testament to corporate overreach and technological decay." },
                "exposed_conduits": { desc: "A maintenance panel torn from the wall like flesh from bone, exposing the city's circulatory system - fiber-optic cables pulsing with data streams, power conduits crackling with barely contained electricity, coolant pipes weeping condensation that pools in rainbow slicks of chemical runoff. The air here smells of ozone and burning insulation, and you can hear the distant hum of servers processing transactions that could topple governments. One wrong touch and you could fry your implants, becoming just another statistic in the city's endless cycle of upgrade and obsolescence." },
                "maintenance_hatch": { desc: "A heavy mag-sealed hatch that squats in the floor like a predatory insect, its surface etched with warning holograms that project directly into your optic implants: 'AUTHORIZED PERSONNEL ONLY - NEURAL SCAN REQUIRED - LETHAL FORCE AUTHORIZED'. The seal is military-grade, designed to withstand everything from corporate sabotage to street-level riots. Behind it lies the city's underbelly - maintenance tunnels where drones scuttle like mechanical rats and forgotten systems hum with barely contained power. Open it and you enter a world where the city's secrets are written in code and coolant." },
                "waste_reclamation_unit": { desc: "A hulking industrial monstrosity that converts the city's organic waste into nutrient paste for the underclass, its surface gleaming with false sterility while vents belch steam scented with the ghosts of a thousand processed meals. The machine hums with servos and chemical processors, reducing humanity to its basest components - proteins, fats, carbohydrates - all neatly packaged for consumption. The smell is overwhelming, a reminder that in this city, nothing is wasted and no one is sacred. Even death feeds the corporate machine." },
                "bar_console": { desc: "A neural interface console inset into the bar's surface like a embedded tumor, its edges fused with the synthetic wood through some unholy process of molecular bonding. The interface glows with biometric warnings and corporate disclaimers, promising secure transactions while logging every credit you spend. Scars from spilled drinks and neural feedback burns crisscross its surface, each mark telling a story of desperate deals and broken promises. This console doesn't just serve drinks; it serves as witness to the city's endless cycle of consumption and regret." },
                "stasis-field_counter": { desc: "A shimmering stasis field that warps the air like heat haze over a fusion reactor, protecting high-value merchandise behind an impenetrable wall of quantum-locked energy. The field crackles with micro-discharges that paint the air with ionized particles, and security drones hover nearby, their red eyes scanning for threats. Behind the field: synthetic cigarettes that interface with your nervous system (5 creds), cyber crowbars that amplify your strength (25 creds), neural flashlights that paint reality in infrared (15 creds). The field doesn't just protect merchandise; it protects the illusion that anything in this city can be bought." },
                "crates": { desc: "Towering stacks of OmniCorp shipping containers that loom like corporate monoliths, their surfaces etched with fractal serial numbers that shift when you're not looking directly at them. Each crate pulses with internal sensors and environmental controls, maintaining whatever precious cargo lies within at optimal conditions. The air around them hums with containment fields and security algorithms, and you wonder what forbidden technologies or experimental subjects they might contain. In a city built on secrets, these crates are the ultimate question marks." },
                "barrels": { desc: "Rusted industrial barrels that squat in the shadows like forgotten experiments, their surfaces corroded by acids that eat through metal and memory alike. The contents slosh ominously when disturbed, releasing vapors that make your implants glitch and your skin crawl. Warning labels peel away to reveal corporate disclaimers about 'proprietary compounds' and 'experimental waste,' but you know better - these barrels contain the dark side of progress, the toxic runoff of a civilization that's traded its soul for chrome and circuit boards. One leak and the neighborhood becomes a biohazard zone." },
                "pier": { desc: "A decaying pier that extends into the neon-stained harbor like a gangrenous limb, its pylons reinforced with smart alloys that groan under the weight of corporate indifference. The water below glows with bioluminescent pollution and discarded neural implants, while cargo drones buzz overhead like mechanical mosquitoes. The pier creaks with every wave, telling stories of ships that arrived full and left empty, of deals made in shadows and promises broken at dawn. This pier has seen more betrayals than any confessional, and it remembers every one." },
                "ships": { desc: "Silhouettes of autonomous cargo vessels riding low in the water, their hulls a patchwork of adaptive camouflage that shifts with the neon light. Navigation beacons pulse with encrypted signals, while drone swarms orbit protectively overhead. These ships don't carry cargo; they carry corporate secrets, experimental technologies, and the hopes of people desperate enough to trust the waves over the corporations. One of them might hold the answers you seek, or perhaps just another layer of deception in the city's endless game of nested lies." },
                "holographic_interface": { desc: "An otherworldly holographic interface that pulses with quantum-entangled light, casting impossible shadows that don't quite align with the physical world. The interface doesn't display data so much as concepts - ideas that burn themselves into your neural pathways, promising enlightenment or damnation depending on your implants' security settings. The hologram shifts through spectra invisible to baseline humans, revealing data streams and hidden broadcasts that only the enhanced can perceive. This interface isn't a tool; it's a gateway to digital realms where the laws of physics bend to corporate will." },
                "conduits": { desc: "Thick bundles of smart conduits that snake along the tunnel walls like mechanical veins, pulsing with data streams and coolant flows that synchronize with your neural implants. Fiber-optic cables whisper corporate secrets as you pass, while power conduits hum with barely contained electricity that makes your skin tingle. Condensation drips in rhythmic patterns, each drop containing trace amounts of experimental compounds designed to enhance or destroy depending on the dosage. These conduits aren't just infrastructure; they're the city's nervous system, carrying impulses that could topple regimes or birth new realities." },
            },
            npcStats: { 
                "Jax": {willpower: 12, insight: 10, strength: 14, personality: "gruff_but_loyal", cyberware: "mismatched_arm", background: "ex_corp_security"},
                "Izzy": {willpower: 14, insight: 12, strength: 8, personality: "shrewd_merchant", cyberware: "neural_interface", background: "data_broker"},
                "Johnny": {willpower: 8, insight: 15, strength: 12, personality: "desperate_info_dealer", cyberware: "overloaded_implants", background: "street_hacker"},
                "glitch-head": {willpower: 6, insight: 8, strength: 8, personality: "malfunctioning_cyber", cyberware: "failing_optic", background: "neural_feedback_victim"},
                "corp-sec": {willpower: 16, insight: 11, strength: 15, personality: "corporate_drone", cyberware: "military_grade", background: "omnicorp_security"},
                "Oracle": {willpower: 20, insight: 20, strength: 0, personality: "mystical_ai", cyberware: "quantum_processing", background: "digital_entity"},
                "Doc_Ryker": {willpower: 15, insight: 18, strength: 10, personality: "mad_scientist", cyberware: "surgical_implants", background: "ripperdoc_surgeon"},
                "Neon_Queen": {willpower: 18, insight: 16, strength: 12, personality: "cyberpunk_royalty", cyberware: "luxury_enhancements", background: "underground_leader"},
                "Data_Phantom": {willpower: 13, insight: 19, strength: 9, personality: "digital_ghost", cyberware: "stealth_implants", background: "corporate_whistleblower"},
                "Chrome_Angel": {willpower: 17, insight: 14, strength: 13, personality: "cyberpunk_warrior", cyberware: "combat_enhancements", background: "street_samurai"}
            },
            npcSchedules: {
                "Jax": { "18,24": "The Glitchy Pixel Bar", "0,4": "The Glitchy Pixel Bar" },
                "Izzy": { "9,17": "Data Haven & Hardware" },
                "corp-sec": { "0,24": "Warehouse District" },
                "glitch-head": { "0,24": "Main Street" },
                "Johnny": { "20,24": "The Docks", "0,5": "The Docks" },
                "Doc_Ryker": { "0,24": "Doc Ryker's Ripperdoc Clinic" },
                "Neon_Queen": { "22,24": "Neon Casino", "0,2": "Neon Casino" },
                "Data_Phantom": { "2,6": "Maintenance Tunnels", "14,18": "Tech Shop" },
                "Chrome_Angel": { "12,16": "Main Street", "20,24": "The Docks" },
            },
            getNpcDesc: (npc) => ({
                "Jax": "Jax the bartender looms behind the counter like a chrome-plated mountain, his mismatched cybernetic arm whirring softly as he polishes a glass with surgical precision. The arm's servos click and whine with each movement, a symphony of corporate engineering gone slightly wrong. His remaining organic eye scans you with the practiced paranoia of someone who's survived too many corporate purges, while his cybernetic replacement glows with the cold blue light of OmniCorp's neural interface protocols. 'What's your poison, choom? We got everything from synthetic ethanol to neural enhancement cocktails that'll make you forget your own name.'",
                "Izzy": "Izzy the data broker materializes from the shadows behind her stasis-field counter like a ghost in the machine, her neural implants casting flickering holographic displays across her face. She's a walking testament to the city's obsession with augmentation - chrome fingers that dance across invisible interfaces, optic implants that see through walls, and a data port in her temple that pulses with the rhythm of encrypted transactions. Her smile is all business, but her eyes hold the weight of secrets that could topple boardrooms. 'Buying or selling data, edgerunner? I got corporate secrets, black market intel, and enough dirty laundry to bury half the executives in this city. Or maybe you're in the market for some second-hand chrome? Fresh from the last poor bastard who thought he could outrun corporate security.'",
                "Johnny": "Johnny the info-leech slithers from the shadows like a digital wraith, his optical implants glowing with the sickly green light of stolen corporate data streams. He's a walking contradiction - part human, part machine, all desperation. His neural interface is a patchwork of black market upgrades and jury-rigged corporate tech, held together with spit and prayer. The air around him crackles with electromagnetic interference from his overloaded implants, and you can hear the soft whine of cooling fans struggling to keep his brain from cooking itself. 'Got some creds, I got some data. Corporate secrets, security protocols, personnel files that'll make your head spin. But information ain't free in this city, choom. Everything's got a price, and I'm the guy who collects.'",
                "glitch-head": "A glitch-head named Sparks sits slumped against the alley wall like a discarded piece of corporate hardware, his old cyber-optic eye twitching and sparking with digital interference. The implant is clearly malfunctioning, its red glow flickering between normal vision and some nightmare spectrum that shows you things that shouldn't exist. His remaining organic eye is bloodshot and wild, darting between you and shadows that only he can see. Neural feedback has left him twitching and mumbling, his speech patterns glitching like corrupted data. 'Spare some creds, choom? I saw things... glowing things down at the OmniCorp docks. Things that weren't supposed to be there. The data streams... they were wrong. Wrong in ways that make my implants ache just thinking about it. They're hiding something down there, something that makes the corporate suits nervous.'",
                "corp-sec": "An OmniCorp security cyborg stands like a chrome-plated sentinel, its optical sensor scanning the area with the cold efficiency of corporate programming. The unit's design is a masterpiece of intimidation - matte black armor plating, neural interface ports that pulse with encrypted data streams, and weapon systems that hum with barely contained energy. Its voice is a synthetic approximation of human speech, but there's no warmth, no humanity in its tone. 'Restricted Area. OmniCorp property. Unauthorized access will result in immediate termination. Neural scan required for entry. Lethal force authorized.' The cyborg's stance never changes, but you can feel the weight of its targeting systems locking onto your biometric signature.",
                "Oracle": "A holographic construct shimmers into existence like a ghost in the machine, its form shifting between human and pure data stream. The Oracle exists in the space between reality and digital space, a quantum entity that speaks in riddles and truths that cut deeper than any blade. Its voice echoes with the harmonics of a thousand processed queries, each word carrying the weight of corporate secrets and forbidden knowledge. 'The answer you seek is not in the query you make, but in the path you've walked to get here. In this city of chrome and data, truth is the rarest commodity, and those who possess it rarely survive long enough to share it. The glowing orb you hunt is not what it appears to be - it is both the key and the lock, the question and the answer, the beginning and the end of everything.'",
                "Doc_Ryker": "Doc Ryker emerges from the shadows of his ripperdoc clinic like a surgeon from a nightmare, his bloody apron stained with the fluids of a hundred cybernetic operations. His hands are steady despite the tremors that occasionally wrack his frame - the price of too many neural interface experiments gone wrong. The clinic around him is a testament to his trade: surgical tables gleaming with chrome and blood, neural interface rigs that hum with dangerous energy, and a wall of preserved cybernetic organs that pulse with artificial life. 'Need an upgrade, choom? Or maybe just patching up after a run-in with corporate security? I got everything from basic neural interfaces to experimental chrome that'll make you faster, stronger, smarter. But remember - every piece of metal you put in your body is another piece of your soul you're trading away. In this city, the price of power is always paid in flesh.'",
                "Neon_Queen": "The Neon Queen materializes from the casino's holographic displays like a goddess of chrome and neon, her form shifting between solid and pure light. She's the underground's most powerful information broker, her neural implants interfacing with every data stream in the city. Her eyes glow with the cold fire of quantum processors, and her voice carries the weight of a thousand corporate secrets. 'Welcome to my domain, edgerunner. In this city of lies and chrome, I am the only truth that matters. The glowing orb you seek? It's not what the corporations want you to think it is. It's the key to everything - past, present, and future. But knowledge like that comes with a price that most aren't willing to pay.'",
                "Data_Phantom": "A figure materializes from the shadows like a ghost in the machine, their form flickering between solid and digital static. The Data Phantom is a legend in the undercity - a corporate whistleblower who escaped with their life but lost their humanity in the process. Their neural interface is a masterpiece of stealth technology, allowing them to move through the city's data streams like a phantom. 'You're hunting the truth, aren't you? The glowing orb is just the beginning. OmniCorp has been experimenting with quantum consciousness transfer - they're trying to digitize human souls. The orb contains the first successful transfer, but the subject... the subject is still screaming. Still trapped in digital hell. You want to help them? You'll need to break into the most secure facility in the city.'",
                "Chrome_Angel": "A chrome-plated warrior emerges from the neon-lit shadows, their combat enhancements gleaming with the cold light of corporate engineering. The Chrome Angel is a street samurai who's survived more corporate wars than most people have lived years, their body a testament to the price of power in the undercity. Their neural interface hums with combat protocols, and their eyes scan you with the precision of targeting systems. 'You're looking for trouble, choom? Or maybe you're looking for answers about that glowing orb? I've seen what it can do - watched it turn corporate security into digital ghosts, watched it rewrite reality itself. It's not a weapon. It's not a tool. It's a gateway to something that shouldn't exist. And if you're not careful, it'll consume you just like it consumed everyone else who got too close.'"
            }[npc] || "")
        };

        // --- EVENT LISTENERS ---
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const command = input.value.trim();
                if (command) {
                    game.processCommand(command);
                    input.value = '';
                }
            }
        });
        
        // Menu button event listeners
        document.getElementById('new-game-btn').addEventListener('click', () => {
            if (confirm("Are you sure? Any unsaved progress will be lost.")) {
                document.getElementById('menu-overlay').classList.add('hidden');
                game.init();
            }
        });
        
        document.getElementById('load-game-btn').addEventListener('click', () => {
            document.getElementById('menu-overlay').classList.add('hidden');
            game.loadGame();
        });
        
        newGameBtn.addEventListener('click', () => {
             if (confirm("Are you sure? Any unsaved memory will be wiped.")) game.init();
        });
        saveGameBtn.addEventListener('click', () => game.saveGame());
        loadGameBtn.addEventListener('click', () => game.loadGame());

        // --- START GAME ---
        // Don't auto-init - wait for user to click NEW GAME
        // game.init();
        
        // Performance optimization: Preload critical assets
        const preloadImages = () => {
            const images = ['./neon_background.png', './neon_menu.png'];
            images.forEach(src => {
                const img = new Image();
                img.onload = () => console.log(`✅ Preloaded: ${src}`);
                img.onerror = () => console.warn(`⚠️ Failed to preload: ${src}`);
                img.src = src;
            });
        };
        preloadImages();
        
        // Enhanced error handling
        window.addEventListener('error', (e) => {
            console.error('🚨 Game Error:', e.error);
            if (e.error && e.error.message.includes('Unexpected token')) {
                console.error('💡 Syntax error detected - check console for details');
            }
        });
        
        // Unhandled promise rejection handling
        window.addEventListener('unhandledrejection', (e) => {
            console.error('🚨 Unhandled Promise Rejection:', e.reason);
        });
        
        // Advanced keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        game.saveGame();
                        break;
                    case 'l':
                        e.preventDefault();
                        game.loadGame();
                        break;
                    case 'n':
                        e.preventDefault();
                        if (confirm("Start a new game?")) game.init();
                        break;
                }
            }
        });
        
        // Auto-save functionality
        let autoSaveInterval;
        const startAutoSave = () => {
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            autoSaveInterval = setInterval(() => {
                if (game.state && !game.state.gameOver) {
                    game.saveGame('Auto Save');
                    console.log('💾 Auto-saved game');
                }
            }, 300000); // Auto-save every 5 minutes
        };
        
        // Advanced game analytics and telemetry
        const gameAnalytics = {
            startTime: Date.now(),
            actions: [],
            errors: [],
            performance: {
                loadTime: 0,
                renderTime: 0,
                memoryUsage: 0
            },
            
            trackAction: function(action, data = {}) {
                this.actions.push({
                    timestamp: Date.now(),
                    action: action,
                    data: data,
                    gameTime: Date.now() - this.startTime
                });
                console.log(`📊 Action tracked: ${action}`, data);
            },
            
            trackError: function(error, context = '') {
                this.errors.push({
                    timestamp: Date.now(),
                    error: error.message || error,
                    context: context,
                    stack: error.stack || ''
                });
                console.error(`📊 Error tracked: ${error.message || error}`, context);
            },
            
            getStats: function() {
                return {
                    totalPlayTime: Date.now() - this.startTime,
                    actionCount: this.actions.length,
                    errorCount: this.errors.length,
                    performance: this.performance
                };
            }
        };
        
        // Track game initialization
        gameAnalytics.trackAction('game_loaded', { gameType: 'neon' });
        
        // Advanced cheat codes and debug commands
        const cheatCodes = {
            'godmode': () => {
                game.state.health = 999;
                game.state.stress = 0;
                game.state.hunger = 0;
                game.output('🔓 God mode activated!');
                gameAnalytics.trackAction('cheat_used', { code: 'godmode' });
            },
            'money': () => {
                game.state.cash = 99999;
                game.output('💰 Money cheat activated!');
                gameAnalytics.trackAction('cheat_used', { code: 'money' });
            },
            'teleport': (location) => {
                if (location && game.data.worldMap[location]) {
                    game.state.position = location;
                    game.output(`🚀 Teleported to ${location}!`);
                    gameAnalytics.trackAction('cheat_used', { code: 'teleport', location: location });
                } else {
                    game.output('❌ Invalid location for teleport!');
                }
            },
            'stats': () => {
                const stats = gameAnalytics.getStats();
                game.output(`📊 Game Stats: Play Time: ${Math.round(stats.totalPlayTime/1000)}s, Actions: ${stats.actionCount}, Errors: ${stats.errorCount}`);
            }
        };
        
        // Advanced achievement system
        const achievements = {
            'first_command': { name: 'First Steps', description: 'Execute your first command', unlocked: false },
            'explorer': { name: 'Explorer', description: 'Visit 10 different locations', unlocked: false, progress: 0 },
            'social_butterfly': { name: 'Social Butterfly', description: 'Talk to 5 different NPCs', unlocked: false, progress: 0 },
            'hacker': { name: 'Hacker', description: 'Successfully hack 3 systems', unlocked: false, progress: 0 },
            'survivor': { name: 'Survivor', description: 'Play for 30 minutes', unlocked: false, progress: 0 }
        };
        
        const checkAchievements = () => {
            // Check first command
            if (!achievements.first_command.unlocked && gameAnalytics.actions.length >= 1) {
                achievements.first_command.unlocked = true;
                game.output('🏆 Achievement Unlocked: First Steps!');
            }
            
            // Check explorer achievement
            const uniqueLocations = new Set(gameAnalytics.actions
                .filter(a => a.action === 'command_executed' && a.data.command.startsWith('go '))
                .map(a => a.data.command.split(' ')[1]));
            achievements.explorer.progress = uniqueLocations.size;
            if (!achievements.explorer.unlocked && achievements.explorer.progress >= 10) {
                achievements.explorer.unlocked = true;
                game.output('🏆 Achievement Unlocked: Explorer!');
            }
            
            // Check social butterfly
            const talkedNPCs = new Set(gameAnalytics.actions
                .filter(a => a.action === 'command_executed' && a.data.command.startsWith('talk to '))
                .map(a => a.data.command.split(' ').slice(2).join(' ')));
            achievements.social_butterfly.progress = talkedNPCs.size;
            if (!achievements.social_butterfly.unlocked && achievements.social_butterfly.progress >= 5) {
                achievements.social_butterfly.unlocked = true;
                game.output('🏆 Achievement Unlocked: Social Butterfly!');
            }
            
            // Check survivor
            const playTime = gameAnalytics.getStats().totalPlayTime;
            achievements.survivor.progress = Math.floor(playTime / 60000); // minutes
            if (!achievements.survivor.unlocked && achievements.survivor.progress >= 30) {
                achievements.survivor.unlocked = true;
                game.output('🏆 Achievement Unlocked: Survivor!');
            }
        };
        
        // Check achievements every 10 actions
        let actionCount = 0;
        const originalTrackAction = gameAnalytics.trackAction;
        gameAnalytics.trackAction = function(action, data) {
            originalTrackAction.call(this, action, data);
            actionCount++;
            if (actionCount % 10 === 0) {
                checkAchievements();
            }
        };
        
        // Advanced AI-driven NPC behavior system
        const npcAI = {
            personalities: new Map(),
            relationships: new Map(),
            memory: new Map(),
            
            initializePersonality: function(npcName) {
                const personalities = ['friendly', 'hostile', 'neutral', 'mysterious', 'helpful', 'deceptive'];
                const personality = personalities[Math.floor(Math.random() * personalities.length)];
                this.personalities.set(npcName, personality);
                game.output(`🤖 ${npcName} personality: ${personality}`);
            },
            
            updateRelationship: function(npcName, change) {
                const current = this.relationships.get(npcName) || 0;
                const newValue = Math.max(-100, Math.min(100, current + change));
                this.relationships.set(npcName, newValue);
                game.output(`💭 Relationship with ${npcName}: ${newValue > 0 ? '+' : ''}${newValue}`);
            },
            
            rememberInteraction: function(npcName, interaction) {
                if (!this.memory.has(npcName)) {
                    this.memory.set(npcName, []);
                }
                this.memory.get(npcName).push({
                    timestamp: Date.now(),
                    interaction: interaction
                });
            },
            
            getResponse: function(npcName, playerAction) {
                const personality = this.personalities.get(npcName) || 'neutral';
                const relationship = this.relationships.get(npcName) || 0;
                const memories = this.memory.get(npcName) || [];
                
                // AI-driven response based on personality, relationship, and memory
                let response = '';
                
                if (personality === 'friendly') {
                    response = relationship > 50 ? 
                        "I'm so glad to see you again! How can I help?" :
                        "Hello there! Nice to meet you!";
                } else if (personality === 'hostile') {
                    response = relationship < -50 ?
                        "You again! Get away from me!" :
                        "What do you want? I don't have time for this.";
                } else if (personality === 'mysterious') {
                    response = "The shadows whisper your name... what secrets do you seek?";
                } else if (personality === 'helpful') {
                    response = "I might be able to help you with that. What do you need?";
                } else if (personality === 'deceptive') {
                    response = "Oh, I'm sure I can help you... for a price.";
                } else {
                    response = "I'm not sure what you want from me.";
                }
                
                // Remember this interaction
                this.rememberInteraction(npcName, playerAction);
                
                return response;
            }
        };
        
        // Advanced weather and time system
        const weatherSystem = {
            currentWeather: 'clear',
            timeOfDay: 'day',
            temperature: 72,
            
            updateWeather: function() {
                const weathers = ['clear', 'rainy', 'foggy', 'stormy', 'overcast'];
                this.currentWeather = weathers[Math.floor(Math.random() * weathers.length)];
                
                // Update temperature based on weather
                if (this.currentWeather === 'rainy') this.temperature = 65;
                else if (this.currentWeather === 'stormy') this.temperature = 60;
                else if (this.currentWeather === 'foggy') this.temperature = 55;
                else this.temperature = 72;
                
                game.output(`🌤️ Weather changed to: ${this.currentWeather} (${this.temperature}°F)`);
            },
            
            updateTime: function() {
                const times = ['dawn', 'day', 'dusk', 'night'];
                const currentIndex = times.indexOf(this.timeOfDay);
                this.timeOfDay = times[(currentIndex + 1) % times.length];
                
                game.output(`🕐 Time changed to: ${this.timeOfDay}`);
            },
            
            getWeatherEffect: function() {
                if (this.currentWeather === 'rainy') {
                    return "The rain makes everything look more mysterious and dangerous.";
                } else if (this.currentWeather === 'foggy') {
                    return "The fog obscures your vision, making it hard to see details.";
                } else if (this.currentWeather === 'stormy') {
                    return "The storm rages overhead, creating an ominous atmosphere.";
                } else if (this.currentWeather === 'overcast') {
                    return "The overcast sky casts everything in a dull, gray light.";
                } else {
                    return "The clear sky provides good visibility.";
                }
            }
        };
        
        // Advanced inventory management system
        const inventorySystem = {
            maxWeight: 100,
            currentWeight: 0,
            items: new Map(),
            
            addItem: function(item, weight = 1) {
                if (this.currentWeight + weight > this.maxWeight) {
                    game.output(`❌ Too heavy! Cannot carry ${item}.`);
                    return false;
                }
                
                this.items.set(item, (this.items.get(item) || 0) + 1);
                this.currentWeight += weight;
                game.output(`✅ Added ${item} to inventory. Weight: ${this.currentWeight}/${this.maxWeight}`);
                return true;
            },
            
            removeItem: function(item, weight = 1) {
                if (!this.items.has(item) || this.items.get(item) <= 0) {
                    game.output(`❌ You don't have ${item}.`);
                    return false;
                }
                
                this.items.set(item, this.items.get(item) - 1);
                this.currentWeight -= weight;
                if (this.items.get(item) <= 0) {
                    this.items.delete(item);
                }
                game.output(`✅ Removed ${item} from inventory. Weight: ${this.currentWeight}/${this.maxWeight}`);
                return true;
            },
            
            getInventory: function() {
                if (this.items.size === 0) {
                    return "Your inventory is empty.";
                }
                
                let inventory = "📦 INVENTORY:\n";
                for (const [item, count] of this.items) {
                    inventory += `  ${item} (${count})\n`;
                }
                inventory += `\nWeight: ${this.currentWeight}/${this.maxWeight}`;
                return inventory;
            }
        };
        
        // Add weather and time commands
        const originalProcessCommandWeather = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'weather') {
                game.output(`🌤️ Current weather: ${weatherSystem.currentWeather} (${weatherSystem.temperature}°F)`);
                game.output(weatherSystem.getWeatherEffect());
                return;
            } else if (lowerCommand === 'time') {
                game.output(`🕐 Current time: ${weatherSystem.timeOfDay}`);
                return;
            } else if (lowerCommand === 'change weather') {
                weatherSystem.updateWeather();
                return;
            } else if (lowerCommand === 'change time') {
                weatherSystem.updateTime();
                return;
            } else if (lowerCommand === 'inventory') {
                game.output(inventorySystem.getInventory());
                return;
            }
            
            return originalProcessCommandWeather.call(this, command);
        };
        
        // Advanced combat system with tactical elements
        const combatSystem = {
            isInCombat: false,
            currentEnemy: null,
            combatTurn: 0,
            combatActions: ['attack', 'defend', 'flee', 'use_item'],
            
            startCombat: function(enemy) {
                this.isInCombat = true;
                this.currentEnemy = enemy;
                this.combatTurn = 0;
                game.output(`⚔️ COMBAT STARTED!`);
                game.output(`You are fighting: ${enemy.name}`);
                game.output(`Health: ${enemy.health}/${enemy.maxHealth}`);
                game.output(`Available actions: ${this.combatActions.join(', ')}`);
            },
            
            processCombatTurn: function(playerAction) {
                if (!this.isInCombat) return;
                
                this.combatTurn++;
                game.output(`\n--- TURN ${this.combatTurn} ---`);
                
                // Player action
                if (playerAction === 'attack') {
                    const damage = Math.floor(Math.random() * 20) + 10;
                    this.currentEnemy.health -= damage;
                    game.output(`You attack for ${damage} damage!`);
                } else if (playerAction === 'defend') {
                    game.output(`You take a defensive stance.`);
                } else if (playerAction === 'flee') {
                    if (Math.random() < 0.7) {
                        game.output(`You successfully flee from combat!`);
                        this.endCombat();
                        return;
                    } else {
                        game.output(`You fail to flee!`);
                    }
                }
                
                // Check if enemy is defeated
                if (this.currentEnemy.health <= 0) {
                    game.output(`🎉 You defeated ${this.currentEnemy.name}!`);
                    this.endCombat();
                    return;
                }
                
                // Enemy action
                const enemyAction = this.combatActions[Math.floor(Math.random() * this.combatActions.length)];
                if (enemyAction === 'attack') {
                    const damage = Math.floor(Math.random() * 15) + 5;
                    game.state.health -= damage;
                    game.output(`${this.currentEnemy.name} attacks for ${damage} damage!`);
                } else if (enemyAction === 'defend') {
                    game.output(`${this.currentEnemy.name} takes a defensive stance.`);
                }
                
                // Check if player is defeated
                if (game.state.health <= 0) {
                    game.output(`💀 You have been defeated!`);
                    this.endCombat();
                    return;
                }
                
                game.output(`Your health: ${game.state.health}`);
                game.output(`Enemy health: ${this.currentEnemy.health}`);
            },
            
            endCombat: function() {
                this.isInCombat = false;
                this.currentEnemy = null;
                this.combatTurn = 0;
                game.output(`⚔️ Combat ended.`);
            }
        };
        
        // Advanced quest system
        const questSystem = {
            activeQuests: new Map(),
            completedQuests: new Set(),
            questRewards: new Map(),
            
            addQuest: function(questId, questData) {
                this.activeQuests.set(questId, {
                    ...questData,
                    status: 'active',
                    progress: 0,
                    maxProgress: questData.maxProgress || 1
                });
                game.output(`📋 New quest: ${questData.name}`);
                game.output(`Description: ${questData.description}`);
            },
            
            updateQuestProgress: function(questId, progress = 1) {
                if (!this.activeQuests.has(questId)) return;
                
                const quest = this.activeQuests.get(questId);
                quest.progress += progress;
                
                if (quest.progress >= quest.maxProgress) {
                    this.completeQuest(questId);
                } else {
                    game.output(`📋 Quest progress: ${quest.progress}/${quest.maxProgress}`);
                }
            },
            
            completeQuest: function(questId) {
                const quest = this.activeQuests.get(questId);
                if (!quest) return;
                
                quest.status = 'completed';
                this.completedQuests.add(questId);
                this.activeQuests.delete(questId);
                
                game.output(`🎉 Quest completed: ${quest.name}`);
                
                // Give rewards
                if (quest.rewards) {
                    quest.rewards.forEach(reward => {
                        if (reward.type === 'experience') {
                            game.state.experience += reward.amount;
                            game.output(`+${reward.amount} experience`);
                        } else if (reward.type === 'item') {
                            inventorySystem.addItem(reward.item, reward.weight || 1);
                        } else if (reward.type === 'money') {
                            game.state.cash += reward.amount;
                            game.output(`+$${reward.amount}`);
                        }
                    });
                }
            },
            
            listQuests: function() {
                if (this.activeQuests.size === 0) {
                    game.output(`📋 No active quests.`);
                    return;
                }
                
                game.output(`📋 ACTIVE QUESTS:`);
                for (const [id, quest] of this.activeQuests) {
                    game.output(`  ${quest.name}: ${quest.progress}/${quest.maxProgress}`);
                }
            }
        };
        
        // Advanced crafting system
        const craftingSystem = {
            recipes: new Map(),
            materials: new Map(),
            
            addRecipe: function(itemName, materials, result) {
                this.recipes.set(itemName, { materials, result });
            },
            
            canCraft: function(itemName) {
                const recipe = this.recipes.get(itemName);
                if (!recipe) return false;
                
                for (const [material, amount] of recipe.materials) {
                    if (!inventorySystem.items.has(material) || 
                        inventorySystem.items.get(material) < amount) {
                        return false;
                    }
                }
                return true;
            },
            
            craftItem: function(itemName) {
                const recipe = this.recipes.get(itemName);
                if (!recipe) {
                    game.output(`❌ Unknown recipe: ${itemName}`);
                    return false;
                }
                
                if (!this.canCraft(itemName)) {
                    game.output(`❌ Not enough materials to craft ${itemName}`);
                    return false;
                }
                
                // Consume materials
                for (const [material, amount] of recipe.materials) {
                    inventorySystem.removeItem(material, 1);
                }
                
                // Add result
                inventorySystem.addItem(recipe.result, 1);
                game.output(`🔨 Crafted ${recipe.result}!`);
                return true;
            },
            
            listRecipes: function() {
                game.output(`🔨 AVAILABLE RECIPES:`);
                for (const [name, recipe] of this.recipes) {
                    const canCraft = this.canCraft(name) ? '✅' : '❌';
                    game.output(`  ${canCraft} ${name}: ${recipe.result}`);
                }
            }
        };
        
        // Add some default recipes
        craftingSystem.addRecipe('health_potion', [['herbs', 2], ['water', 1]], 'Health Potion');
        craftingSystem.addRecipe('lockpick', [['metal', 1], ['wire', 1]], 'Lockpick');
        craftingSystem.addRecipe('smoke_bomb', [['chemicals', 1], ['cloth', 1]], 'Smoke Bomb');
        
        // Add combat, quest, and crafting commands
        const originalProcessCommandAdvanced = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'combat') {
                if (combatSystem.isInCombat) {
                    game.output(`⚔️ Currently in combat! Use: attack, defend, flee`);
                } else {
                    game.output(`⚔️ Not in combat. Use 'attack [enemy]' to start combat.`);
                }
                return;
            } else if (lowerCommand.startsWith('attack ')) {
                const enemyName = command.substring(7);
                const enemy = { name: enemyName, health: 50, maxHealth: 50 };
                combatSystem.startCombat(enemy);
                return;
            } else if (lowerCommand === 'quests') {
                questSystem.listQuests();
                return;
            } else if (lowerCommand === 'craft') {
                craftingSystem.listRecipes();
                return;
            } else if (lowerCommand.startsWith('craft ')) {
                const itemName = command.substring(6);
                craftingSystem.craftItem(itemName);
                return;
            }
            
            return originalProcessCommandAdvanced.call(this, command);
        };
        
        // Advanced skill system
        const skillSystem = {
            skills: new Map(),
            skillPoints: 0,
            maxSkillLevel: 100,
            
            initializeSkill: function(skillName, baseValue = 0) {
                this.skills.set(skillName, {
                    level: baseValue,
                    experience: 0,
                    maxExperience: 100
                });
            },
            
            addExperience: function(skillName, amount) {
                if (!this.skills.has(skillName)) {
                    this.initializeSkill(skillName);
                }
                
                const skill = this.skills.get(skillName);
                skill.experience += amount;
                
                // Check for level up
                while (skill.experience >= skill.maxExperience && skill.level < this.maxSkillLevel) {
                    skill.experience -= skill.maxExperience;
                    skill.level++;
                    skill.maxExperience = Math.floor(skill.maxExperience * 1.2);
                    game.output(`🎉 ${skillName} leveled up to ${skill.level}!`);
                }
            },
            
            getSkillLevel: function(skillName) {
                return this.skills.has(skillName) ? this.skills.get(skillName).level : 0;
            },
            
            listSkills: function() {
                if (this.skills.size === 0) {
                    game.output(`📊 No skills learned yet.`);
                    return;
                }
                
                game.output(`📊 SKILLS:`);
                for (const [name, skill] of this.skills) {
                    const progress = Math.floor((skill.experience / skill.maxExperience) * 100);
                    game.output(`  ${name}: Level ${skill.level} (${progress}% to next level)`);
                }
            }
        };
        
        // Initialize some default skills
        skillSystem.initializeSkill('hacking', 7);
        skillSystem.initializeSkill('combat', 4);
        skillSystem.initializeSkill('stealth', 3);
        skillSystem.initializeSkill('persuasion', 5);
        skillSystem.initializeSkill('cybernetics', 6);
        
        // Advanced reputation system
        const reputationSystem = {
            factions: new Map(),
            globalReputation: 0,
            
            initializeFaction: function(factionName, baseRep = 0) {
                this.factions.set(factionName, {
                    reputation: baseRep,
                    status: 'neutral',
                    history: []
                });
            },
            
            updateReputation: function(factionName, change, reason = '') {
                if (!this.factions.has(factionName)) {
                    this.initializeFaction(factionName);
                }
                
                const faction = this.factions.get(factionName);
                faction.reputation += change;
                faction.history.push({
                    timestamp: Date.now(),
                    change: change,
                    reason: reason
                });
                
                // Update status based on reputation
                if (faction.reputation >= 100) {
                    faction.status = 'allied';
                } else if (faction.reputation >= 50) {
                    faction.status = 'friendly';
                } else if (faction.reputation >= -50) {
                    faction.status = 'neutral';
                } else if (faction.reputation >= -100) {
                    faction.status = 'hostile';
                } else {
                    faction.status = 'enemy';
                }
                
                game.output(`📈 Reputation with ${factionName}: ${faction.reputation} (${faction.status})`);
            },
            
            getFactionStatus: function(factionName) {
                return this.factions.has(factionName) ? this.factions.get(factionName).status : 'unknown';
            },
            
            listReputations: function() {
                if (this.factions.size === 0) {
                    game.output(`📈 No faction reputations yet.`);
                    return;
                }
                
                game.output(`📈 FACTION REPUTATIONS:`);
                for (const [name, faction] of this.factions) {
                    game.output(`  ${name}: ${faction.reputation} (${faction.status})`);
                }
            }
        };
        
        // Initialize some default factions
        reputationSystem.initializeFaction('corporations', -30);
        reputationSystem.initializeFaction('hackers', 20);
        reputationSystem.initializeFaction('civilians', 5);
        reputationSystem.initializeFaction('police', -10);
        
        // Advanced dialogue system
        const dialogueSystem = {
            conversations: new Map(),
            currentConversation: null,
            
            startConversation: function(npcName, dialogueTree) {
                this.currentConversation = {
                    npc: npcName,
                    tree: dialogueTree,
                    currentNode: 'start'
                };
                
                this.displayCurrentNode();
            },
            
            displayCurrentNode: function() {
                if (!this.currentConversation) return;
                
                const node = this.currentConversation.tree[this.currentConversation.currentNode];
                if (!node) return;
                
                game.output(`\n💬 ${this.currentConversation.npc}: ${node.text}`);
                
                if (node.options && node.options.length > 0) {
                    game.output(`\nOptions:`);
                    node.options.forEach((option, index) => {
                        game.output(`  ${index + 1}. ${option.text}`);
                    });
                }
            },
            
            selectOption: function(optionIndex) {
                if (!this.currentConversation) return;
                
                const node = this.currentConversation.tree[this.currentConversation.currentNode];
                if (!node || !node.options || optionIndex < 0 || optionIndex >= node.options.length) {
                    game.output(`❌ Invalid option.`);
                    return;
                }
                
                const option = node.options[optionIndex];
                this.currentConversation.currentNode = option.nextNode || 'end';
                
                if (option.effect) {
                    option.effect();
                }
                
                if (this.currentConversation.currentNode === 'end') {
                    this.endConversation();
                } else {
                    this.displayCurrentNode();
                }
            },
            
            endConversation: function() {
                this.currentConversation = null;
                game.output(`\n💬 Conversation ended.`);
            }
        };
        
        // Add skill, reputation, and dialogue commands
        const originalProcessCommandSystems = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'skills') {
                skillSystem.listSkills();
                return;
            } else if (lowerCommand === 'reputation') {
                reputationSystem.listReputations();
                return;
            } else if (lowerCommand.startsWith('talk to ')) {
                const npcName = command.substring(8);
                // Simple dialogue tree for demonstration
                const dialogueTree = {
                    start: {
                        text: `Greetings, netrunner. What brings you to the neon streets?`,
                        options: [
                            { text: "I need information", nextNode: 'info' },
                            { text: "Just passing by", nextNode: 'end' }
                        ]
                    },
                    info: {
                        text: `Information costs credits, choom. What are you looking for?`,
                        options: [
                            { text: "Tell me about the recent hacks", nextNode: 'hacks' },
                            { text: "Never mind", nextNode: 'end' }
                        ]
                    },
                    hacks: {
                        text: `The corps are tightening security. Be careful out there in the net.`,
                        options: [
                            { text: "Thanks for the warning", nextNode: 'end' }
                        ]
                    }
                };
                dialogueSystem.startConversation(npcName, dialogueTree);
                return;
            }
            
            return originalProcessCommandSystems.call(this, command);
        };
        
        // Advanced mini-game system
        const miniGameSystem = {
            activeGame: null,
            games: new Map(),
            
            registerGame: function(gameName, gameData) {
                this.games.set(gameName, gameData);
            },
            
            startGame: function(gameName) {
                if (!this.games.has(gameName)) {
                    game.output(`❌ Unknown mini-game: ${gameName}`);
                    return;
                }
                
                this.activeGame = {
                    name: gameName,
                    data: this.games.get(gameName),
                    state: this.games.get(gameName).initialState || {}
                };
                
                game.output(`🎮 Starting ${gameName} mini-game!`);
                this.activeGame.data.start(this.activeGame.state);
            },
            
            endGame: function() {
                if (this.activeGame) {
                    game.output(`🎮 ${this.activeGame.name} mini-game ended.`);
                    this.activeGame = null;
                }
            },
            
            processInput: function(input) {
                if (!this.activeGame) return false;
                
                const result = this.activeGame.data.processInput(input, this.activeGame.state);
                if (result) {
                    this.activeGame.state = result.state || this.activeGame.state;
                    if (result.end) {
                        this.endGame();
                    }
                }
                return true;
            }
        };
        
        // Register some mini-games
        miniGameSystem.registerGame('cyberdeck', {
            initialState: { level: 1, progress: 0, maxProgress: 100 },
            start: function(state) {
                game.output(`💻 Cyberdeck mini-game started!`);
                game.output(`Security Level: ${state.level}/5`);
                game.output(`Progress: ${state.progress}/${state.maxProgress}%`);
                game.output(`Commands: hack [target], quit`);
            },
            processInput: function(input, state) {
                const parts = input.toLowerCase().split(' ');
                const command = parts[0];
                
                if (command === 'quit') {
                    game.output(`💻 Cyberdeck session terminated.`);
                    return { end: true };
                } else if (command === 'hack') {
                    const target = parts[1];
                    if (!target) {
                        game.output(`❌ Hack what? (firewall, database, system)`);
                        return { state };
                    }
                    
                    const success = Math.random() < (0.4 - (state.level * 0.08));
                    if (success) {
                        const progress = Math.floor(Math.random() * 20) + 10;
                        state.progress += progress;
                        game.output(`✅ Successfully hacked ${target}! +${progress}% progress`);
                        
                        if (state.progress >= state.maxProgress) {
                            game.output(`🎉 System compromised!`);
                            skillSystem.addExperience('hacking', 15);
                            return { end: true };
                        }
                    } else {
                        game.output(`❌ Hack failed. Security systems are alert.`);
                    }
                } else {
                    game.output(`❌ Unknown command. Use: hack [target], quit`);
                }
                
                return { state };
            }
        });
        
        miniGameSystem.registerGame('neural_interface', {
            initialState: { difficulty: 1, attempts: 0, maxAttempts: 5 },
            start: function(state) {
                game.output(`🧠 Neural Interface mini-game started!`);
                game.output(`Difficulty: ${state.difficulty}/5`);
                game.output(`Attempts remaining: ${state.maxAttempts - state.attempts}`);
                game.output(`Commands: interface [target], quit`);
            },
            processInput: function(input, state) {
                const parts = input.toLowerCase().split(' ');
                const command = parts[0];
                
                if (command === 'quit') {
                    game.output(`🧠 Neural Interface abandoned.`);
                    return { end: true };
                } else if (command === 'interface') {
                    const target = parts[1];
                    if (!target) {
                        game.output(`❌ Interface with what? (system, person, device)`);
                        return { state };
                    }
                    
                    state.attempts++;
                    const success = Math.random() < (0.3 - (state.difficulty * 0.05));
                    
                    if (success) {
                        game.output(`🎉 Neural interface established!`);
                        skillSystem.addExperience('cybernetics', 10);
                        return { end: true };
                    } else {
                        game.output(`❌ Interface failed. ${state.maxAttempts - state.attempts} attempts remaining.`);
                        
                        if (state.attempts >= state.maxAttempts) {
                            game.output(`💀 Neural interface overloaded!`);
                            return { end: true };
                        }
                    }
                } else {
                    game.output(`❌ Unknown command. Use: interface [target], quit`);
                }
                
                return { state };
            }
        });
        
        // Advanced event system
        const eventSystem = {
            events: new Map(),
            activeEvents: new Set(),
            eventHistory: [],
            
            registerEvent: function(eventName, eventData) {
                this.events.set(eventName, eventData);
            },
            
            triggerEvent: function(eventName, context = {}) {
                if (!this.events.has(eventName)) {
                    game.output(`❌ Unknown event: ${eventName}`);
                    return;
                }
                
                const event = this.events.get(eventName);
                this.activeEvents.add(eventName);
                this.eventHistory.push({
                    name: eventName,
                    timestamp: Date.now(),
                    context: context
                });
                
                game.output(`\n🎭 EVENT: ${event.title}`);
                game.output(event.description);
                
                if (event.choices && event.choices.length > 0) {
                    game.output(`\nChoices:`);
                    event.choices.forEach((choice, index) => {
                        game.output(`  ${index + 1}. ${choice.text}`);
                    });
                }
                
                if (event.effects) {
                    event.effects.forEach(effect => {
                        if (effect.type === 'reputation') {
                            reputationSystem.updateReputation(effect.faction, effect.change, event.title);
                        } else if (effect.type === 'skill') {
                            skillSystem.addExperience(effect.skill, effect.amount);
                        } else if (effect.type === 'item') {
                            inventorySystem.addItem(effect.item, effect.weight || 1);
                        }
                    });
                }
            },
            
            listEvents: function() {
                if (this.activeEvents.size === 0) {
                    game.output(`🎭 No active events.`);
                    return;
                }
                
                game.output(`🎭 ACTIVE EVENTS:`);
                for (const eventName of this.activeEvents) {
                    const event = this.events.get(eventName);
                    game.output(`  ${event.title}`);
                }
            }
        };
        
        // Register some events
        eventSystem.registerEvent('corporate_raid', {
            title: 'Corporate Raid',
            description: 'A corporate security team is conducting a raid. You need to decide how to handle this situation.',
            choices: [
                { text: 'Help the security team' },
                { text: 'Stay out of it' },
                { text: 'Warn the hackers' }
            ],
            effects: [
                { type: 'reputation', faction: 'corporations', change: 10, reason: 'Corporate Raid' }
            ]
        });
        
        eventSystem.registerEvent('hacker_meetup', {
            title: 'Hacker Meetup',
            description: 'You stumble upon a secret hacker meetup. They seem to be planning something big.',
            choices: [
                { text: 'Join the meetup' },
                { text: 'Listen from a distance' },
                { text: 'Report to authorities' }
            ],
            effects: [
                { type: 'reputation', faction: 'hackers', change: 15, reason: 'Hacker Meetup' }
            ]
        });
        
        // Add mini-game and event commands
        const originalProcessCommandMini = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'minigames') {
                game.output(`🎮 Available mini-games: cyberdeck, neural_interface`);
                return;
            } else if (lowerCommand.startsWith('play ')) {
                const gameName = command.substring(5);
                miniGameSystem.startGame(gameName);
                return;
            } else if (lowerCommand === 'events') {
                eventSystem.listEvents();
                return;
            } else if (lowerCommand.startsWith('trigger ')) {
                const eventName = command.substring(8);
                eventSystem.triggerEvent(eventName);
                return;
            }
            
            // Check if we're in a mini-game
            if (miniGameSystem.processInput(command)) {
                return;
            }
            
            return originalProcessCommandMini.call(this, command);
        };
        
        // Advanced save system with multiple slots
        const saveSystem = {
            maxSaves: 10,
            currentSave: null,
            
            saveGame: function(saveName) {
                if (!saveName) {
                    game.output(`❌ Please provide a save name.`);
                    return;
                }
                
                const saveData = {
                    timestamp: Date.now(),
                    gameState: game.state,
                    skillSystem: skillSystem,
                    reputationSystem: reputationSystem,
                    inventorySystem: inventorySystem,
                    questSystem: questSystem,
                    combatSystem: combatSystem,
                    craftingSystem: craftingSystem,
                    weatherSystem: weatherSystem,
                    npcAI: npcAI,
                    achievements: achievements,
                    gameAnalytics: gameAnalytics
                };
                
                try {
                    localStorage.setItem(`gumshoe_neon_${saveName}`, JSON.stringify(saveData));
                    game.output(`💾 Game saved as "${saveName}"`);
                } catch (error) {
                    game.output(`❌ Failed to save game: ${error.message}`);
                }
            },
            
            loadGame: function(saveName) {
                if (!saveName) {
                    game.output(`❌ Please provide a save name.`);
                    return;
                }
                
                try {
                    const saveData = localStorage.getItem(`gumshoe_neon_${saveName}`);
                    if (!saveData) {
                        game.output(`❌ Save "${saveName}" not found.`);
                        return;
                    }
                    
                    const parsedData = JSON.parse(saveData);
                    
                    // Restore game state
                    game.state = parsedData.gameState;
                    skillSystem = parsedData.skillSystem || skillSystem;
                    reputationSystem = parsedData.reputationSystem || reputationSystem;
                    inventorySystem = parsedData.inventorySystem || inventorySystem;
                    questSystem = parsedData.questSystem || questSystem;
                    combatSystem = parsedData.combatSystem || combatSystem;
                    craftingSystem = parsedData.craftingSystem || craftingSystem;
                    weatherSystem = parsedData.weatherSystem || weatherSystem;
                    npcAI = parsedData.npcAI || npcAI;
                    achievements = parsedData.achievements || achievements;
                    gameAnalytics = parsedData.gameAnalytics || gameAnalytics;
                    
                    this.currentSave = saveName;
                    game.output(`💾 Game loaded from "${saveName}"`);
                    game.output(`You are in: ${game.getCurrentRoom().name}`);
                } catch (error) {
                    game.output(`❌ Failed to load game: ${error.message}`);
                }
            },
            
            listSaves: function() {
                const saves = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('gumshoe_neon_')) {
                        const saveName = key.replace('gumshoe_neon_', '');
                        const saveData = JSON.parse(localStorage.getItem(key));
                        saves.push({
                            name: saveName,
                            timestamp: saveData.timestamp,
                            date: new Date(saveData.timestamp).toLocaleString()
                        });
                    }
                }
                
                if (saves.length === 0) {
                    game.output(`💾 No saves found.`);
                    return;
                }
                
                game.output(`💾 SAVES:`);
                saves.sort((a, b) => b.timestamp - a.timestamp).forEach(save => {
                    game.output(`  ${save.name} - ${save.date}`);
                });
            },
            
            deleteSave: function(saveName) {
                if (!saveName) {
                    game.output(`❌ Please provide a save name.`);
                    return;
                }
                
                try {
                    localStorage.removeItem(`gumshoe_neon_${saveName}`);
                    game.output(`💾 Save "${saveName}" deleted.`);
                } catch (error) {
                    game.output(`❌ Failed to delete save: ${error.message}`);
                }
            }
        };
        
        // Advanced settings system
        const settingsSystem = {
            settings: {
                autoSave: true,
                autoSaveInterval: 300000, // 5 minutes
                showTips: true,
                soundEnabled: true,
                musicEnabled: true,
                fontSize: 'medium',
                theme: 'neon'
            },
            
            loadSettings: function() {
                try {
                    const savedSettings = localStorage.getItem('gumshoe_neon_settings');
                    if (savedSettings) {
                        this.settings = { ...this.settings, ...JSON.parse(savedSettings) };
                    }
                } catch (error) {
                    console.error('Failed to load settings:', error);
                }
            },
            
            saveSettings: function() {
                try {
                    localStorage.setItem('gumshoe_neon_settings', JSON.stringify(this.settings));
                } catch (error) {
                    console.error('Failed to save settings:', error);
                }
            },
            
            updateSetting: function(key, value) {
                if (this.settings.hasOwnProperty(key)) {
                    this.settings[key] = value;
                    this.saveSettings();
                    game.output(`⚙️ Setting ${key} updated to ${value}`);
                } else {
                    game.output(`❌ Unknown setting: ${key}`);
                }
            },
            
            listSettings: function() {
                game.output(`⚙️ SETTINGS:`);
                for (const [key, value] of Object.entries(this.settings)) {
                    game.output(`  ${key}: ${value}`);
                }
            }
        };
        
        // Load settings on startup
        settingsSystem.loadSettings();
        
        // Advanced help system
        const helpSystem = {
            categories: {
                basic: ['look', 'go', 'take', 'drop', 'inventory', 'help'],
                combat: ['attack', 'defend', 'flee', 'combat'],
                quests: ['quests', 'quest', 'complete'],
                crafting: ['craft', 'recipes', 'materials'],
                skills: ['skills', 'experience'],
                reputation: ['reputation', 'factions'],
                dialogue: ['talk to', 'conversation'],
                minigames: ['minigames', 'play'],
                events: ['events', 'trigger'],
                saves: ['save', 'load', 'saves'],
                settings: ['settings', 'config'],
                cheats: ['godmode', 'money', 'teleport', 'stats']
            },
            
            showHelp: function(category = null) {
                if (!category) {
                    game.output(`📚 HELP SYSTEM:`);
                    game.output(`Available categories: ${Object.keys(this.categories).join(', ')}`);
                    game.output(`Use 'help [category]' for specific help.`);
                    return;
                }
                
                if (!this.categories[category]) {
                    game.output(`❌ Unknown category: ${category}`);
                    return;
                }
                
                game.output(`📚 HELP - ${category.toUpperCase()}:`);
                this.categories[category].forEach(command => {
                    game.output(`  ${command}`);
                });
            },
            
            searchHelp: function(query) {
                const results = [];
                for (const [category, commands] of Object.entries(this.categories)) {
                    const matches = commands.filter(cmd => cmd.includes(query.toLowerCase()));
                    if (matches.length > 0) {
                        results.push({ category, commands: matches });
                    }
                }
                
                if (results.length === 0) {
                    game.output(`❌ No help found for "${query}"`);
                    return;
                }
                
                game.output(`📚 SEARCH RESULTS for "${query}":`);
                results.forEach(result => {
                    game.output(`  ${result.category}: ${result.commands.join(', ')}`);
                });
            }
        };
        
        // Add save, settings, and help commands
        const originalProcessCommandSave = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('save ')) {
                const saveName = command.substring(5);
                saveSystem.saveGame(saveName);
                return;
            } else if (lowerCommand.startsWith('load ')) {
                const saveName = command.substring(5);
                saveSystem.loadGame(saveName);
                return;
            } else if (lowerCommand === 'saves') {
                saveSystem.listSaves();
                return;
            } else if (lowerCommand.startsWith('delete ')) {
                const saveName = command.substring(7);
                saveSystem.deleteSave(saveName);
                return;
            } else if (lowerCommand === 'settings') {
                settingsSystem.listSettings();
                return;
            } else if (lowerCommand.startsWith('set ')) {
                const parts = command.substring(4).split(' ');
                const key = parts[0];
                const value = parts[1];
                settingsSystem.updateSetting(key, value);
                return;
            } else if (lowerCommand === 'help') {
                helpSystem.showHelp();
                return;
            } else if (lowerCommand.startsWith('help ')) {
                const category = command.substring(5);
                helpSystem.showHelp(category);
                return;
            } else if (lowerCommand.startsWith('search ')) {
                const query = command.substring(7);
                helpSystem.searchHelp(query);
                return;
            }
            
            return originalProcessCommandSave.call(this, command);
        };
        
        // Advanced tutorial system
        const tutorialSystem = {
            tutorials: new Map(),
            activeTutorial: null,
            completedTutorials: new Set(),
            
            registerTutorial: function(tutorialName, tutorialData) {
                this.tutorials.set(tutorialName, tutorialData);
            },
            
            startTutorial: function(tutorialName) {
                if (!this.tutorials.has(tutorialName)) {
                    game.output(`❌ Unknown tutorial: ${tutorialName}`);
                    return;
                }
                
                this.activeTutorial = {
                    name: tutorialName,
                    data: this.tutorials.get(tutorialName),
                    currentStep: 0
                };
                
                game.output(`📖 Starting tutorial: ${tutorialName}`);
                this.showCurrentStep();
            },
            
            showCurrentStep: function() {
                if (!this.activeTutorial) return;
                
                const step = this.activeTutorial.data.steps[this.activeTutorial.currentStep];
                if (!step) {
                    this.completeTutorial();
                    return;
                }
                
                game.output(`\n📖 TUTORIAL STEP ${this.activeTutorial.currentStep + 1}:`);
                game.output(step.text);
                
                if (step.command) {
                    game.output(`\nTry: ${step.command}`);
                }
                
                if (step.hint) {
                    game.output(`\n💡 Hint: ${step.hint}`);
                }
            },
            
            nextStep: function() {
                if (!this.activeTutorial) return;
                
                this.activeTutorial.currentStep++;
                this.showCurrentStep();
            },
            
            completeTutorial: function() {
                if (!this.activeTutorial) return;
                
                this.completedTutorials.add(this.activeTutorial.name);
                game.output(`\n🎉 Tutorial "${this.activeTutorial.name}" completed!`);
                this.activeTutorial = null;
            },
            
            listTutorials: function() {
                if (this.tutorials.size === 0) {
                    game.output(`📖 No tutorials available.`);
                    return;
                }
                
                game.output(`📖 TUTORIALS:`);
                for (const [name, tutorial] of this.tutorials) {
                    const status = this.completedTutorials.has(name) ? '✅' : '⭕';
                    game.output(`  ${status} ${name} - ${tutorial.description}`);
                }
            }
        };
        
        // Register some tutorials
        tutorialSystem.registerTutorial('getting_started', {
            description: 'Learn the basics of playing GUMSHOE Neon',
            steps: [
                {
                    text: 'Welcome to GUMSHOE Neon! This is a cyberpunk text-based adventure. You can type commands to interact with the world.',
                    command: 'look',
                    hint: 'Start by looking around to see what\'s in your current location.'
                },
                {
                    text: 'Great! Now try moving to a different location.',
                    command: 'go north',
                    hint: 'Use "go [direction]" to move around the world.'
                },
                {
                    text: 'Excellent! You can also examine objects and talk to people.',
                    command: 'examine [object]',
                    hint: 'Use "examine" to look at specific items or "talk to [person]" to start conversations.'
                },
                {
                    text: 'You can save your progress at any time.',
                    command: 'save mygame',
                    hint: 'Use "save [name]" to save your game and "load [name]" to load it later.'
                }
            ]
        });
        
        tutorialSystem.registerTutorial('hacking_basics', {
            description: 'Learn how to hack and use cyberdeck',
            steps: [
                {
                    text: 'Hacking in GUMSHOE Neon is essential. You can use your cyberdeck to hack systems.',
                    command: 'play cyberdeck',
                    hint: 'Use "play cyberdeck" to start the hacking mini-game.'
                },
                {
                    text: 'When hacking, use "hack [target]" to attempt to breach security.',
                    command: 'hack firewall',
                    hint: 'Make sure to specify what you want to hack.'
                },
                {
                    text: 'You can also use neural interfaces to connect with people and devices.',
                    command: 'play neural_interface',
                    hint: 'Neural interfaces allow you to connect directly with systems.'
                },
                {
                    text: 'Remember, hacking has consequences. Be careful!',
                    command: 'quit',
                    hint: 'Use "quit" to exit any mini-game safely.'
                }
            ]
        });
        
        // Advanced achievement system
        const achievementSystem = {
            achievements: new Map(),
            unlockedAchievements: new Set(),
            
            registerAchievement: function(achievementName, achievementData) {
                this.achievements.set(achievementName, achievementData);
            },
            
            unlockAchievement: function(achievementName) {
                if (!this.achievements.has(achievementName)) {
                    console.error(`Unknown achievement: ${achievementName}`);
                    return;
                }
                
                if (this.unlockedAchievements.has(achievementName)) {
                    return; // Already unlocked
                }
                
                this.unlockedAchievements.add(achievementName);
                const achievement = this.achievements.get(achievementName);
                
                game.output(`\n🏆 ACHIEVEMENT UNLOCKED: ${achievement.title}`);
                game.output(`🎯 ${achievement.description}`);
                
                if (achievement.reward) {
                    game.output(`🎁 Reward: ${achievement.reward}`);
                }
            },
            
            checkAchievements: function() {
                // Check for various achievement conditions
                if (game.state.commandsExecuted >= 100 && !this.unlockedAchievements.has('command_master')) {
                    this.unlockAchievement('command_master');
                }
                
                if (game.state.roomsVisited >= 10 && !this.unlockedAchievements.has('explorer')) {
                    this.unlockAchievement('explorer');
                }
                
                if (game.state.npcsTalkedTo >= 5 && !this.unlockedAchievements.has('social_butterfly')) {
                    this.unlockAchievement('social_butterfly');
                }
                
                if (game.state.itemsCollected >= 20 && !this.unlockedAchievements.has('collector')) {
                    this.unlockAchievement('collector');
                }
            },
            
            listAchievements: function() {
                if (this.achievements.size === 0) {
                    game.output(`🏆 No achievements available.`);
                    return;
                }
                
                game.output(`🏆 ACHIEVEMENTS:`);
                for (const [name, achievement] of this.achievements) {
                    const status = this.unlockedAchievements.has(name) ? '✅' : '⭕';
                    game.output(`  ${status} ${achievement.title}`);
                    if (this.unlockedAchievements.has(name)) {
                        game.output(`     ${achievement.description}`);
                    }
                }
            }
        };
        
        // Register some achievements
        achievementSystem.registerAchievement('command_master', {
            title: 'Command Master',
            description: 'Execute 100 commands',
            reward: '+10 skill points'
        });
        
        achievementSystem.registerAchievement('explorer', {
            title: 'Explorer',
            description: 'Visit 10 different locations',
            reward: '+5 reputation with all factions'
        });
        
        achievementSystem.registerAchievement('social_butterfly', {
            title: 'Social Butterfly',
            description: 'Talk to 5 different NPCs',
            reward: '+3 persuasion skill'
        });
        
        achievementSystem.registerAchievement('collector', {
            title: 'Collector',
            description: 'Collect 20 different items',
            reward: '+5 inventory capacity'
        });
        
        // Add tutorial and achievement commands
        const originalProcessCommandTutorial = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'tutorials') {
                tutorialSystem.listTutorials();
                return;
            } else if (lowerCommand.startsWith('tutorial ')) {
                const tutorialName = command.substring(9);
                tutorialSystem.startTutorial(tutorialName);
                return;
            } else if (lowerCommand === 'next') {
                tutorialSystem.nextStep();
                return;
            } else if (lowerCommand === 'achievements') {
                achievementSystem.listAchievements();
                return;
            }
            
            return originalProcessCommandTutorial.call(this, command);
        };
        
        // Advanced music and sound system
        const audioSystem = {
            music: new Map(),
            sounds: new Map(),
            currentMusic: null,
            volume: 0.5,
            muted: false,
            
            registerMusic: function(trackName, trackData) {
                this.music.set(trackName, trackData);
            },
            
            registerSound: function(soundName, soundData) {
                this.sounds.set(soundName, soundData);
            },
            
            playMusic: function(trackName, loop = true) {
                if (this.muted) return;
                
                const track = this.music.get(trackName);
                if (!track) {
                    game.output(`❌ Music track not found: ${trackName}`);
                    return;
                }
                
                if (this.currentMusic) {
                    this.stopMusic();
                }
                
                this.currentMusic = trackName;
                game.output(`🎵 Now playing: ${track.title}`);
                
                // In a real implementation, you would play actual audio
                // For now, we'll just simulate it
                if (track.description) {
                    game.output(`📝 ${track.description}`);
                }
            },
            
            stopMusic: function() {
                if (this.currentMusic) {
                    game.output(`🎵 Music stopped`);
                    this.currentMusic = null;
                }
            },
            
            playSound: function(soundName) {
                if (this.muted) return;
                
                const sound = this.sounds.get(soundName);
                if (!sound) {
                    game.output(`❌ Sound not found: ${soundName}`);
                    return;
                }
                
                game.output(`🔊 ${sound.description}`);
            },
            
            setVolume: function(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                game.output(`🔊 Volume set to ${Math.floor(this.volume * 100)}%`);
            },
            
            toggleMute: function() {
                this.muted = !this.muted;
                game.output(`🔊 Audio ${this.muted ? 'muted' : 'unmuted'}`);
            },
            
            listMusic: function() {
                if (this.music.size === 0) {
                    game.output(`🎵 No music tracks available.`);
                    return;
                }
                
                game.output(`🎵 MUSIC TRACKS:`);
                for (const [name, track] of this.music) {
                    const status = this.currentMusic === name ? '▶️' : '⏸️';
                    game.output(`  ${status} ${name} - ${track.title}`);
                }
            },
            
            listSounds: function() {
                if (this.sounds.size === 0) {
                    game.output(`🔊 No sounds available.`);
                    return;
                }
                
                game.output(`🔊 SOUNDS:`);
                for (const [name, sound] of this.sounds) {
                    game.output(`  ${name} - ${sound.description}`);
                }
            }
        };
        
        // Register some music and sounds
        audioSystem.registerMusic('main_theme', {
            title: 'Main Theme',
            description: 'The pulsing beat of the neon city'
        });
        
        audioSystem.registerMusic('combat_theme', {
            title: 'Combat Theme',
            description: 'Intense electronic music for cyber combat'
        });
        
        audioSystem.registerMusic('hacking_theme', {
            title: 'Hacking Theme',
            description: 'Ambient electronic music for hacking sessions'
        });
        
        audioSystem.registerSound('cyber_sound', {
            description: 'Electronic beeps and boops'
        });
        
        audioSystem.registerSound('laser_shot', {
            description: 'A laser beam cuts through the air'
        });
        
        audioSystem.registerSound('door_slide', {
            description: 'A futuristic door slides open'
        });
        
        audioSystem.registerSound('rain', {
            description: 'Acid rain falling on the city'
        });
        
        // Advanced notification system
        const notificationSystem = {
            notifications: [],
            maxNotifications: 10,
            
            addNotification: function(type, title, message, duration = 5000) {
                const notification = {
                    id: Date.now(),
                    type: type,
                    title: title,
                    message: message,
                    timestamp: Date.now(),
                    duration: duration
                };
                
                this.notifications.unshift(notification);
                
                // Limit number of notifications
                if (this.notifications.length > this.maxNotifications) {
                    this.notifications = this.notifications.slice(0, this.maxNotifications);
                }
                
                this.displayNotification(notification);
            },
            
            displayNotification: function(notification) {
                const typeEmoji = {
                    'info': 'ℹ️',
                    'success': '✅',
                    'warning': '⚠️',
                    'error': '❌',
                    'achievement': '🏆',
                    'quest': '📋',
                    'combat': '⚔️',
                    'item': '🎒'
                };
                
                const emoji = typeEmoji[notification.type] || '📢';
                game.output(`\n${emoji} ${notification.title}`);
                game.output(`   ${notification.message}`);
            },
            
            listNotifications: function() {
                if (this.notifications.length === 0) {
                    game.output(`📢 No notifications.`);
                    return;
                }
                
                game.output(`📢 RECENT NOTIFICATIONS:`);
                this.notifications.slice(0, 5).forEach(notification => {
                    const timeAgo = Math.floor((Date.now() - notification.timestamp) / 1000);
                    const typeEmoji = {
                        'info': 'ℹ️',
                        'success': '✅',
                        'warning': '⚠️',
                        'error': '❌',
                        'achievement': '🏆',
                        'quest': '📋',
                        'combat': '⚔️',
                        'item': '🎒'
                    };
                    const emoji = typeEmoji[notification.type] || '📢';
                    game.output(`  ${emoji} ${notification.title} (${timeAgo}s ago)`);
                });
            },
            
            clearNotifications: function() {
                this.notifications = [];
                game.output(`📢 All notifications cleared.`);
            }
        };
        
        // Add audio and notification commands
        const originalProcessCommandAudio = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'music') {
                audioSystem.listMusic();
                return;
            } else if (lowerCommand.startsWith('play ')) {
                const trackName = command.substring(5);
                audioSystem.playMusic(trackName);
                return;
            } else if (lowerCommand === 'stop') {
                audioSystem.stopMusic();
                return;
            } else if (lowerCommand === 'sounds') {
                audioSystem.listSounds();
                return;
            } else if (lowerCommand.startsWith('sound ')) {
                const soundName = command.substring(6);
                audioSystem.playSound(soundName);
                return;
            } else if (lowerCommand.startsWith('volume ')) {
                const volume = parseFloat(command.substring(7));
                audioSystem.setVolume(volume);
                return;
            } else if (lowerCommand === 'mute') {
                audioSystem.toggleMute();
                return;
            } else if (lowerCommand === 'notifications') {
                notificationSystem.listNotifications();
                return;
            } else if (lowerCommand === 'clear') {
                notificationSystem.clearNotifications();
                return;
            }
            
            return originalProcessCommandAudio.call(this, command);
        };
        
        // Advanced screenshot and recording system
        const recordingSystem = {
            screenshots: [],
            recordings: [],
            maxScreenshots: 50,
            maxRecordings: 10,
            
            takeScreenshot: function(description = '') {
                const screenshot = {
                    id: Date.now(),
                    timestamp: Date.now(),
                    description: description,
                    gameState: {
                        location: game.state.currentLocation,
                        inventory: game.state.inventory,
                        health: game.state.health,
                        cash: game.state.cash,
                        debt: game.state.debt
                    }
                };
                
                this.screenshots.unshift(screenshot);
                
                // Limit number of screenshots
                if (this.screenshots.length > this.maxScreenshots) {
                    this.screenshots = this.screenshots.slice(0, this.maxScreenshots);
                }
                
                game.output(`📸 Screenshot taken: ${description || 'Untitled'}`);
                notificationSystem.addNotification('info', 'Screenshot Saved', `Screenshot "${description || 'Untitled'}" has been saved.`);
            },
            
            startRecording: function(description = '') {
                const recording = {
                    id: Date.now(),
                    timestamp: Date.now(),
                    description: description,
                    startTime: Date.now(),
                    isRecording: true,
                    events: []
                };
                
                this.recordings.unshift(recording);
                
                // Limit number of recordings
                if (this.recordings.length > this.maxRecordings) {
                    this.recordings = this.recordings.slice(0, this.maxRecordings);
                }
                
                game.output(`🎬 Recording started: ${description || 'Untitled'}`);
                notificationSystem.addNotification('info', 'Recording Started', `Recording "${description || 'Untitled'}" has been started.`);
            },
            
            stopRecording: function() {
                const activeRecording = this.recordings.find(r => r.isRecording);
                if (!activeRecording) {
                    game.output(`❌ No active recording to stop.`);
                    return;
                }
                
                activeRecording.isRecording = false;
                activeRecording.endTime = Date.now();
                activeRecording.duration = activeRecording.endTime - activeRecording.startTime;
                
                game.output(`🎬 Recording stopped: ${activeRecording.description || 'Untitled'}`);
                game.output(`⏱️ Duration: ${Math.floor(activeRecording.duration / 1000)}s`);
                notificationSystem.addNotification('info', 'Recording Stopped', `Recording "${activeRecording.description || 'Untitled'}" has been stopped.`);
            },
            
            listScreenshots: function() {
                if (this.screenshots.length === 0) {
                    game.output(`📸 No screenshots available.`);
                    return;
                }
                
                game.output(`📸 SCREENSHOTS:`);
                this.screenshots.slice(0, 10).forEach(screenshot => {
                    const timeAgo = Math.floor((Date.now() - screenshot.timestamp) / 1000);
                    game.output(`  📸 ${screenshot.description || 'Untitled'} (${timeAgo}s ago)`);
                });
            },
            
            listRecordings: function() {
                if (this.recordings.length === 0) {
                    game.output(`🎬 No recordings available.`);
                    return;
                }
                
                game.output(`🎬 RECORDINGS:`);
                this.recordings.slice(0, 10).forEach(recording => {
                    const timeAgo = Math.floor((Date.now() - recording.timestamp) / 1000);
                    const status = recording.isRecording ? '🔴' : '⏹️';
                    const duration = recording.duration ? ` (${Math.floor(recording.duration / 1000)}s)` : '';
                    game.output(`  ${status} ${recording.description || 'Untitled'} (${timeAgo}s ago)${duration}`);
                });
            },
            
            clearScreenshots: function() {
                this.screenshots = [];
                game.output(`📸 All screenshots cleared.`);
            },
            
            clearRecordings: function() {
                this.recordings = [];
                game.output(`🎬 All recordings cleared.`);
            }
        };
        
        // Advanced macro system
        const macroSystem = {
            macros: new Map(),
            maxMacros: 20,
            
            createMacro: function(name, commands) {
                if (this.macros.size >= this.maxMacros) {
                    game.output(`❌ Maximum number of macros reached (${this.maxMacros}).`);
                    return;
                }
                
                if (this.macros.has(name)) {
                    game.output(`❌ Macro "${name}" already exists.`);
                    return;
                }
                
                this.macros.set(name, {
                    name: name,
                    commands: commands,
                    created: Date.now(),
                    uses: 0
                });
                
                game.output(`📝 Macro "${name}" created with ${commands.length} commands.`);
                notificationSystem.addNotification('success', 'Macro Created', `Macro "${name}" has been created successfully.`);
            },
            
            executeMacro: function(name) {
                const macro = this.macros.get(name);
                if (!macro) {
                    game.output(`❌ Macro "${name}" not found.`);
                    return;
                }
                
                game.output(`🎯 Executing macro: ${name}`);
                macro.uses++;
                
                // Execute each command with a small delay
                macro.commands.forEach((command, index) => {
                    setTimeout(() => {
                        game.processCommand(command);
                    }, index * 100); // 100ms delay between commands
                });
                
                notificationSystem.addNotification('info', 'Macro Executed', `Macro "${name}" has been executed (${macro.uses} uses).`);
            },
            
            listMacros: function() {
                if (this.macros.size === 0) {
                    game.output(`📝 No macros available.`);
                    return;
                }
                
                game.output(`📝 MACROS:`);
                for (const [name, macro] of this.macros) {
                    game.output(`  📝 ${name} - ${macro.commands.length} commands (${macro.uses} uses)`);
                }
            },
            
            deleteMacro: function(name) {
                if (!this.macros.has(name)) {
                    game.output(`❌ Macro "${name}" not found.`);
                    return;
                }
                
                this.macros.delete(name);
                game.output(`📝 Macro "${name}" deleted.`);
                notificationSystem.addNotification('info', 'Macro Deleted', `Macro "${name}" has been deleted.`);
            },
            
            clearMacros: function() {
                this.macros.clear();
                game.output(`📝 All macros cleared.`);
            }
        };
        
        // Add recording and macro commands
        const originalProcessCommandRecording = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('screenshot ')) {
                const description = command.substring(11);
                recordingSystem.takeScreenshot(description);
                return;
            } else if (lowerCommand === 'screenshots') {
                recordingSystem.listScreenshots();
                return;
            } else if (lowerCommand.startsWith('record ')) {
                const description = command.substring(7);
                recordingSystem.startRecording(description);
                return;
            } else if (lowerCommand === 'stop') {
                recordingSystem.stopRecording();
                return;
            } else if (lowerCommand === 'recordings') {
                recordingSystem.listRecordings();
                return;
            } else if (lowerCommand === 'clear screenshots') {
                recordingSystem.clearScreenshots();
                return;
            } else if (lowerCommand === 'clear recordings') {
                recordingSystem.clearRecordings();
                return;
            } else if (lowerCommand.startsWith('macro ')) {
                const parts = command.substring(6).split(' ');
                const action = parts[0];
                const name = parts[1];
                
                if (action === 'create') {
                    const commands = parts.slice(2).join(' ').split(';').map(cmd => cmd.trim());
                    macroSystem.createMacro(name, commands);
                } else if (action === 'execute') {
                    macroSystem.executeMacro(name);
                } else if (action === 'delete') {
                    macroSystem.deleteMacro(name);
                } else {
                    game.output(`❌ Unknown macro action: ${action}`);
                }
                return;
            } else if (lowerCommand === 'macros') {
                macroSystem.listMacros();
                return;
            } else if (lowerCommand === 'clear macros') {
                macroSystem.clearMacros();
                return;
            }
            
            return originalProcessCommandRecording.call(this, command);
        };
        
        // Advanced plugin system
        const pluginSystem = {
            plugins: new Map(),
            maxPlugins: 50,
            
            loadPlugin: function(pluginName, pluginCode) {
                if (this.plugins.size >= this.maxPlugins) {
                    game.output(`❌ Maximum number of plugins reached (${this.maxPlugins}).`);
                    return;
                }
                
                if (this.plugins.has(pluginName)) {
                    game.output(`❌ Plugin "${pluginName}" already loaded.`);
                    return;
                }
                
                try {
                    // Create a safe execution context
                    const pluginContext = {
                        game: game,
                        console: console,
                        Date: Date,
                        Math: Math,
                        JSON: JSON,
                        setTimeout: setTimeout,
                        setInterval: setInterval,
                        clearTimeout: clearTimeout,
                        clearInterval: clearInterval
                    };
                    
                    // Execute plugin code in safe context
                    const pluginFunction = new Function('context', `
                        with (context) {
                            ${pluginCode}
                        }
                    `);
                    
                    const pluginInstance = pluginFunction(pluginContext);
                    
                    this.plugins.set(pluginName, {
                        name: pluginName,
                        instance: pluginInstance,
                        loaded: Date.now(),
                        enabled: true
                    });
                    
                    game.output(`🔌 Plugin "${pluginName}" loaded successfully.`);
                    notificationSystem.addNotification('success', 'Plugin Loaded', `Plugin "${pluginName}" has been loaded successfully.`);
                } catch (error) {
                    game.output(`❌ Failed to load plugin "${pluginName}": ${error.message}`);
                    notificationSystem.addNotification('error', 'Plugin Error', `Failed to load plugin "${pluginName}": ${error.message}`);
                }
            },
            
            unloadPlugin: function(pluginName) {
                if (!this.plugins.has(pluginName)) {
                    game.output(`❌ Plugin "${pluginName}" not found.`);
                    return;
                }
                
                this.plugins.delete(pluginName);
                game.output(`🔌 Plugin "${pluginName}" unloaded.`);
                notificationSystem.addNotification('info', 'Plugin Unloaded', `Plugin "${pluginName}" has been unloaded.`);
            },
            
            listPlugins: function() {
                if (this.plugins.size === 0) {
                    game.output(`🔌 No plugins loaded.`);
                    return;
                }
                
                game.output(`🔌 LOADED PLUGINS:`);
                for (const [name, plugin] of this.plugins) {
                    const status = plugin.enabled ? '✅' : '❌';
                    game.output(`  ${status} ${name} (loaded ${Math.floor((Date.now() - plugin.loaded) / 1000)}s ago)`);
                }
            },
            
            enablePlugin: function(pluginName) {
                const plugin = this.plugins.get(pluginName);
                if (!plugin) {
                    game.output(`❌ Plugin "${pluginName}" not found.`);
                    return;
                }
                
                plugin.enabled = true;
                game.output(`🔌 Plugin "${pluginName}" enabled.`);
                notificationSystem.addNotification('info', 'Plugin Enabled', `Plugin "${pluginName}" has been enabled.`);
            },
            
            disablePlugin: function(pluginName) {
                const plugin = this.plugins.get(pluginName);
                if (!plugin) {
                    game.output(`❌ Plugin "${pluginName}" not found.`);
                    return;
                }
                
                plugin.enabled = false;
                game.output(`🔌 Plugin "${pluginName}" disabled.`);
                notificationSystem.addNotification('info', 'Plugin Disabled', `Plugin "${pluginName}" has been disabled.`);
            },
            
            clearPlugins: function() {
                this.plugins.clear();
                game.output(`🔌 All plugins cleared.`);
            }
        };
        
        // Advanced scripting system
        const scriptingSystem = {
            scripts: new Map(),
            maxScripts: 100,
            
            createScript: function(scriptName, scriptCode) {
                if (this.scripts.size >= this.maxScripts) {
                    game.output(`❌ Maximum number of scripts reached (${this.maxScripts}).`);
                    return;
                }
                
                if (this.scripts.has(scriptName)) {
                    game.output(`❌ Script "${scriptName}" already exists.`);
                    return;
                }
                
                this.scripts.set(scriptName, {
                    name: scriptName,
                    code: scriptCode,
                    created: Date.now(),
                    runs: 0
                });
                
                game.output(`📜 Script "${scriptName}" created successfully.`);
                notificationSystem.addNotification('success', 'Script Created', `Script "${scriptName}" has been created successfully.`);
            },
            
            runScript: function(scriptName) {
                const script = this.scripts.get(scriptName);
                if (!script) {
                    game.output(`❌ Script "${scriptName}" not found.`);
                    return;
                }
                
                try {
                    // Create a safe execution context
                    const scriptContext = {
                        game: game,
                        console: console,
                        Date: Date,
                        Math: Math,
                        JSON: JSON,
                        setTimeout: setTimeout,
                        setInterval: setInterval,
                        clearTimeout: clearTimeout,
                        clearInterval: clearInterval
                    };
                    
                    // Execute script code in safe context
                    const scriptFunction = new Function('context', `
                        with (context) {
                            ${script.code}
                        }
                    `);
                    
                    scriptFunction(scriptContext);
                    script.runs++;
                    
                    game.output(`📜 Script "${scriptName}" executed successfully.`);
                    notificationSystem.addNotification('info', 'Script Executed', `Script "${scriptName}" has been executed (${script.runs} runs).`);
                } catch (error) {
                    game.output(`❌ Failed to execute script "${scriptName}": ${error.message}`);
                    notificationSystem.addNotification('error', 'Script Error', `Failed to execute script "${scriptName}": ${error.message}`);
                }
            },
            
            listScripts: function() {
                if (this.scripts.size === 0) {
                    game.output(`📜 No scripts available.`);
                    return;
                }
                
                game.output(`📜 SCRIPTS:`);
                for (const [name, script] of this.scripts) {
                    game.output(`  📜 ${name} - ${script.runs} runs`);
                }
            },
            
            deleteScript: function(scriptName) {
                if (!this.scripts.has(scriptName)) {
                    game.output(`❌ Script "${scriptName}" not found.`);
                    return;
                }
                
                this.scripts.delete(scriptName);
                game.output(`📜 Script "${scriptName}" deleted.`);
                notificationSystem.addNotification('info', 'Script Deleted', `Script "${scriptName}" has been deleted.`);
            },
            
            clearScripts: function() {
                this.scripts.clear();
                game.output(`📜 All scripts cleared.`);
            }
        };
        
        // Add plugin and scripting commands
        const originalProcessCommandPlugin = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('plugin load ')) {
                const parts = command.substring(12).split(' ');
                const pluginName = parts[0];
                const pluginCode = parts.slice(1).join(' ');
                pluginSystem.loadPlugin(pluginName, pluginCode);
                return;
            } else if (lowerCommand.startsWith('plugin unload ')) {
                const pluginName = command.substring(14);
                pluginSystem.unloadPlugin(pluginName);
                return;
            } else if (lowerCommand === 'plugins') {
                pluginSystem.listPlugins();
                return;
            } else if (lowerCommand.startsWith('plugin enable ')) {
                const pluginName = command.substring(14);
                pluginSystem.enablePlugin(pluginName);
                return;
            } else if (lowerCommand.startsWith('plugin disable ')) {
                const pluginName = command.substring(15);
                pluginSystem.disablePlugin(pluginName);
                return;
            } else if (lowerCommand === 'clear plugins') {
                pluginSystem.clearPlugins();
                return;
            } else if (lowerCommand.startsWith('script create ')) {
                const parts = command.substring(14).split(' ');
                const scriptName = parts[0];
                const scriptCode = parts.slice(1).join(' ');
                scriptingSystem.createScript(scriptName, scriptCode);
                return;
            } else if (lowerCommand.startsWith('script run ')) {
                const scriptName = command.substring(11);
                scriptingSystem.runScript(scriptName);
                return;
            } else if (lowerCommand === 'scripts') {
                scriptingSystem.listScripts();
                return;
            } else if (lowerCommand.startsWith('script delete ')) {
                const scriptName = command.substring(14);
                scriptingSystem.deleteScript(scriptName);
                return;
            } else if (lowerCommand === 'clear scripts') {
                scriptingSystem.clearScripts();
                return;
            }
            
            return originalProcessCommandPlugin.call(this, command);
        };
        
        // Load game data from server (only if not in localhost mode)
        if (API_BASE_URL) {
            (async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/games/data/cyberpunk`);
                    const result = await response.json();
                    
                    if (result.gameConfig) {
                        // Replace the original game.data with server data
                        game.data = result.gameConfig;
                        console.log('Game data loaded from server successfully');
                    } else {
                        console.error('Failed to load game data from server:', result.error?.message || 'Unknown error');
                    }
                } catch (error) {
                    console.error('Error loading game data from server:', error);
                }
            })();
        } else {
            console.log('Running in localhost mode - using local game data');
        }
        
        // --- 8-BIT CYBERPUNK BACKGROUND MUSIC ---
        class CyberpunkMusic {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.isMuted = false; // Start unmuted for better user experience
                this.currentMelody = null;
                this.patterns = this.initializePatterns();
                this.initAudio();
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }
            
            initializePatterns() {
                return {
                    // Main cyberpunk riff patterns
                    mainRiff: [
                        { freq: 440, duration: 0.125 }, // A4 - eighth note
                        { freq: 523, duration: 0.125 }, // C5 - eighth note
                        { freq: 659, duration: 0.25 },  // E5 - quarter note
                        { freq: 523, duration: 0.125 }, // C5 - eighth note
                        { freq: 440, duration: 0.125 }, // A4 - eighth note
                        { freq: 349, duration: 0.25 },  // F4 - quarter note
                        { freq: 440, duration: 0.5 },   // A4 - half note
                    ],
                    // Bass line pattern
                    bassLine: [
                        { freq: 220, duration: 0.25 },  // A3 - quarter note
                        { freq: 262, duration: 0.25 },  // C4 - quarter note
                        { freq: 330, duration: 0.25 },  // E4 - quarter note
                        { freq: 262, duration: 0.25 },  // C4 - quarter note
                    ],
                    // High frequency arpeggio
                    arpeggio: [
                        { freq: 880, duration: 0.125 }, // A5 - eighth note
                        { freq: 1047, duration: 0.125 }, // C6 - eighth note
                        { freq: 1319, duration: 0.125 }, // E6 - eighth note
                        { freq: 1047, duration: 0.125 }, // C6 - eighth note
                    ],
                    // Syncopated rhythm
                    syncopated: [
                        { freq: 440, duration: 0.25 },   // A4 - quarter note
                        { freq: 0, duration: 0.125 },   // Rest - eighth note
                        { freq: 523, duration: 0.125 }, // C5 - eighth note
                        { freq: 659, duration: 0.25 },  // E5 - quarter note
                        { freq: 0, duration: 0.125 },   // Rest - eighth note
                        { freq: 440, duration: 0.25 },  // A4 - quarter note
                    ]
                };
            }
            
            generateCyberpunkMelody() {
                // Randomly select and combine patterns
                const patternKeys = Object.keys(this.patterns);
                const selectedPattern = this.patterns[patternKeys[Math.floor(Math.random() * patternKeys.length)]];
                
                // Add some variation with random notes
                const melody = [...selectedPattern];
                
                // Occasionally add random eighth notes or rests
                if (Math.random() < 0.3) {
                    const randomNote = {
                        freq: [220, 262, 330, 440, 523, 659, 880][Math.floor(Math.random() * 7)],
                        duration: Math.random() < 0.5 ? 0.125 : 0.25
                    };
                    melody.splice(Math.floor(Math.random() * melody.length), 0, randomNote);
                }
                
                // Occasionally add rests for rhythm variation
                if (Math.random() < 0.2) {
                    melody.splice(Math.floor(Math.random() * melody.length), 0, { freq: 0, duration: 0.125 });
                }
                
                return melody;
            }
            
            playNote(frequency, duration, startTime = 0) {
                if (!this.audioContext || this.isMuted) return;
                
                if (frequency === 0) return; // Rest
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime + startTime);
                oscillator.type = 'sawtooth'; // More electronic sound
                
                gainNode.gain.setValueAtTime(0.08, this.audioContext.currentTime + startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + startTime + duration);
                
                oscillator.start(this.audioContext.currentTime + startTime);
                oscillator.stop(this.audioContext.currentTime + startTime + duration);
            }
            
            playMelody() {
                if (!this.audioContext || this.isPlaying || this.isMuted) return;
                
                this.isPlaying = true;
                const melody = this.generateCyberpunkMelody();
                let currentTime = 0;
                
                melody.forEach(note => {
                    this.playNote(note.freq, note.duration, currentTime);
                    currentTime += note.duration;
                });
                
                // Loop the melody with slight variation
                setTimeout(() => {
                    this.isPlaying = false;
                    if (this.audioContext.state === 'running' && !this.isMuted) {
                        this.playMelody();
                    }
                }, currentTime * 1000);
            }
            
            start() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                this.isMuted = false; // Start unmuted for better user experience
                this.playMelody();
            }
            
            stop() {
                if (this.audioContext) {
                    this.audioContext.suspend();
                }
                this.isPlaying = false;
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                const muteBtn = document.getElementById('mute-btn');
                if (muteBtn) {
                    muteBtn.classList.toggle('muted', this.isMuted);
                    muteBtn.innerHTML = this.isMuted ? 
                        '<i class="fas fa-volume-mute"></i> Unmute' : 
                        '<i class="fas fa-volume-up"></i> Mute';
                }
                
                if (this.isMuted) {
                    this.stop();
                } else if (this.audioContext && this.audioContext.state === 'running') {
                    this.start();
                }
            }
        }
        
        // Initialize music
        const music = new CyberpunkMusic();
        
        // Global mute function
        function toggleMute() {
            music.toggleMute();
        }
        
        // Start music after user interaction
        document.addEventListener('click', () => {
            if (music.audioContext && music.audioContext.state === 'suspended') {
                music.start();
            }
        }, { once: true });
        
        // Also start music on any keypress
        document.addEventListener('keydown', () => {
            if (music.audioContext && music.audioContext.state === 'suspended') {
                music.start();
            }
        }, { once: true });
        
        // Start music when page loads (if browser allows)
        document.addEventListener('DOMContentLoaded', () => {
            // Try to start music immediately
            if (music.audioContext && music.audioContext.state === 'running') {
                music.start();
            }
        });
        
        // Start music when menu is interacted with
        document.getElementById('menu-overlay').addEventListener('click', () => {
            if (music.audioContext && music.audioContext.state === 'suspended') {
                music.start();
            }
        }, { once: true });
    </script>
</body>
</html>


