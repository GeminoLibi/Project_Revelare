<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMSHOE: The Case of the Glowing Orb</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Special+Elite&family=VT323&display=swap" rel="stylesheet">
    <!-- Google AdSense - Minimal Script (Disabled for testing) -->
    <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3891410174900441"></script> -->
    <style>
        /*
         * GUMSHOE Terminal Aesthetics - Open Source Resources Used:
         *
         * CRT Scanlines Effect: Inspired by classic computer terminal displays
         * Film Grain Animation: CSS-based noise texture simulation
         * Vintage Typography: "Special Elite" font from Google Fonts
         * Atmospheric Gradients: Custom CSS radial/linear gradients
         * Paper Texture Effects: Simulated vintage paper using CSS patterns
         * Glow Effects: Custom text-shadow and box-shadow combinations
         * Background Art: Custom noir detective background image (./noir_background.png)
         * Menu Art: Noir-themed menu background image (./noir_menu.png)
         * Particle Effects: CSS-animated atmospheric particles for immersion
         * Blend Modes: CSS background-blend-mode for art integration
         *
         * All effects are implemented using pure CSS and HTML5 techniques.
         * Background and menu art images are custom assets created for this project.
         */

        :root {
            --background-color: #1a1a1a;
            --text-color: #e0b684;
            --glow-color: #ffc278;
            --border-color: #5a4a3a;
            --accent-color: #8c3a3a;
            --font-main: 'VT323', monospace;
            --font-header: 'Special Elite', cursive;
        }
        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 18px;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
            background-image:
                linear-gradient(180deg, rgba(10, 8, 6, 0.3) 0%, transparent 30%, transparent 70%, rgba(5, 4, 3, 0.4) 100%),
                url('./noir_background.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-blend-mode: normal;
            padding-top: 80px; /* Add space for navigation bar */
        }
        #terminal-container {
            width: 95%;
            max-width: 800px;
            height: calc(100vh - 100px);
            border: 4px solid var(--border-color);
            border-radius: 8px;
            background: radial-gradient(ellipse at center, rgba(41, 36, 30, 0.95) 0%, rgba(26, 26, 26, 0.95) 100%);
            box-shadow: 0 0 10px var(--border-color), 0 0 25px rgba(0, 0, 0, 0.8), inset 0 0 15px rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        #terminal-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Film grain texture */
                radial-gradient(circle at 20% 80%, rgba(120, 119, 121, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(120, 119, 121, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 119, 121, 0.2) 0%, transparent 50%);
            pointer-events: none;
            z-index: 5;
            animation: film-grain 0.5s steps(10) infinite;
        }

        #terminal-container::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* CRT scanlines */
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 0, 0, 0.03) 2px,
                    rgba(0, 0, 0, 0.03) 4px
                ),
                /* Vignette effect */
                radial-gradient(ellipse at center, transparent 40%, rgba(0, 0, 0, 0.4) 100%),
                /* Subtle radial light */
                radial-gradient(circle, rgba(224, 182, 132, 0.08) 20%, rgba(224, 182, 132, 0) 80%);
            pointer-events: none;
            z-index: 10;
            animation: flicker 0.15s infinite, crt-flicker 0.1s infinite;
        }

        @keyframes flicker {
            0% { opacity: 0.8; }
            50% { opacity: 0.9; }
            100% { opacity: 1; }
        }

        @keyframes film-grain {
            0%, 100% { transform: translate(0, 0) }
            10% { transform: translate(-1px, -1px) }
            20% { transform: translate(-1px, 1px) }
            30% { transform: translate(1px, -1px) }
            40% { transform: translate(1px, 1px) }
            50% { transform: translate(-1px, 0) }
            60% { transform: translate(1px, 0) }
            70% { transform: translate(0, -1px) }
            80% { transform: translate(0, 1px) }
            90% { transform: translate(-1px, -1px) }
        }

        @keyframes crt-flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                opacity: 1;
                transform: translateY(0);
            }
            20%, 24%, 55% {
                opacity: 0.94;
                transform: translateY(1px);
            }
            22% {
                opacity: 0.85;
                transform: translateY(2px);
            }
        }
        #header {
            padding: 15px 20px;
            border-bottom: 2px solid var(--border-color);
            text-align: center;
            font-family: var(--font-header);
            font-size: 28px;
            color: var(--accent-color);
            text-shadow:
                2px 2px 4px rgba(0, 0, 0, 0.9),
                0 0 8px var(--glow-color),
                0 0 12px var(--glow-color),
                0 0 16px rgba(139, 69, 19, 0.3);
            flex-shrink: 0;
            background:
                linear-gradient(135deg, rgba(20, 15, 10, 0.8), rgba(40, 35, 30, 0.6)),
                radial-gradient(circle at 30% 70%, rgba(139, 69, 19, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 30%, rgba(160, 82, 45, 0.05) 0%, transparent 50%);
            font-weight: bold;
            position: relative;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        #header::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image:
                radial-gradient(circle at 25% 25%, rgba(139, 69, 19, 0.1) 1px, transparent 1px),
                radial-gradient(circle at 75% 75%, rgba(160, 82, 45, 0.08) 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            opacity: 0.3;
        }

        #money-display {
            position: absolute;
            top: 12px;
            right: 20px;
            font-family: var(--font-main);
            font-size: 16px;
            color: var(--glow-color);
            text-shadow:
                0 0 4px var(--glow-color),
                0 0 8px var(--glow-color),
                1px 1px 2px rgba(0, 0, 0, 0.8);
            background:
                linear-gradient(135deg, rgba(10, 8, 6, 0.9), rgba(20, 16, 12, 0.8)),
                radial-gradient(circle at 30% 70%, rgba(139, 69, 19, 0.2) 0%, transparent 50%);
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid var(--border-color);
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 8px rgba(139, 69, 19, 0.2);
            backdrop-filter: blur(2px);
        }
        #output {
            flex-grow: 1;
            padding: 25px;
            overflow-y: auto;
            text-shadow:
                0 0 3px var(--glow-color),
                1px 1px 2px rgba(0, 0, 0, 0.8);
            line-height: 1.6;
            white-space: pre-wrap;
            background:
                linear-gradient(180deg, rgba(20, 15, 10, 0.1) 0%, transparent 20%, transparent 80%, rgba(10, 8, 6, 0.1) 100%),
                radial-gradient(ellipse at 50% 50%, rgba(139, 69, 19, 0.02) 0%, transparent 70%);
        }
        #input-line {
            display: flex;
            padding: 15px 25px;
            border-top: 2px solid var(--border-color);
            background:
                linear-gradient(135deg, rgba(15, 12, 8, 0.8), rgba(25, 20, 15, 0.6)),
                radial-gradient(circle at 20% 80%, rgba(139, 69, 19, 0.1) 0%, transparent 50%);
            flex-shrink: 0;
            align-items: center;
            position: relative;
        }

        #input-line::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image:
                radial-gradient(circle at 15% 85%, rgba(160, 82, 45, 0.05) 1px, transparent 1px),
                radial-gradient(circle at 85% 15%, rgba(139, 69, 19, 0.03) 1px, transparent 1px);
            background-size: 25px 25px;
            pointer-events: none;
            opacity: 0.4;
        }

        #prompt {
            color: var(--glow-color);
            margin-right: 12px;
            text-shadow:
                0 0 4px var(--glow-color),
                0 0 8px var(--glow-color),
                1px 1px 1px rgba(0, 0, 0, 0.8);
            font-weight: bold;
            font-size: 20px;
        }

        #input {
            background: none;
            border: none;
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 18px;
            width: 100%;
            outline: none;
            text-shadow:
                0 0 3px var(--glow-color),
                1px 1px 1px rgba(0, 0, 0, 0.5);
            caret-color: var(--glow-color);
        }

        #input::selection {
            background-color: rgba(139, 69, 19, 0.4);
            text-shadow: none;
        }
        #output::-webkit-scrollbar {
            width: 12px;
            background: linear-gradient(to bottom, rgba(20, 20, 20, 0.8), rgba(10, 10, 10, 0.8));
        }
        #output::-webkit-scrollbar-track {
            background: linear-gradient(to bottom, rgba(40, 35, 30, 0.6), rgba(26, 26, 26, 0.6));
            border-radius: 6px;
            margin: 2px;
        }
        #output::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, var(--border-color), rgba(139, 69, 19, 0.8));
            border-radius: 6px;
            border: 1px solid rgba(139, 69, 19, 0.3);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        #output::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, var(--glow-color), var(--border-color));
        }
        .game-button {
            background-color: var(--border-color);
            color: var(--text-color);
            border: 1px solid var(--glow-color);
            padding: 5px 10px;
            margin-left: 10px;
            font-family: var(--font-main);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .game-button:hover { background-color: var(--glow-color); color: var(--background-color); text-shadow: none; }
        
        /* Menu Overlay Styles */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            height: 100vh;
            width: 100vw;
            background:
                /* Atmospheric vignette overlay */
                radial-gradient(ellipse at center, rgba(10, 8, 6, 0.6) 0%, rgba(20, 16, 12, 0.4) 30%, rgba(139, 69, 19, 0.1) 70%, rgba(160, 82, 45, 0.05) 100%),
                /* Menu art with blend mode */
                url('./noir_menu.png') center/cover;
            background-blend-mode: normal, normal;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            position: relative;
        }

        .menu-overlay::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Enhanced CRT scanlines for menu */
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 3px,
                    rgba(0, 0, 0, 0.08) 3px,
                    rgba(0, 0, 0, 0.08) 6px
                ),
                /* Film grain overlay */
                radial-gradient(circle at 20% 80%, rgba(120, 119, 121, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(120, 119, 121, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 60% 40%, rgba(120, 119, 121, 0.1) 0%, transparent 50%);
            animation: menu-grain 0.4s steps(10) infinite;
            pointer-events: none;
            opacity: 0.6;
        }

        .menu-overlay::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                /* Warm light rays */
                radial-gradient(circle at 25% 25%, rgba(224, 182, 132, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 75% 75%, rgba(160, 82, 45, 0.08) 0%, transparent 40%),
                /* Corner vignette */
                linear-gradient(135deg, rgba(0, 0, 0, 0.3) 0%, transparent 30%, transparent 70%, rgba(0, 0, 0, 0.3) 100%);
            pointer-events: none;
            animation: menu-atmosphere 8s ease-in-out infinite alternate;
        }

        @keyframes menu-atmosphere {
            0% { opacity: 0.7; }
            100% { opacity: 0.9; }
        }

        /* Atmospheric particles for menu art */
        .menu-particles {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 5;
        }

        .menu-particles::before,
        .menu-particles::after {
            content: '';
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(224, 182, 132, 0.6);
            border-radius: 50%;
            animation: particle-float 6s ease-in-out infinite;
        }

        .menu-particles::before {
            top: 20%;
            left: 15%;
            animation-delay: 0s;
            animation-duration: 8s;
        }

        .menu-particles::after {
            top: 60%;
            right: 20%;
            animation-delay: 2s;
            animation-duration: 10s;
        }

        @keyframes particle-float {
            0%, 100% {
                transform: translateY(0) translateX(0);
                opacity: 0.3;
            }
            25% {
                transform: translateY(-20px) translateX(10px);
                opacity: 0.6;
            }
            50% {
                transform: translateY(-10px) translateX(-5px);
                opacity: 0.4;
            }
            75% {
                transform: translateY(-30px) translateX(15px);
                opacity: 0.7;
            }
        }

        /* Add particles to menu overlay */
        .menu-overlay .menu-particles {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
        }

        /* Background art atmospheric enhancements */
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background:
                radial-gradient(circle at 20% 30%, rgba(139, 69, 19, 0.05) 0%, transparent 30%),
                radial-gradient(circle at 80% 70%, rgba(160, 82, 45, 0.03) 0%, transparent 30%),
                linear-gradient(45deg, transparent 40%, rgba(120, 119, 121, 0.02) 50%, transparent 60%);
            pointer-events: none;
            z-index: -1;
            animation: background-atmosphere 15s ease-in-out infinite;
        }

        @keyframes background-atmosphere {
            0%, 100% {
                opacity: 0.6;
                transform: scale(1);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.02);
            }
        }

        /* Subtle background art movement for immersion */
        body {
            animation: background-float 20s ease-in-out infinite;
        }

        @keyframes background-float {
            0%, 100% {
                background-position: center;
            }
            25% {
                background-position: center 10px;
            }
            50% {
                background-position: center -5px;
            }
            75% {
                background-position: center 5px;
            }
        }

        @keyframes menu-grain {
            0%, 100% { transform: translate(0, 0) }
            25% { transform: translate(-0.5px, -0.5px) }
            50% { transform: translate(0.5px, -0.5px) }
            75% { transform: translate(-0.5px, 0.5px) }
        }
        
        .menu-content {
            text-align: center;
            padding: 50px;
            position: relative;
            z-index: 10;
            backdrop-filter: blur(1px);
            border-radius: 8px;
            border: 1px solid rgba(139, 69, 19, 0.3);
            background: rgba(10, 8, 6, 0.1);
            box-shadow:
                0 0 20px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(139, 69, 19, 0.05);
        }

        .menu-content::before {
            content: '';
            position: absolute;
            top: -2px; left: -2px; right: -2px; bottom: -2px;
            background: linear-gradient(45deg, transparent, rgba(139, 69, 19, 0.1), transparent);
            border-radius: 10px;
            z-index: -1;
            animation: menu-glow 3s ease-in-out infinite alternate;
        }

        @keyframes menu-glow {
            0% { opacity: 0.3; }
            100% { opacity: 0.6; }
        }

        .menu-title {
            font-family: var(--font-header);
            font-size: 52px;
            color: var(--accent-color);
            text-shadow:
                3px 3px 6px rgba(0, 0, 0, 0.9),
                0 0 12px var(--glow-color),
                0 0 18px var(--glow-color),
                0 0 24px rgba(139, 69, 19, 0.5);
            margin-bottom: 15px;
            letter-spacing: 3px;
            font-weight: bold;
            text-transform: uppercase;
            position: relative;
        }

        .menu-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--glow-color), transparent);
            box-shadow: 0 0 10px var(--glow-color);
        }

        .menu-subtitle {
            font-family: var(--font-main);
            font-size: 26px;
            color: var(--text-color);
            margin-bottom: 45px;
            text-shadow:
                2px 2px 4px rgba(0, 0, 0, 0.9),
                0 0 6px var(--glow-color),
                0 0 8px rgba(139, 69, 19, 0.3);
            font-weight: 600;
            line-height: 1.3;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .menu-btn {
            background:
                linear-gradient(135deg, rgba(15, 12, 8, 0.9), rgba(25, 20, 15, 0.8)),
                radial-gradient(circle at 30% 70%, rgba(139, 69, 19, 0.15) 0%, transparent 50%);
            border: 3px solid var(--border-color);
            color: var(--text-color);
            font-family: var(--font-main);
            font-size: 20px;
            padding: 18px 45px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow:
                0 0 4px var(--glow-color),
                1px 1px 2px rgba(0, 0, 0, 0.8);
            min-width: 220px;
            backdrop-filter: blur(8px);
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 0 12px rgba(139, 69, 19, 0.2);
            position: relative;
            overflow: hidden;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%; right: 100%; bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: all 0.5s;
        }

        .menu-btn:hover::before {
            left: -50%;
            right: -50%;
        }
        
        .menu-btn:hover {
            background:
                linear-gradient(135deg, var(--border-color), rgba(139, 69, 19, 0.8)),
                radial-gradient(circle at 30% 70%, rgba(160, 82, 45, 0.2) 0%, transparent 50%);
            color: var(--background-color);
            text-shadow: none;
            box-shadow:
                0 6px 12px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 0 20px var(--glow-color),
                0 0 30px rgba(139, 69, 19, 0.4);
            transform: translateY(-2px);
            border-color: var(--glow-color);
        }
        
        .menu-overlay.hidden {
            display: none;
        }
        
        /* Music Controls */
        .music-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            display: flex;
            gap: 12px;
            backdrop-filter: blur(4px);
        }
        
        .music-btn {
            background:
                linear-gradient(135deg, rgba(10, 8, 6, 0.8), rgba(20, 16, 12, 0.7)),
                radial-gradient(circle at 30% 70%, rgba(139, 69, 19, 0.1) 0%, transparent 50%);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            padding: 10px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-family: var(--font-main);
            font-size: 14px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 0 0 2px var(--glow-color);
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .music-btn::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.05) 50%, transparent 70%);
            transform: translateX(-100%);
            transition: transform 0.5s;
        }

        .music-btn:hover::before {
            transform: translateX(100%);
        }

        .music-btn:hover {
            background:
                linear-gradient(135deg, var(--border-color), rgba(139, 69, 19, 0.6)),
                radial-gradient(circle at 30% 70%, rgba(160, 82, 45, 0.15) 0%, transparent 50%);
            color: var(--background-color);
            text-shadow: none;
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 0 12px var(--glow-color);
            transform: translateY(-1px);
        }
        
        .music-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: var(--accent-color);
        }
        
        .music-btn.muted {
            background: linear-gradient(135deg, rgba(80, 0, 0, 0.8), rgba(120, 0, 0, 0.7));
            border-color: #8b0000;
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(139, 0, 0, 0.3);
        }
        
        .npc-name {
            color: #8B0000; /* Dark red for noir theme */
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
    </style>
    
    <!-- Smart navigation will be loaded dynamically -->
</head>
<body>
    <!-- Navigation Container -->
    <div id="navigation-container"></div>

    <!-- Music Controls -->
    <div class="music-controls">
        <button id="mute-btn" class="music-btn" onclick="toggleMute()">
            <i class="fas fa-volume-mute"></i> Mute
        </button>
    </div>

    <div id="terminal-container">
        <!-- Menu Screen Overlay -->
        <div id="menu-overlay" class="menu-overlay">
            <div class="menu-particles"></div>
            <div class="menu-content">
                <h1 class="menu-title">GUMSHOE</h1>
                <p class="menu-subtitle">The Case of the Glowing Orb</p>
                <div class="menu-buttons">
                    <button id="new-game-btn" class="menu-btn">NEW GAME</button>
                    <button id="load-game-btn" class="menu-btn">LOAD GAME</button>
                </div>
            </div>
        </div>
        
        <div id="header">
            THE CASE OF THE GLOWING ORB
            <div id="money-display">$0</div>
        </div>
        <div id="output"></div>
        <div id="input-line">
            <span id="prompt">&gt;</span>
            <input type="text" id="input" autocomplete="off" autofocus>
        </div>
        <div id="controls" style="padding: 0 20px 10px; border-top: 1px solid var(--border-color); background-color: rgba(0,0,0,0.2); text-align: right;">
            <button id="new-game-btn" class="game-button">New Game</button>
            <button id="save-game-btn" class="game-button">Save</button>
            <button id="load-game-btn" class="game-button">Load</button>
        </div>
    </div>

    <script>
        // === SIMPLIFIED DEBUG SCRIPT ===
        console.log('🔍 DEBUG: Script starting...');
        
        // API Configuration
        console.log('🔍 DEBUG: Setting API_BASE_URL...');
        const API_BASE_URL = (window.location.hostname === 'localhost') ? null : 'https://project-revelare-backend.liberatorgeminorum.workers.dev';
        console.log('✅ DEBUG: API_BASE_URL set to:', API_BASE_URL);
        
        // --- DOM ELEMENTS ---
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const newGameBtn = document.getElementById('new-game-btn');
        const saveGameBtn = document.getElementById('save-game-btn');
        const loadGameBtn = document.getElementById('load-game-btn');

        // --- FULL GAME LOGIC OBJECT ---
        console.log('🔍 DEBUG: Creating game object...');
        
        // TEMPORARILY COMMENT OUT GAME OBJECT TO TEST
        const game = {
            // --- STATE ---
            state: {},

            // --- INITIALIZATION ---
            init(isLoad = false) {
                if (!isLoad) {
                    this.state = this.getInitialState();
                }
                output.innerHTML = '';
                this.updateMoneyDisplay(); // Update money display immediately
                this.typeWriter(this.getIntroText(), 'normal');
                setTimeout(() => {
                    this.handleLook([]);
                    this.showStatus();
                }, 2000);
            },

            getInitialState() {
                const attributes = this.rollAttributes();
                const background = this.assignHiddenBackground();
                const startingState = {
                    journal: [
                        "The case of the 'Glowing Orb' just landed on my desk. Feels like trouble already.",
                        "Client: Mrs. Evelyn Blackwood - wealthy widow, claims her husband's death wasn't an accident.",
                        "The 'orb' is actually a rare diamond that disappeared the night he died.",
                        "Three suspects: His business partner, his mistress, and his estranged son.",
                        "But something doesn't add up. The police called it a suicide. She says murder.",
                        "You feel different today. Your background traits seem more pronounced. People look at you differently."
                    ],
                    health: 5,
                    inventory: [],
                    discoveredCoords: new Set(['0,0,0']),
                    playerPos: { x: 0, y: 0, z: 0 },
                    gameOver: false,
                    won: false,
                    equippedWeapon: "fists",
                    playerConditions: new Set(),
                    time: { hour: 20, minute: 0, day: 1 },
                    gameState: {
                        deskSearched: false,
                        lockboxOpened: false,
                        cratesSearched: false,
                        suspicionLevel: 0,
                        stressLevel: 0,
                        hunger: 0,
                        // Dynamic world state
                        npcRelationships: {
                            "bartender": { trust: 0, fear: 0, gratitude: 0 },
                            "bum": { trust: 0, fear: 0, gratitude: 0 },
                            "izzy": { trust: 0, fear: 0, gratitude: 0 },
                            "johnny": { trust: 0, fear: 0, gratitude: 0 },
                            "guard": { trust: 0, fear: 0, gratitude: 0 },
                            "landlord": { trust: -2, fear: 0, gratitude: 0 },
                            "regular": { trust: 0, fear: 0, gratitude: 0 },
                            "dock_worker": { trust: 0, fear: 1, gratitude: 0 },
                            "fisherman": { trust: 0, fear: 0, gratitude: 0 },
                            "desk_sergeant": { trust: 0, fear: 1, gratitude: 0 },
                            "detective_morrison": { trust: -1, fear: 1, gratitude: 0 }
                        },
                        worldEvents: {
                            powerSurges: 0,
                            policeActivity: 0,
                            strangeLights: 0,
                            whispers: 0
                        },
                        reputation: {
                            police: 0,
                            criminals: 0,
                            civilians: 0
                        },
                        // New story elements
                        blackwoodCase: {
                            interviewedWidow: false,
                            interviewedPartner: false,
                            interviewedMistress: false,
                            interviewedSon: false,
                            foundDiamond: false,
                            discoveredTruth: false,
                            trustLevel: 0, // -5 to +5, affects ending
                            evidenceCollected: []
                        },
                        sideQuests: {
                            missingGirl: { active: false, completed: false, trustGained: 0 },
                            corruptCop: { active: false, completed: false, trustGained: 0 },
                            gamblingDebt: { active: false, completed: false, trustGained: 0 },
                            blackmailCase: { active: false, completed: false, trustGained: 0 }
                        },
                        relationships: {
                            widow: 0,      // -5 to +5
                            partner: 0,     // -5 to +5  
                            mistress: 0,    // -5 to +5
                            son: 0,         // -5 to +5
                            bartender: 0,   // -5 to +5
                            informant: 0    // -5 to +5
                        },
                        // Hidden background system
                        playerBackground: background,
                        backgroundReputation: {
                            ex_cop: 0,      // -5 to +5
                            ex_mob: 0,      // -5 to +5
                            ex_military: 0, // -5 to +5
                            ex_lawyer: 0,   // -5 to +5
                            ex_reporter: 0, // -5 to +5
                            ex_con: 0       // -5 to +5
                        },
                        // Theft tracking
                        stolenItems: [],
                        // Conversation tracking
                        conversationHistory: {},
                        // New systems for epic gameplay
                        randomEncounters: [],
                        loreItems: [],
                        persistentNPCs: {},
                        sideQuests: [],
                        completedQuests: [],
                        skillPoints: 0,
                        skills: {
                            investigation: 0,
                            deduction: 0,
                            intimidation: 0,
                            persuasion: 0,
                            stealth: 0,
                            lockpicking: 0,
                            hacking: 0,
                            combat: 0
                        },
                        reputation: {
                            police: 0,
                            criminals: 0,
                            informants: 0,
                            civilians: 0
                        },
                        relationships: {},
                        discoveredSecrets: [],
                        timeBasedEvents: [],
                        worldState: {
                            weather: 'foggy',
                            temperature: 'cold',
                            crimeLevel: 'high',
                            policeActivity: 'moderate'
                        },
                        // Advanced systems
                        achievements: [],
                        trophies: [],
                        factionLoyalty: {
                            police: 0,
                            mob: 0,
                            informants: 0,
                            civilians: 0
                        },
                        romance: {},
                        crafting: {
                            materials: {},
                            recipes: {},
                            tools: []
                        },
                        economy: {
                            marketPrices: {},
                            inflation: 1.0,
                            blackMarket: false
                        },
                        combat: {
                            tactics: [],
                            specialMoves: [],
                            equipment: {}
                        },
                        mystery: {
                            clues: [],
                            redHerrings: [],
                            suspects: [],
                            timeline: []
                        },
                        memory: {
                            patterns: [],
                            sequences: [],
                            faces: []
                        }
                    },
                    attributes: attributes,
                    cash: this.rollStartingCash(attributes.luck),
                    debt: 0,
                    bills: {
                        rent: { amount: 800, dueDay: 5, lateFee: 200, paid: false },
                        utilities: { amount: 200, dueDay: 3, lateFee: 50, paid: false }
                    },
                    contracts: this.generateContracts(),
                    activeContracts: [],
                    worldMap: JSON.parse(JSON.stringify(this.data.worldMap)), // Deep copy for mutable state
                    npcStats: JSON.parse(JSON.stringify(this.data.npcStats)),
                };
                this.updateNpcs(startingState);
                return startingState;
            },
            
            // Port of all python logic into JS...
            
            // --- CORE MECHANICS ---
            rollAttributes() {
                const roll4d6DropLowest = () => {
                    let rolls = Array(4).fill(0).map(() => Math.floor(Math.random() * 6) + 1);
                    rolls.sort((a, b) => a - b);
                    return rolls.slice(1).reduce((sum, val) => sum + val, 0);
                };
                return {
                    constitution: roll4d6DropLowest(), perception: roll4d6DropLowest(),
                    dexterity: roll4d6DropLowest(), charisma: roll4d6DropLowest(),
                    strength: roll4d6DropLowest(), luck: roll4d6DropLowest(),
                };
            },

            rollStartingCash(luck) {
                 const luckModifier = Math.floor((luck - 10) / 2);
                 return Math.max(20, Math.floor(Math.random() * 151) + 50 + (luckModifier * 25));
            },

            assignHiddenBackground() {
                const backgrounds = [
                    {
                        name: "Ex-Cop",
                        trait: "police instincts",
                        bonuses: { perception: 2, constitution: 1 },
                        description: "You have an eye for detail and know how to read people.",
                        backgroundAbility: "Police Training - bonus to investigation and intimidation",
                        clues: ["You notice things others miss", "You have a cop's way of looking at people", "You know police procedure"],
                        backstory: "They say once a cop, always a cop. You were a detective in the 23rd precinct before the corruption got too thick. You saw too much - dirty politicians, bent judges, cops on the take. When you tried to blow the whistle, they framed you for evidence tampering. Now you're out here in the rain, solving cases for the little guy while the badges who should be upholding the law are too busy lining their pockets.",
                        events: [
                            {
                                trigger: "visit_precinct",
                                chance: 0.6,
                                message: "As you step into the 44th Precinct, you feel eyes on you. A uniformed officer you recognize from your old days mutters 'Hey, ain't that the rat who got demoted?' The room goes quiet. Your old partner catches your eye but looks away.",
                                consequences: () => {
                                    this.state.gameState.suspicionLevel += 1;
                                    this.state.gameState.reputation.police -= 2;
                                }
                            },
                            {
                                trigger: "talk_police",
                                chance: 0.4,
                                message: "The cop you're talking to suddenly gets cagey. 'You were one of us once, detective. Or should I say, ex-detective?' Word about your disgrace has spread through the department.",
                                consequences: () => {
                                    this.state.gameState.npcRelationships["guard"].trust -= 2;
                                }
                            }
                        ],
                        specialInteractions: {
                            "guard": "The beat cop eyes you suspiciously. 'I know you. You were that detective they canned for... what was it again?'",
                            "bartender": "The bartender slides you a beer on the house. 'Heard about what happened to you at the 23rd. Dirty business.'"
                        }
                    },
                    {
                        name: "Ex-Mob",
                        trait: "street smarts",
                        bonuses: { charisma: 2, strength: 1 },
                        description: "You know how the underworld works and can handle yourself.",
                        backgroundAbility: "Street Connections - bonus to intimidation and underworld contacts",
                        clues: ["You know how to handle yourself in a fight", "You understand the criminal mind", "You have connections in low places"],
                        backstory: "You grew up on these mean streets. Started as a runner for the Gallo family, worked your way up to lieutenant. But you got soft - started thinking about going legit, maybe opening a restaurant or something. The boss didn't like that. 'Once you're in, you're in for life,' he said. So you faked your death and disappeared into the night. Now you use your street smarts to help people who can't go to the cops.",
                        events: [
                            {
                                trigger: "visit_casino",
                                chance: 0.5,
                                message: "A slick-looking gambler approaches you at the casino. 'Hey, ain't you that guy who was supposed to be sleeping with the fishes? The boss is still looking for you.' He slips away before you can respond, but you notice the casino security watching you more closely.",
                                consequences: () => {
                                    this.state.gameState.suspicionLevel += 2;
                                    this.state.gameState.reputation.criminals += 1;
                                }
                            },
                            {
                                trigger: "talk_bartender",
                                chance: 0.3,
                                message: "The bartender leans in close. 'Word on the street is you're the guy who walked away from the Gallo family. That's either very brave or very stupid. Either way, you might want to watch your back.'",
                                consequences: () => {
                                    this.state.journal.push("Bartender warned me about mob heat. Need to be careful.");
                                }
                            }
                        ],
                        specialInteractions: {
                            "bartender": "The bartender gives you a knowing nod. 'You look like someone who knows how things really work around here.'",
                            "bum": "The street bum recognizes you. 'Hey, you used to run with the Gallos! You still connected?'"
                        }
                    },
                    {
                        name: "Ex-Military",
                        trait: "discipline",
                        bonuses: { constitution: 2, strength: 1 },
                        description: "You're tough, disciplined, and know how to follow orders.",
                        backgroundAbility: "Military Training - bonus to combat and endurance",
                        clues: ["You move with military precision", "You're tougher than most", "You have a soldier's bearing"],
                        backstory: "You served your country in the Pacific theater. Saw action at Guadalcanal, the Philippines, Okinawa. Came back a hero with a chest full of medals and a head full of nightmares. The VA hospital couldn't help with the memories - the screams of dying men, the smell of cordite and blood. You tried to readjust to civilian life, but the discipline that kept you alive over there made it hard to hold down a desk job. That's when you became a private investigator - using your training to help people who couldn't help themselves.",
                        events: [
                            {
                                trigger: "combat_success",
                                chance: 0.4,
                                message: "As you finish the fight, memories flood back - the jungles of Guadalcanal, the bayonet training, the discipline that kept you alive. You move with the precision of a well-oiled machine, but the old nightmares threaten to surface.",
                                consequences: () => {
                                    this.state.gameState.stressLevel += 1;
                                    // But also gain a temporary combat bonus
                                    this.state.playerConditions.add('battle_hardened');
                                    setTimeout(() => {
                                        this.state.playerConditions.delete('battle_hardened');
                                    }, 30000); // 5 minutes
                                }
                            },
                            {
                                trigger: "talk_veteran",
                                chance: 0.6,
                                message: "The old bum you're talking to suddenly stands straighter. 'You served, didn't you? I can tell. Guadalcanal? Philippines? You got that look.' He shares stories from the war that make your own memories resurface.",
                                consequences: () => {
                                    this.state.gameState.stressLevel += 1;
                                    this.state.gameState.npcRelationships["bum"].trust += 3;
                                }
                            }
                        ],
                        specialInteractions: {
                            "guard": "The cop salutes you unconsciously. 'Thank you for your service, sir.'",
                            "bartender": "The bartender pours you a stiff drink. 'On the house, soldier. You earned it.'"
                        }
                    },
                    {
                        name: "Ex-Lawyer",
                        trait: "legal knowledge",
                        bonuses: { charisma: 2, perception: 1 },
                        description: "You know the law and how to argue your case.",
                        backgroundAbility: "Legal Expertise - bonus to persuasion and investigation",
                        clues: ["You think like a lawyer", "You know legal procedures", "You're good at reading people"],
                        backstory: "You were a rising star at Cromwell, Wentworth & Stone, the most prestigious law firm in the city. Corporate law paid the bills, but you dreamed of being a trial lawyer, fighting for the little guy. Then came the Blackwood Industries case. You were supposed to bury the evidence of their illegal dumping, but you couldn't do it. You leaked the documents to the press instead. They disbarred you, called you an 'ethical liability.' Now you use your legal knowledge to help people navigate the corrupt system you used to be part of.",
                        events: [
                            {
                                trigger: "visit_precinct",
                                chance: 0.7,
                                message: "At the precinct, a detective recognizes you. 'Hey, you're that lawyer who got disbarred for leaking evidence! You think you're above the law?' The desk sergeant tells you to leave before they arrest you for trespassing.",
                                consequences: () => {
                                    this.state.gameState.suspicionLevel += 2;
                                    this.state.gameState.reputation.police -= 3;
                                }
                            },
                            {
                                trigger: "examine_evidence",
                                chance: 0.5,
                                message: "Looking at this evidence, you immediately spot the legal irregularities. This case file has been tampered with - pages reordered, signatures forged. Your legal training kicks in automatically.",
                                consequences: () => {
                                    this.state.gameState.blackwoodCase.evidenceCollected.push("Legal irregularities discovered in case file");
                                    this.state.journal.push("Legal analysis: Case file shows signs of tampering. Someone high up is covering their tracks.");
                                }
                            }
                        ],
                        specialInteractions: {
                            "sterling": "Richard Sterling recognizes you. 'You were that lawyer who tried to take down Blackwood Industries. You're lucky they only disbarred you.'",
                            "bartender": "The bartender chuckles. 'A lawyer walks into a bar... Oh wait, that's you. What's the difference between a lawyer and a liar? The spelling.'"
                        }
                    },
                    {
                        name: "Ex-Reporter",
                        trait: "investigative instincts",
                        bonuses: { perception: 2, charisma: 1 },
                        description: "You know how to dig for the truth and get people to talk.",
                        backgroundAbility: "Investigative Skills - bonus to investigation and social interaction",
                        clues: ["You're naturally curious", "You know how to ask the right questions", "You have a nose for news"],
                        backstory: "You were a star reporter for the Daily Herald, the kind of journalist who won Pulitzers and made politicians sweat. Your exposé on police corruption in the 23rd precinct made you famous - and got you fired. The police commissioner was your source's uncle, and when the story ran, they raided the newsroom looking for 'leaked evidence.' The publisher threw you under the bus to save the paper. Now you're a private investigator, using your reporting skills to uncover truths that the mainstream press is too scared to touch.",
                        events: [
                            {
                                trigger: "read_newspaper",
                                chance: 0.8,
                                message: "Reading this newspaper story, you immediately spot the inconsistencies. The byline is from your old rival at the Herald - the same hack who stole your sources. You could call him out, but it might burn bridges.",
                                consequences: () => {
                                    this.state.journal.push("Newspaper story riddled with inaccuracies. Old rival at Herald still cutting corners.");
                                }
                            },
                            {
                                trigger: "talk_informant",
                                chance: 0.5,
                                message: "As you talk to this informant, your reporter instincts kick in. You notice the telltale signs of someone who's been coached - rehearsed phrases, nervous glances. This guy is feeding you a story, not the truth.",
                                consequences: () => {
                                    this.state.gameState.relationships.informant -= 2;
                                    this.state.journal.push("Informant seems unreliable - story sounds rehearsed. Need to verify independently.");
                                }
                            }
                        ],
                        specialInteractions: {
                            "bartender": "The bartender slides you a drink. 'You were that reporter who exposed the 23rd precinct scandal. Buy you a drink?'",
                            "newspaper_boy": "The newspaper boy recognizes you. 'Hey, you're that reporter they fired! You gonna write another exposé?'"
                        }
                    },
                    {
                        name: "Ex-Con",
                        trait: "survival instincts",
                        bonuses: { strength: 2, constitution: 1 },
                        description: "You've been through hell and know how to survive.",
                        backgroundAbility: "Survival Instincts - bonus to combat and endurance",
                        clues: ["You're tougher than you look", "You know how to survive", "You have a criminal's instincts"],
                        backstory: "You did ten years at Sing Sing for armed robbery. The kind where you point a gun at someone and tell them to hand over the cash. But you weren't always bad - you were a kid from the wrong side of the tracks, father drank himself to death, mother worked three jobs just to keep food on the table. The bank job was supposed to be the score that set you up for life, but the guard had a itchy trigger finger. You got out three years ago, parole hanging over your head like a guillotine. Now you solve cases for people who can't trust the cops - using the same street smarts that kept you alive in the joint.",
                        events: [
                            {
                                trigger: "visit_prison_area",
                                chance: 0.6,
                                message: "As you walk through this neighborhood, you feel eyes on you. A couple of ex-cons you knew from Sing Sing spot you. 'Hey, look who it is! The bank robber who got out early. You still owe me twenty bucks from the canteen.'",
                                consequences: () => {
                                    this.state.gameState.suspicionLevel += 1;
                                    this.state.gameState.reputation.criminals += 2;
                                }
                            },
                            {
                                trigger: "talk_guard",
                                chance: 0.5,
                                message: "The guard you're talking to gets a strange look. 'You look familiar. Weren't you in the papers? Armed robbery, right? What makes you think I should talk to you?'",
                                consequences: () => {
                                    this.state.gameState.npcRelationships["guard"].trust -= 3;
                                    this.state.gameState.suspicionLevel += 1;
                                }
                            }
                        ],
                        specialInteractions: {
                            "guard": "The guard eyes you warily. 'I know your type. What are you really doing here?'",
                            "bartender": "The bartender pours you a drink. 'Heard you did time. You look like you can handle yourself.'"
                        }
                    }
                ];
                
                const selectedBackground = backgrounds[Math.floor(Math.random() * backgrounds.length)];
                
                return {
                    ...selectedBackground,
                    discovered: false,
                    cluesFound: 0
                };
            },

            generateContracts() {
                const contractTypes = [
                    { 
                        type: "Missing Person", 
                        description: "Find Sarah Chen, a young woman who disappeared from the docks three days ago", 
                        payout: 200, 
                        target_location: "docks",
                        storyImpact: "missingGirl",
                        trustReward: 2
                    },
                    { 
                        type: "Corruption Investigation", 
                        description: "Gather evidence on Detective Morrison's shady dealings with local criminals", 
                        payout: 300, 
                        target_location: "precinct",
                        storyImpact: "corruptCop",
                        trustReward: 3
                    },
                    { 
                        type: "Debt Collection", 
                        description: "Help Big Tony collect from a deadbeat gambler at the casino", 
                        payout: 150, 
                        target_location: "casino",
                        storyImpact: "gamblingDebt",
                        trustReward: 1
                    },
                    { 
                        type: "Blackmail Case", 
                        description: "Find out who's been sending threatening letters to the mayor's daughter", 
                        payout: 250, 
                        target_location: "city_hall",
                        storyImpact: "blackmailCase",
                        trustReward: 2
                    }
                ];
                
                const contracts = [];
                for (let i = 0; i < 3; i++) {
                    const contract = JSON.parse(JSON.stringify(contractTypes[Math.floor(Math.random() * contractTypes.length)]));
                    contract.completed = false;
                    contracts.push(contract);
                }
                return contracts;
            },

            attributeCheck(attribute, difficultyClass) {
                const roll = Math.floor(Math.random() * 20) + 1;
                let modifier = Math.floor((this.state.attributes[attribute] - 10) / 2);

                if (this.state.playerConditions.has('crippled_leg') && ['dexterity', 'strength'].includes(attribute)) modifier -= 2;
                if (this.state.playerConditions.has('concussion') && ['perception', 'charisma'].includes(attribute)) modifier -= 2;

                // Apply subtle background bonuses
                const background = this.state.gameState.playerBackground;
                if (background.name === "Ex-Cop" && (attribute === "perception" || attribute === "charisma")) modifier += 1;
                if (background.name === "Ex-Mob" && (attribute === "charisma" || attribute === "strength")) modifier += 1;
                if (background.name === "Ex-Military" && (attribute === "constitution" || attribute === "strength")) modifier += 1;
                if (background.name === "Ex-Lawyer" && (attribute === "charisma" || attribute === "perception")) modifier += 1;
                if (background.name === "Ex-Reporter" && (attribute === "perception" || attribute === "charisma")) modifier += 1;
                if (background.name === "Ex-Con" && (attribute === "strength" || attribute === "constitution")) modifier += 1;

                const stressPenalty = -this.state.gameState.stressLevel;
                const hungerPenalty = -this.state.gameState.hunger;
                const total = roll + modifier + stressPenalty + hungerPenalty;
                const success = total >= difficultyClass;

                if (roll === 20) return { result: "critical_success", total };
                if (roll === 1) return { result: "critical_failure", total };
                return { result: success ? "success" : "failure", total };
            },

            advanceTime(minutes) {
                this.state.time.minute += minutes;
                const hoursPassed = Math.floor(this.state.time.minute / 60);
                if (hoursPassed > 0) {
                    this.state.time.minute %= 60;
                    for (let i = 0; i < hoursPassed; i++) {
                        this.state.time.hour++;
                        if (this.state.time.hour >= 24) {
                            this.state.time.hour = 0;
                            this.state.time.day++;
                            this.processDailyEvents();
                        }
                    }
                    this.updateNpcs(this.state);
                }
            },
            
            processDailyEvents() {
                this.outputText("The city sleeps, but you don't. A new day begins...", 'cyan');
                this.state.gameState.hunger = Math.min(3, this.state.gameState.hunger + 1);
                if (this.state.gameState.hunger > 1) {
                    this.outputText("Your stomach growls. You need to eat something soon.", 'warning');
                }
                for (const [billName, details] of Object.entries(this.state.bills)) {
                    if (!details.paid && this.state.time.day > details.dueDay) {
                         this.outputText(`Your ${billName} is overdue! A $${details.lateFee} late fee has been added to your debt.`, 'fail');
                         this.state.debt += details.amount + details.lateFee;
                         details.paid = true; // Mark as overdue
                         this.state.gameState.stressLevel = Math.min(5, this.state.gameState.stressLevel + 1);
                    }
                }
            },
            
            updateNpcs(state) {
                // Skip NPC spawning if data is still encrypted
                if (typeof this.data === 'string') {
                    return;
                }
                
                const currentHour = state.time.hour;
                const currentDay = state.time.day;
                
                // Clear all NPCs
                for (const room of Object.values(state.worldMap)) {
                    if (room.npcs) room.npcs = {};
                }
                
                // Place scheduled NPCs
                for (const [npcName, schedule] of Object.entries(this.data.npcSchedules)) {
                    for (const [[start, end], locationName] of Object.entries(schedule)) {
                        const isActive = (start <= end) ? (currentHour >= start && currentHour < end) : (currentHour >= start || currentHour < end);
                        if (isActive && locationName) {
                            for (const room of Object.values(state.worldMap)) {
                                if (room.name.toLowerCase().includes(locationName.toLowerCase())) {
                                    if (!room.npcs) room.npcs = {};
                                    room.npcs[npcName] = this.data.getNpcDesc(npcName) || `A <span class="npc-name">${npcName.toLowerCase()}</span> is here.`;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Add random flavor NPCs and events
                this.spawnRandomEvents(state, currentHour, currentDay);
            },
            
            spawnRandomEvents(state, hour, day) {
                // Random flavor NPCs that appear based on time and location
                const flavorNpcs = {
                    "street_vendor": { 
                        locations: ["Main Street", "The Alley"], 
                        times: [8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
                        desc: "A street vendor pushes a cart of hot dogs. 'Get your dogs here! Fresh off the grill!'",
                        actions: ["buy_food", "ask_directions"]
                    },
                    "newspaper_boy": { 
                        locations: ["Main Street", "The Bar"], 
                        times: [6, 7, 8, 18, 19, 20],
                        desc: "A young newspaper boy shouts headlines. 'Extra! Extra! Read all about it! Blackwood suicide rocks city!'",
                        actions: ["buy_paper", "ask_news"]
                    },
                    "beat_cop": { 
                        locations: ["Main Street", "The Alley", "Warehouse District"], 
                        times: [14, 15, 16, 17, 18, 19, 20, 21, 22],
                        desc: "A beat cop walks his patrol, nightstick tapping rhythmically against his leg.",
                        actions: ["ask_crime", "report_suspicious"]
                    },
                    "drunk": { 
                        locations: ["The Bar", "The Alley"], 
                        times: [20, 21, 22, 23, 0, 1, 2, 3],
                        desc: "A drunk stumbles past, muttering about 'the glow' and 'things that shouldn't be'.",
                        actions: ["help_drunk", "ignore"]
                    },
                    "mysterious_stranger": { 
                        locations: ["The Docks", "XAI Lab"], 
                        times: [23, 0, 1, 2, 3, 4, 5],
                        desc: "A figure in a dark coat watches from the shadows. They seem to be waiting for something.",
                        actions: ["approach", "observe", "avoid"]
                    }
                };
                
                // Spawn random NPCs
                for (const [npcType, npcData] of Object.entries(flavorNpcs)) {
                    if (npcData.times.includes(hour) && Math.random() < 0.3) {
                        const location = npcData.locations[Math.floor(Math.random() * npcData.locations.length)];
                        for (const room of Object.values(state.worldMap)) {
                            if (room.name.toLowerCase().includes(location.toLowerCase())) {
                                if (!room.npcs) room.npcs = {};
                                room.npcs[npcType] = npcData.desc;
                                break;
                            }
                        }
                    }
                }
                
                // Random events that can trigger consequences
                this.triggerRandomEvents(state, hour, day);
            },
            
            triggerRandomEvents(state, hour, day) {
                // Only trigger events occasionally to avoid spam
                if (Math.random() > 0.1) return;
                
                const events = [
                    {
                        name: "power_surge",
                        condition: () => hour >= 22 || hour <= 6,
                        message: "The streetlights flicker and dim. Something is draining power from the grid.",
                        consequence: () => {
                            this.state.journal.push("Power surges detected in the city. Something is consuming massive amounts of electricity.");
                            this.outputText("You feel a strange tingling in the air. The power grid is unstable.", 'yellow');
                        }
                    },
                    {
                        name: "police_sirens",
                        condition: () => hour >= 20 && hour <= 23,
                        message: "Police sirens wail in the distance. Another crime in the city that never sleeps.",
                        consequence: () => {
                            this.state.journal.push("Police activity increased. The city is getting more dangerous.");
                            this.outputText("The sound of sirens echoes through the night. Trouble is brewing.", 'yellow');
                        }
                    },
                    {
                        name: "strange_lights",
                        condition: () => hour >= 23 || hour <= 5,
                        message: "You catch a glimpse of strange, pulsing lights in the industrial district.",
                        consequence: () => {
                            this.state.journal.push("Mysterious lights spotted in industrial district. Investigation needed.");
                            this.outputText("Something glows ominously in the distance. It's not natural.", 'yellow');
                        }
                    },
                    {
                        name: "whispers",
                        condition: () => hour >= 1 && hour <= 4,
                        message: "You hear whispers on the wind. Words you can't quite make out, but they chill your blood.",
                        consequence: () => {
                            this.state.journal.push("Heard strange whispers in the night. The city holds secrets.");
                            this.outputText("The wind carries voices that shouldn't exist. You shiver involuntarily.", 'yellow');
                        }
                    }
                ];
                
                const activeEvent = events.find(event => event.condition());
                if (activeEvent) {
                    this.outputText(activeEvent.message, 'cyan');
                    activeEvent.consequence();
                }
            },

            takeDamage(amount) {
                this.state.health -= amount;
                this.outputText(`You take ${amount} point(s) of damage. You have ${this.state.health} health left.`, 'fail');
                if (this.state.health <= 0) {
                    this.endGame("The blows are too much. You slump to the ground as your vision fades to black...");
                }
            },

            endGame(message) {
                this.outputText("\n" + "=".repeat(60), 'fail');
                this.outputText(this.wrapText(message), 'fail');
                this.outputText("=".repeat(60) + "\n", 'fail');
                this.state.gameOver = true;
                input.disabled = true;
            },
            
            // --- PARSING & COMMANDS ---
            processCommand(commandStr) {
                if (this.state.gameOver) return;
                
                const echo = document.createElement('div');
                echo.style.color = 'var(--glow-color)';
                echo.textContent = `> ${commandStr}`;
                output.appendChild(echo);

                const words = commandStr.toLowerCase().split(' ').filter(w => w);
                const action = words[0];
                const args = words.slice(1);

                let minutesPassed = 0;
                
                // Check if we're in dialogue mode
                if (this.state.currentDialogue) {
                    // Only allow dialogue choices and quit/exit during dialogue
                    if (["1", "2", "3", "4", "5", "6", "7", "8", "9", "quit", "exit"].includes(action)) {
                        const commandMap = {
                            "1": () => this.handleDialogueChoice(1), "2": () => this.handleDialogueChoice(2), "3": () => this.handleDialogueChoice(3),
                            "4": () => this.handleDialogueChoice(4), "5": () => this.handleDialogueChoice(5), "6": () => this.handleDialogueChoice(6),
                            "7": () => this.handleDialogueChoice(7), "8": () => this.handleDialogueChoice(8), "9": () => this.handleDialogueChoice(9),
                            "quit": () => { this.state.gameOver = true; }, "exit": () => { this.state.gameOver = true; },
                        };
                        if (commandMap[action]) {
                            minutesPassed = commandMap[action].call(this, args) || 0;
                        } else {
                            this.outputText("Please choose a dialogue option (1-6) or type 'quit' to exit.");
                            minutesPassed = 0;
                        }
                    } else {
                        this.outputText("You're in the middle of a conversation. Choose a dialogue option (1-6) or type 'quit' to exit.");
                        minutesPassed = 0;
                    }
                } else {
                    // Normal command processing when not in dialogue
                    const commandMap = {
                        "go": this.handleGo, "n": () => this.handleGo(['n']), "s": () => this.handleGo(['s']),
                        "e": () => this.handleGo(['e']), "w": () => this.handleGo(['w']), "u": () => this.handleGo(['u']),
                        "d": () => this.handleGo(['d']), "take": this.handleTake, "get": this.handleTake,
                        "drop": this.handleDrop, "talk": this.handleTalk, "look": this.handleLook, "examine": this.handleLook,
                        "l": () => this.handleLook([]), "search": this.handleSearch, "use": this.handleUse, "give": this.handleGive,
                        "attack": this.handleAttack, "equip": this.handleEquip, "unequip": this.handleUnequip,
                        "read": this.handleRead, "smoke": this.handleSmoke, "drink": this.handleDrink, "think": this.handleThink,
                        "gamble": this.handleGamble, "contracts": this.handleContracts, "accept": this.handleAcceptContract,
                        "work": this.handleWorkContract, "buy": this.handleBuy, "bluff": this.handleBluff, "steal": this.handleSteal, "stolen": this.handleStolen,
                        "break": this.handleBreakInto, "pick": this.handlePickLock, "pry": this.handlePry, "smoke": this.handleSmoke, "drink": this.handleDrink,
                        "investigate": this.handleInvestigate, "confront": this.handleConfront,
                        "status": this.showStatus, "inventory": this.showInventory, "i": this.showInventory,
                        "journal": this.handleThink, "map": this.handleMap, "hint": this.handleHint, "help": this.showHelp,
                        "save": this.handleSave, "load": this.handleLoad, "saves": this.handleSaves, "delete_save": this.handleDeleteSave,
                        "quit": () => { this.state.gameOver = true; }, "exit": () => { this.state.gameOver = true; },
                        // New epic systems
                        "quests": this.handleQuests, "sidequests": this.handleQuests,
                        "skills": this.handleSkills, "reputation": this.handleReputation,
                        "lore": this.handleLore, "library": this.handleLore,
                        "hack": this.handleHack, "lockpick": this.handleLockpick,
                        "deduce": this.handleDeduce, "interrogate": this.handleInterrogate,
                        "surveil": this.handleSurveil, "stakeout": this.handleStakeout,
                        // Advanced systems
                        "memory": this.handleMemory, "puzzle": this.handlePuzzle,
                        "faction": this.handleFaction, "loyalty": this.handleLoyalty,
                        "craft": this.handleCraft, "enhance": this.handleEnhance,
                        "romance": this.handleRomance, "flirt": this.handleFlirt,
                        "achievement": this.handleAchievement, "trophy": this.handleTrophy,
                        "weather": this.handleWeather, "forecast": this.handleForecast,
                        "economy": this.handleEconomy, "trade": this.handleTrade,
                        "combat": this.handleCombat, "tactics": this.handleTactics,
                        "mystery": this.handleMystery, "clue": this.handleClue,
                        // Advanced AI & Procedural Systems
                        "ai": this.handleAI, "npc": this.handleNPC, "personality": this.handlePersonality,
                        "quest": this.handleQuest, "generate": this.handleGenerate,
                        "stock": this.handleStock, "market": this.handleMarket, "invest": this.handleInvest,
                        "social": this.handleSocial, "network": this.handleNetwork, "rumor": this.handleRumor,
                        "schedule": this.handleSchedule, "appointment": this.handleAppointment, "deadline": this.handleDeadline,
                        "skilltree": this.handleSkillTree, "unlock": this.handleUnlock,
                        "puzzlechain": this.handlePuzzleChain, "chain": this.handleChain,
                        "optimize": this.handleOptimize, "performance": this.handlePerformance,
                        // Advanced Combat & Storytelling
                        "combat": this.handleCombat, "fight": this.handleCombat, "battle": this.handleCombat,
                        "attack": this.handleAttack, "defend": this.handleDefend, "flee": this.handleFlee,
                        "special": this.handleSpecial, "tactics": this.handleTactics,
                        "story": this.handleStory, "storyline": this.handleStory, "plot": this.handleStory,
                    };
                    if (commandMap[action]) {
                        minutesPassed = commandMap[action].call(this, args) || 0;
                    } else {
                        this.outputText("I don't understand that, pal. Keep it simple. (Type 'help' for commands)");
                        minutesPassed = 1;
                    }
                }

                if (minutesPassed > 0) {
                    this.advanceTime(minutesPassed);
                    const { day, hour, minute } = this.state.time;
                    const timeStr = `Day ${day}, ${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                    this.outputText(`(${timeStr})`, 'grey');
                }
                
                if (this.state.won) {
                    this.endGame("YOU WIN! You walk out of the warehouse as sirens fill the night air. You uncovered the truth. Good work, gumshoe.");
                } else if (this.state.gameOver) {
                    this.endGame("GAME OVER. The city always wins. The rain washes the streets clean, but it'll never wash away the darkness.");
                }
            },
            
            findTarget(targetWords, itemList) {
                const targetStr = targetWords.join(" ");
                if (!targetStr) return null;
                
                // First try exact match
                if (itemList.includes(targetStr)) return targetStr;
                
                // Try case-insensitive exact match
                const exactMatch = itemList.find(item => 
                    item.toLowerCase() === targetStr.toLowerCase()
                );
                if (exactMatch) return exactMatch;
                
                // Try partial word matching (case-insensitive)
                const found = itemList.filter(item => {
                    const normalizedItem = item.toLowerCase().replace(/_/g, ' ');
                    const normalizedTarget = targetStr.toLowerCase();
                    
                    // Check if all words in target are found in item
                    return targetWords.every(word => 
                        normalizedItem.includes(word.toLowerCase())
                    ) || normalizedItem.includes(normalizedTarget);
                });
                
                if (found.length === 1) return found[0];
                if (found.length > 1) {
                    this.outputText(`Which one did you mean: ${found.join(', ')}?`);
                    return null;
                }
                return null;
            },
            
            getCurrentRoom() {
                const posKey = `${this.state.playerPos.x},${this.state.playerPos.y},${this.state.playerPos.z}`;
                return this.data.worldMap[posKey];
            },

            // --- ALL COMMAND HANDLERS PORTED ---
            
            handleGo(args) {
                if (!args.length) { this.outputText("Go where?"); return 0; }
                const direction = args[0][0];
                const room = this.getCurrentRoom();
                const { x, y, z } = this.state.playerPos;

                // Handle overrides
                if (room.exitsOverride && room.exitsOverride[direction]) {
                    const [nx, ny, nz] = room.exitsOverride[direction];
                    const nextPosKey = `${nx},${ny},${nz}`;
                    if (this.data.worldMap[nextPosKey]) {
                         if (this.data.worldMap[nextPosKey].locked) { this.outputText("The door is locked."); return 2; }
                         
                         // Check for random encounters during movement
                         this.checkRandomEncounter();
                         
                         this.state.playerPos = { x: nx, y: ny, z: nz };
                         this.state.discoveredCoords.add(nextPosKey);
                         this.outputText(`You go ${direction.toUpperCase()}...`);
                         this.handleLook([]);
                         return 5;
                    }
                }
                
                // Standard movement
                const moves = { n: { y: y + 1 }, s: { y: y - 1 }, e: { x: x + 1 }, w: { x: x - 1 }, u: { z: z + 1 }, d: { z: z - 1 } };
                if (!moves[direction]) { this.outputText(`'${direction}' is not a valid direction.`); return 1; }
                
                const nextPos = { ...this.state.playerPos, ...moves[direction] };
                const nextPosKey = `${nextPos.x},${nextPos.y},${nextPos.z}`;

                if (this.data.worldMap[nextPosKey]) {
                    if (this.data.worldMap[nextPosKey].locked) { this.outputText("The door is locked."); return 2; }
                    this.state.playerPos = nextPos;
                    this.state.discoveredCoords.add(nextPosKey);
                    this.outputText(`You go ${direction.toUpperCase()}...`);
                    this.handleLook([]);

                    // Trigger background events based on new location
                    const newRoom = this.data.worldMap[nextPosKey];
                    if (newRoom.name.includes("44th Precinct") || newRoom.name.includes("Police")) {
                        this.triggerBackgroundEvent("visit_precinct");
                    }
                    if (newRoom.name.includes("Casino") || newRoom.name.includes("Lucky Strike")) {
                        this.triggerBackgroundEvent("visit_casino");
                    }

                    return 5;
                } else {
                    this.outputText("You can't go that way, pal.");
                    return 1;
                }
            },

            handleLook(args = []) {
                const room = this.getCurrentRoom();
                if (!room) { this.outputText("You are lost in the void. This shouldn't happen.", 'fail'); return 1; }

                if (args.length > 0) { // Look at something specific
                    const searchSpace = [...(room.items || []), ...Object.keys(room.npcs || {}), ...(room.features || []), ...this.state.inventory];
                    const targetName = this.findTarget(args, searchSpace);
                    if (targetName) {
                        // Safe property access to prevent undefined errors
                        let desc = null;

                        // Check if it's an item
                        if (this.data.items && this.data.items[targetName] && this.data.items[targetName].desc) {
                            desc = this.data.items[targetName].desc;
                        }
                        // Check if it's a feature
                        else if (this.data.features && this.data.features[targetName] && this.data.features[targetName].desc) {
                            desc = this.data.features[targetName].desc;
                        }
                        // Check if it's an NPC
                        else if (room.npcs && room.npcs[targetName]) {
                            desc = room.npcs[targetName];
                        }
                        // Check if it's a dynamic NPC description
                        else if (this.data.getNpcDesc && this.data.getNpcDesc(targetName)) {
                            desc = this.data.getNpcDesc(targetName);
                        }
                        // Default fallback
                        else {
                            desc = `A <span class="npc-name">${targetName.toLowerCase()}</span> is here.`;
                        }

                        if (desc) {
                            this.outputText(this.wrapText(desc));
                            return 2;
                        } else {
                            this.outputText(`You see ${targetName} but can't examine it closely.`);
                            return 1;
                        }
                    } else { this.outputText(`You don't see '${args.join(' ')}' here.`); return 1; }
                }

                this.outputText(`--- ${room.name} ---`, 'header');
                this.outputText(this.wrapText(room.baseDesc));
                if (room.npcs && Object.keys(room.npcs).length > 0) { Object.values(room.npcs).forEach(desc => this.outputText(this.wrapText(desc), 'cyan')); }
                if (room.items && room.items.length > 0) { this.outputText("On the ground you see: " + room.items.join(', ')); }
                if (room.features && room.features.length > 0) { this.outputText("You notice: " + room.features.join(', ')); }

                const exits = [];
                const { x, y, z } = this.state.playerPos;
                const moves = { N: { y: y + 1 }, S: { y: y - 1 }, E: { x: x + 1 }, W: { x: x - 1 }, U: { z: z + 1 }, D: { z: z - 1 } };
                for (const [dir, move] of Object.entries(moves)) {
                    const checkPos = { ...this.state.playerPos, ...move };
                    if (this.data.worldMap[`${checkPos.x},${checkPos.y},${checkPos.z}`]) exits.push(dir);
                }
                if (exits.length > 0) this.outputText("Exits: " + exits.join(" "));
                return 1;
            },

            handleTake(args) {
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, room.items || []);
                if (!targetName) { this.outputText(`You don't see that here.`); return 1; }
                if (this.data.items[targetName]?.takeable) {
                    this.state.inventory.push(targetName);
                    room.items = room.items.filter(item => item !== targetName);
                    this.outputText(`You take the ${targetName}.`);
                    if (targetName.includes("cash_stack")) {
                        const amount = this.data.items[targetName].value || 200;
                        this.spendMoney(-amount, "found cash");
                        this.outputText(`You pocket an extra $${amount}.`);
                        this.state.inventory = this.state.inventory.filter(i => i !== targetName);
                    }
                    return 2;
                } else { this.outputText(`You can't take the ${targetName}.`); return 1; }
            },
            
            handleDrop(args) {
                 const targetName = this.findTarget(args, this.state.inventory);
                 if (!targetName) { this.outputText("You aren't carrying that."); return 1; }
                 const room = this.getCurrentRoom();
                 this.state.inventory = this.state.inventory.filter(item => item !== targetName);
                 if (!room.items) room.items = [];
                 room.items.push(targetName);
                 this.outputText(`You drop the ${targetName}.`);
                 return 2;
            },
            
            handleTalk(args) {
                 if (!args.length) { this.outputText("Talk to who?"); return 0; }
                 const room = this.getCurrentRoom();
                 
                 // Debug: Show available NPCs
                 const availableNPCs = Object.keys(room.npcs || {});
                 this.outputText(`Available NPCs: ${availableNPCs.join(', ')}`, 'debug');
                 
                 const npcName = this.findTarget(args, Object.keys(room.npcs || {}));
                 if (!npcName) { 
                     this.outputText(`They aren't here. Available: ${availableNPCs.join(', ')}`); 
                     return 2; 
                 }

                // Trigger background events based on who you're talking to
                if (npcName === "bartender") {
                    this.triggerBackgroundEvent("talk_bartender");
                } else if (npcName === "guard") {
                    this.triggerBackgroundEvent("talk_police");
                } else if (npcName === "johnny" || npcName === "informant") {
                    this.triggerBackgroundEvent("talk_informant");
                } else if (npcName === "bum" && this.state.gameState.playerBackground?.name === "Ex-Military") {
                    this.triggerBackgroundEvent("talk_veteran");
                 }

                 // Enhanced character interactions
                 if (npcName === "evelyn") {
                     this.handleEvelynTalk();
                     return 15;
                 } else if (npcName === "sterling") {
                     this.handleSterlingTalk();
                     return 15;
                 } else if (npcName === "isabella") {
                     this.handleIsabellaTalk();
                     return 15;
                 } else if (npcName === "david") {
                     this.handleDavidTalk();
                     return 15;
                 } else if (npcName === "bartender") {
                     this.handleBartenderTalk();
                     return 10;
                } else if (npcName === "landlord") {
                    this.handleLandlordTalk();
                    return 5;
                } else if (npcName === "desk_sergeant") {
                    this.handleDeskSergeantTalk();
                    return 10;
                } else if (npcName === "detective_morrison") {
                    this.handleDetectiveMorrisonTalk();
                    return 15;
                } else if (npcName === "dock_worker") {
                    this.handleDockWorkerTalk();
                    return 8;
                } else if (npcName === "fisherman") {
                    this.handleFishermanTalk();
                     return 10;
                 } else {
                     this.handleGenericNPCTalk(npcName);
                     return 10;
                 }
            },

            handleRead(args) {
                if (!args.length) { 
                    this.outputText("Read what?"); 
                    return 0; 
                }
                
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, this.state.inventory.concat(room.items || []));
                
                if (!targetName) { 
                    this.outputText(`You don't see '${args.join(' ')}' to read.`); 
                    return 2; 
                }

                if (targetName === "case_file") {
                    this.outputText("--- CASE FILE: THE BLACKWOOD DIAMOND AFFAIR ---", 'header');
                    this.outputText("Client: Mrs. Evelyn Blackwood", 'cyan');
                    this.outputText("Date: March 15, 1947", 'cyan');
                    this.outputText("", 'normal');
                    this.outputText("SUMMARY:", 'header');
                    this.outputText("Marcus Blackwood, wealthy industrialist, found dead in his office.", 'normal');
                    this.outputText("Police ruled it suicide, but widow claims murder.", 'normal');
                    this.outputText("Missing: Rare diamond worth $50,000.", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("SUSPECTS:", 'header');
                    this.outputText("1. Richard Sterling - Business partner, stands to inherit company", 'normal');
                    this.outputText("2. Isabella Rose - Mistress, seen arguing with victim", 'normal');
                    this.outputText("3. David Blackwood - Estranged son, financial troubles", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("EVIDENCE:", 'header');
                    this.outputText("- Suicide note found (handwriting questionable)", 'normal');
                    this.outputText("- Diamond case empty, no signs of forced entry", 'normal');
                    this.outputText("- Witness saw 'glowing orb' in office window", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("OBJECTIVE: Determine if suicide or murder, locate missing diamond.", 'green');

                    // Add evidence to case
                    const caseState = this.state.gameState.blackwoodCase;
                    if (!caseState.evidenceCollected.includes("Case file reviewed")) {
                        caseState.evidenceCollected.push("Case file reviewed");
                        this.outputText("Evidence collected: Case file details", 'success');
                    }
                    return 5;
                } else if (targetName === "newspaper") {
                    this.outputText("--- THE DAILY HERALD - March 16, 1947 ---", 'header');
                    this.outputText("BLACKWOOD SUICIDE SHOCKS CITY", 'cyan');
                    this.outputText("", 'normal');
                    this.outputText("Industrialist Marcus Blackwood, 52, was found dead in his office yesterday.", 'normal');
                    this.outputText("Police report suicide, but sources say investigation continues.", 'normal');
                    this.outputText("Blackwood Industries stock drops 15% on news.", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("Mrs. Evelyn Blackwood declined comment.", 'normal');

                    // Add evidence to case
                    const caseState = this.state.gameState.blackwoodCase;
                    if (!caseState.evidenceCollected.includes("Newspaper article reviewed")) {
                        caseState.evidenceCollected.push("Newspaper article reviewed");
                        this.outputText("Evidence collected: Newspaper details", 'success');
                    }

                    // Trigger background event for reading newspaper
                    this.triggerBackgroundEvent("read_newspaper");

                    return 3;
                } else if (targetName === "ledger") {
                    this.outputText("--- BLACKWOOD INDUSTRIES LEDGER ---", 'header');
                    this.outputText("Recent transactions show unusual activity:", 'normal');
                    this.outputText("- Large withdrawal: $25,000 (March 10)", 'normal');
                    this.outputText("- Payment to 'I.R.' - $5,000 (March 12)", 'normal');
                    this.outputText("- Payment to 'D.B.' - $10,000 (March 13)", 'normal');
                    this.outputText("- Diamond insurance claim filed (March 14)", 'normal');
                    this.outputText("", 'normal');
                    this.outputText("Something doesn't add up...", 'warning');

                    // Add evidence to case
                    const caseState = this.state.gameState.blackwoodCase;
                    if (!caseState.evidenceCollected.includes("Financial records examined")) {
                        caseState.evidenceCollected.push("Financial records examined");
                        this.outputText("Evidence collected: Suspicious financial transactions", 'success');
                    }
                    return 5;
                } else {
                    this.outputText(`You can't read the ${targetName}.`);
                    return 2;
                }
            },

            handleMap() {
                this.outputText("--- CITY MAP ---", 'header');
                this.outputText("(Only showing locations you've discovered)", 'grey');
                
                // Only show visited locations
                const visitedRooms = [];
                for (const coord of this.state.discoveredCoords) {
                    const room = this.data.worldMap[coord];
                    if (room && room.name) {
                        const [x, y, z] = coord.split(',').map(Number);
                        const depth = z < 0 ? ` (Underground Level ${Math.abs(z)})` : z > 0 ? ` (Above Ground Level ${z})` : '';
                        visitedRooms.push(`${room.name}${depth} - ${coord}`);
                    }
                }
                
                if (visitedRooms.length === 0) {
                    this.outputText("You haven't discovered any locations yet. Start exploring!");
                } else {
                    visitedRooms.forEach(room => this.outputText(room));
                }
                
                // Show current location
                const currentCoord = `${this.state.playerPos.x},${this.state.playerPos.y},${this.state.playerPos.z}`;
                const currentRoom = this.data.worldMap[currentCoord];
                if (currentRoom) {
                    this.outputText(`\nYou are currently at: ${currentRoom.name}`, 'cyan');
                }
                
                return 1;
            },

            handleHint() {
                const caseState = this.state.gameState.blackwoodCase;
                this.outputText("--- INVESTIGATION HINTS ---", 'header');
                
                if (!caseState.interviewedWidow) {
                    this.outputText("• Visit Blackwood Estate to interview the widow", 'cyan');
                }
                if (!caseState.interviewedPartner) {
                    this.outputText("• Check Blackwood Industries for the business partner", 'cyan');
                }
                if (!caseState.interviewedMistress) {
                    this.outputText("• The Velvet Lounge might have answers", 'cyan');
                }
                if (!caseState.interviewedSon) {
                    this.outputText("• The Flophouse - estranged son lives there", 'cyan');
                }
                if (!caseState.foundDiamond) {
                    this.outputText("• Look for the 'glowing orb' - it's not what it seems", 'cyan');
                }
                if (caseState.evidenceCollected.length < 3) {
                    this.outputText("• Search rooms thoroughly for evidence", 'cyan');
                }
                if (caseState.evidenceCollected.length >= 3 && !caseState.discoveredTruth) {
                    this.outputText("• Use 'investigate' to piece together the evidence", 'cyan');
                }
                
                this.outputText("", 'normal');
                this.outputText("Remember: Talk to people, search rooms, follow leads!", 'green');
                return 0;
            },

            handleBartenderTalk() {
                const background = this.state.gameState.playerBackground;
                const room = this.getCurrentRoom();
                
                // Check for special background dialogue first
                const specialDialogue = this.getBackgroundDialogue("bartender");
                if (specialDialogue) {
                    this.outputText(this.wrapText(specialDialogue));
                } else {
                this.outputText(this.wrapText(room.npcs.bartender));
                }
                
                // Subtle background-based reactions (only if no special dialogue was used)
                if (!specialDialogue) {
                if (background.name === "Ex-Cop") {
                    this.outputText("The bartender's eyes narrow slightly. 'You got that cop look about you.'", 'cyan');
                } else if (background.name === "Ex-Mob") {
                    this.outputText("The bartender nods knowingly. 'You know how things work around here.'", 'cyan');
                } else if (background.name === "Ex-Military") {
                    this.outputText("The bartender straightens up. 'You got that military bearing, don't you?'", 'cyan');
                } else if (background.name === "Ex-Lawyer") {
                    this.outputText("The bartender studies you. 'You talk like a lawyer, mister.'", 'cyan');
                } else if (background.name === "Ex-Reporter") {
                    this.outputText("The bartender leans in. 'You ask questions like a newsman.'", 'cyan');
                } else if (background.name === "Ex-Con") {
                    this.outputText("The bartender's hand moves closer to something under the bar.", 'warning');
                } else {
                    this.outputText("The bartender treats you with polite neutrality.", 'normal');
                    }
                }
                
                    this.outputText(this.wrapText("He gestures to a corkboard. 'Got some odd jobs if you need the cash. Type 'contracts'.'", 2), 'grey');
            },

            handleLandlordTalk() {
                this.outputText("Mrs. Kowalski crosses her arms and glares at you.", 'cyan');
                this.outputText("'Rent's two weeks overdue, mister! $800, and don't give me that 'I'm working on a big case' routine.'", 'normal');

                const caseState = this.state.gameState.blackwoodCase;
                if (caseState.interviewedWidow || caseState.interviewedPartner) {
                    this.outputText("She softens slightly. 'Fine, I read about that Blackwood business. Tragic. But bills don't pay themselves.'", 'normal');
                    this.state.gameState.npcRelationships["landlord"] = (this.state.gameState.npcRelationships["landlord"] || 0) + 1;
                } else {
                    this.outputText("'I got my own problems. The building's falling apart and the city's full of deadbeats.'", 'normal');
                }
            },

            handleDeskSergeantTalk() {
                this.outputText("The desk sergeant peers at you over his paperwork.", 'cyan');
                this.outputText("'What do you want? We got real police work to do here.'", 'normal');

                const caseState = this.state.gameState.blackwoodCase;
                if (caseState.interviewedSon || caseState.foundDiamond) {
                    this.outputText("He sighs. 'Look, off the record? Blackwood's death stunk to high heaven. But the captain says case closed.'", 'cyan');
                    this.state.gameState.npcRelationships["desk_sergeant"] = (this.state.gameState.npcRelationships["desk_sergeant"] || 0) + 2;
                    this.state.journal.push("Desk sergeant hinted that Blackwood case was closed too quickly.");
                } else {
                    this.outputText("'Another civilian playing detective. Go bother someone else.'", 'normal');
                }
            },

            handleDetectiveMorrisonTalk() {
                this.outputText("Detective Morrison swivels in his chair to face you.", 'cyan');
                this.outputText("'Private investigator, huh? You know we don't like amateurs stepping on our toes.'", 'normal');

                const caseState = this.state.gameState.blackwoodCase;
                if (caseState.evidenceCollected.length >= 2) {
                    const { result } = this.attributeCheck("charisma", 15);
                    if (result.includes("success")) {
                        this.outputText("He leans forward. 'Alright, between you and me... Blackwood was into some shady stuff. Diamond smuggling, maybe.'", 'green');
                        this.state.gameState.npcRelationships["detective_morrison"] = (this.state.gameState.npcRelationships["detective_morrison"] || 0) + 3;
                        this.state.journal.push("Detective Morrison: Blackwood involved in diamond smuggling.");
                        this.state.gameState.blackwoodCase.evidenceCollected.push("Detective hints at diamond smuggling");
                    } else {
                        this.outputText("'Get out of my face before I arrest you for obstruction.'", 'fail');
                        this.state.gameState.npcRelationships["detective_morrison"] = (this.state.gameState.npcRelationships["detective_morrison"] || 0) - 1;
                    }
                } else {
                    this.outputText("'Unless you've got something concrete, I suggest you stick to lost puppies.'", 'normal');
                }
            },

            handleDockWorkerTalk() {
                this.outputText("The dock worker sets down his crate and wipes his hands on his pants.", 'cyan');
                this.outputText("'What do you want? This ain't no tourist spot.'", 'normal');

                const caseState = this.state.gameState.blackwoodCase;
                if (this.state.gameState.sideQuests?.missingGirl?.completed) {
                    this.outputText("'Heard you found that missing girl. Good work. She was like family around here.'", 'green');
                    this.state.gameState.npcRelationships["dock_worker"] = (this.state.gameState.npcRelationships["dock_worker"] || 0) + 2;
                } else {
                    this.outputText("'Strange shipments come through here at night. Big crates, no markings. Stay out of trouble.'", 'cyan');
                }
            },

            handleFishermanTalk() {
                this.outputText("The old fisherman looks up from his nets with eyes like weathered granite.", 'cyan');
                this.outputText("'The sea don't care about your troubles, mister. It just takes what it wants.'", 'normal');

                // Fisherman has unique knowledge about docks
                const caseState = this.state.gameState.blackwoodCase;
                if (!caseState.interviewedSon && Math.random() > 0.6) {
                    this.outputText("He pauses, then lowers his voice. 'Heard Blackwood arguing with his boy down here once. 'Bout money, inheritance. Ugly scene.'", 'cyan');
                    this.state.journal.push("Fisherman: Saw Blackwood arguing with his son about inheritance.");
                    this.state.gameState.npcRelationships["fisherman"] = (this.state.gameState.npcRelationships["fisherman"] || 0) + 1;
                } else {
                    this.outputText("'Go fish somewhere else. I've got work to do.'", 'normal');
                }
            },

            handleGenericNPCTalk(npcName) {
                const room = this.getCurrentRoom();
                const npc = room.npcs[npcName];
                
                if (!npc) {
                    this.outputText(`You don't see ${npcName} here.`, 'fail');
                    return;
                }
                
                // Check for special background dialogue first
                const specialDialogue = this.getBackgroundDialogue(npcName);
                if (specialDialogue) {
                    this.outputText(this.wrapText(specialDialogue));
                } else {
                // Display the NPC's description
                this.outputText(this.wrapText(npc));
                }
                
                // Enhanced dialogue system with consequences
                this.startEnhancedDialogue(npcName);
            },
            
            startEnhancedDialogue(npcName) {
                // Initialize conversation history if it doesn't exist
                if (!this.state.gameState.conversationHistory) {
                    this.state.gameState.conversationHistory = {};
                }
                if (!this.state.gameState.conversationHistory[npcName]) {
                    this.state.gameState.conversationHistory[npcName] = {
                        topicsDiscussed: [],
                        relationship: this.state.gameState.npcRelationships[npcName] || { trust: 0, fear: 0, gratitude: 0 },
                        lastSpoken: null,
                        flags: {}
                    };
                }

                // Update last spoken time
                this.state.gameState.conversationHistory[npcName].lastSpoken = `${this.state.time.day}:${String(this.state.time.hour).padStart(2, '0')}`;

                // Store current dialogue state
                this.state.currentDialogue = {
                    npc: npcName,
                    stage: 'greeting',
                    history: this.state.gameState.conversationHistory[npcName]
                };
                
                // Get dynamic dialogue based on NPC, game state, and conversation history
                const dialogue = this.getDynamicNPCDialogue(npcName);
                
                this.outputText(`\n--- Talking to ${npcName} ---`, 'header');
                this.outputText(`"${dialogue.greeting}"`, 'cyan');
                
                // Show dialogue options with consequences
                this.showDynamicOptions(npcName, dialogue);
            },
            
            getDynamicNPCDialogue(npcName) {
                const history = this.state.gameState.conversationHistory[npcName];
                const relationship = history.relationship;
                const caseState = this.state.gameState.blackwoodCase;
                const background = this.state.gameState.playerBackground;

                // Base dialogue templates
                const dialogues = {
                    "bum": {
                        greeting: "The bum eyes you warily. 'Spare a dime for a vet, mister? I seen things... things that ain't right down at the docks.'",
                        options: [
                            {
                                text: "Give him money",
                                action: "give_money",
                                consequence: "grateful_info",
                                available: () => this.state.cash >= 5,
                                once: false
                            },
                            {
                                text: "Ask about the docks",
                                action: "ask_docks",
                                consequence: "dock_info",
                                available: () => !history.topicsDiscussed.includes("docks"),
                                once: true
                            },
                            {
                                text: "Ask about Blackwood",
                                action: "ask_blackwood",
                                consequence: "blackwood_info",
                                available: () => caseState.interviewedWidow && !history.topicsDiscussed.includes("blackwood"),
                                once: true
                            },
                            {
                                text: "Walk away",
                                action: "leave",
                                consequence: "no_consequence",
                                available: () => true,
                                once: false
                            }
                        ]
                    },
                    "bartender": {
                        greeting: relationship.trust > 2 ? "'Back again, friend? What'll it be?'" :
                                 relationship.trust < -1 ? "'What do you want now?'" :
                                 "'What's your poison?'",
                        options: [
                            {
                                text: "Ask about the Blackwood case",
                                action: "ask_case",
                                consequence: "case_gossip",
                                available: () => caseState.interviewedWidow,
                                once: false
                            },
                            {
                                text: "Order a drink",
                                action: "order_drink",
                                consequence: "drink_ordered",
                                available: () => this.state.cash >= 3,
                                once: false
                            },
                            {
                                text: "Ask about local rumors",
                                action: "ask_rumors",
                                consequence: "local_gossip",
                                available: () => relationship.trust >= 0,
                                once: false
                            },
                            {
                                text: "Leave",
                                action: "leave",
                                consequence: "no_consequence",
                                available: () => true,
                                once: false
                            }
                        ]
                    },
                    "izzy": {
                        greeting: relationship.gratitude > 1 ? "'Good to see you again, detective. Need anything?'" :
                                 relationship.trust < 0 ? "'You again? Make it quick.'" :
                                 "'Buying or selling?'",
                        options: [
                            {
                                text: "Ask about stolen goods",
                                action: "ask_stolen",
                                consequence: "stolen_goods_info",
                                available: () => this.state.gameState.stolenItems && this.state.gameState.stolenItems.length > 0,
                                once: true
                            },
                            {
                                text: "Browse merchandise",
                                action: "browse",
                                consequence: "show_merchandise",
                                available: () => true,
                                once: false
                            },
                            {
                                text: "Inquire about Blackwood",
                                action: "ask_blackwood",
                                consequence: "blackwood_business",
                                available: () => caseState.interviewedPartner && relationship.trust >= 0,
                                once: true
                            },
                            {
                                text: "Leave",
                                action: "leave",
                                consequence: "no_consequence",
                                available: () => true,
                                once: false
                            }
                        ]
                    },
                    "detective_morrison": {
                        greeting: relationship.trust > 3 ? "'Detective. What brings you to my neck of the woods?'" :
                                 relationship.trust < 0 ? "'You again. This better be important.'" :
                                 "'Private dick, huh? You know we don't like your type poking around our cases.'",
                        options: [
                            {
                                text: "Share investigation findings",
                                action: "share_findings",
                                consequence: "shared_intel",
                                available: () => caseState.evidenceCollected.length >= 2,
                                once: false
                            },
                            {
                                text: "Ask for police files",
                                action: "ask_files",
                                consequence: "file_access",
                                available: () => relationship.trust >= 2,
                                once: false
                            },
                            {
                                text: "Press about corruption",
                                action: "press_corruption",
                                consequence: "corruption_admission",
                                available: () => caseState.evidenceCollected.length >= 3 && relationship.trust >= 1,
                                once: true
                            },
                            {
                                text: "Back off",
                                action: "leave",
                                consequence: "no_consequence",
                                available: () => true,
                                once: false
                            }
                        ]
                    },
                    "fisherman": {
                        greeting: relationship.trust > 1 ? "'Ah, the detective returns. The sea has been restless lately.'" :
                                 "'The sea don't care about your troubles. It just takes what it wants.'",
                        options: [
                            {
                                text: "Ask about recent shipments",
                                action: "ask_shipments",
                                consequence: "shipment_info",
                                available: () => relationship.trust >= 0,
                                once: false
                            },
                            {
                                text: "Ask about Blackwood family",
                                action: "ask_family",
                                consequence: "family_conflict",
                                available: () => caseState.interviewedSon && !history.topicsDiscussed.includes("family"),
                                once: true
                            },
                            {
                                text: "Share a sea story",
                                action: "share_story",
                                consequence: "bonding_moment",
                                available: () => background.name === "Ex-Military" && !history.topicsDiscussed.includes("war_stories"),
                                once: true
                            },
                            {
                                text: "Depart",
                                action: "leave",
                                consequence: "no_consequence",
                                available: () => true,
                                once: false
                            }
                        ]
                    }
                };

                return dialogues[npcName] || {
                    greeting: `${npcName} looks at you expectantly.`,
                    options: [
                        {
                            text: "Ask about the case",
                            action: "ask_case",
                            consequence: "generic_info",
                            available: () => true,
                            once: false
                        },
                        {
                            text: "End conversation",
                            action: "leave",
                            consequence: "no_consequence",
                            available: () => true,
                            once: false
                        }
                    ]
                };
            },

            showDynamicOptions(npcName, dialogue) {
                this.outputText("\nWhat do you do?", 'yellow');

                const availableOptions = dialogue.options.filter(option =>
                    option.available() &&
                    (!option.once || !this.state.currentDialogue.history.topicsDiscussed.includes(option.action))
                );

                if (availableOptions.length === 0) {
                    this.outputText("1. End conversation", 'cyan');
                    this.state.currentDialogue.options = [{ text: "End conversation", action: "leave", consequence: "no_consequence" }];
                    return;
                }

                availableOptions.forEach((option, index) => {
                    this.outputText(`${index + 1}. ${option.text}`, 'cyan');
                });

                // Store available options for choice handling
                this.state.currentDialogue.stage = 'options';
                this.state.currentDialogue.options = availableOptions;
            },
            
            getEnhancedNPCDialogue(npcName) {
                const dialogues = {
                    "bum": {
                        greeting: "The bum eyes you warily. 'Spare a dime for a vet, mister? I seen things... things that ain't right down at the docks.'",
                        options: [
                            { text: "Give him money", action: "give_money", consequence: "grateful_info" },
                            { text: "Ask about the docks", action: "ask_docks", consequence: "dock_info" },
                            { text: "Ignore him", action: "ignore", consequence: "missed_opportunity" }
                        ]
                    },
                    "street_vendor": {
                        greeting: "A street vendor pushes a cart of hot dogs. 'Get your dogs here! Fresh off the grill!'",
                        options: [
                            { text: "Buy food", action: "buy_food", consequence: "vendor_gossip" },
                            { text: "Ask about recent events", action: "ask_events", consequence: "city_news" },
                            { text: "Walk away", action: "leave", consequence: "no_consequence" }
                        ]
                    },
                    "newspaper_boy": {
                        greeting: "A young newspaper boy shouts headlines. 'Extra! Extra! Read all about it! Blackwood suicide rocks city!'",
                        options: [
                            { text: "Buy a paper", action: "buy_paper", consequence: "newspaper_info" },
                            { text: "Ask about the headlines", action: "ask_headlines", consequence: "boy_gossip" },
                            { text: "Ignore him", action: "ignore", consequence: "no_consequence" }
                        ]
                    },
                    "beat_cop": {
                        greeting: "A beat cop walks his patrol, nightstick tapping rhythmically against his leg.",
                        options: [
                            { text: "Ask about recent crimes", action: "ask_crimes", consequence: "police_info" },
                            { text: "Report suspicious activity", action: "report_suspicious", consequence: "police_attention" },
                            { text: "Avoid eye contact", action: "avoid", consequence: "no_consequence" }
                        ]
                    },
                    "drunk": {
                        greeting: "A drunk stumbles past, muttering about 'the glow' and 'things that shouldn't be'.",
                        options: [
                            { text: "Help him", action: "help_drunk", consequence: "drunk_gratitude" },
                            { text: "Ask about the glow", action: "ask_glow", consequence: "drunk_rambling" },
                            { text: "Ignore him", action: "ignore", consequence: "no_consequence" }
                        ]
                    },
                    "mysterious_stranger": {
                        greeting: "A figure in a dark coat watches from the shadows. They seem to be waiting for something.",
                        options: [
                            { text: "Approach cautiously", action: "approach", consequence: "stranger_encounter" },
                            { text: "Observe from distance", action: "observe", consequence: "stranger_behavior" },
                            { text: "Avoid them", action: "avoid", consequence: "missed_encounter" }
                        ]
                    }
                };
                
                return dialogues[npcName] || {
                    greeting: `${npcName} looks at you expectantly.`,
                    options: [
                        { text: "Ask about the case", action: "ask_case", consequence: "generic_info" },
                        { text: "Ask about local news", action: "ask_news", consequence: "local_gossip" },
                        { text: "End conversation", action: "end", consequence: "no_consequence" }
                    ]
                };
            },
            
            showConsequentialOptions(npcName, dialogue) {
                this.outputText("\nWhat do you do?", 'yellow');
                dialogue.options.forEach((option, index) => {
                    this.outputText(`${index + 1}. ${option.text}`, 'cyan');
                });
                
                // Store dialogue state for choice handling
                this.state.currentDialogue.stage = 'options';
                this.state.currentDialogue.options = dialogue.options;
            },
            
            handleDialogueChoice(choice) {
                if (!this.state.currentDialogue || !this.state.currentDialogue.options) return;
                
                const selectedOption = this.state.currentDialogue.options[choice - 1];
                if (!selectedOption) {
                    this.outputText("Invalid choice.", 'fail');
                    return;
                }

                // Track discussed topics
                if (selectedOption.once) {
                    this.state.currentDialogue.history.topicsDiscussed.push(selectedOption.action);
                }
                
                // Execute the consequence
                this.executeDynamicConsequence(selectedOption);
                
                // Clear dialogue state
                this.state.currentDialogue = null;
            },
            
            executeDynamicConsequence(option) {
                const consequences = {
                    // Original consequences for backward compatibility
                    "grateful_info": () => {
                        this.outputText("The bum's eyes light up. 'Bless you, mister! You know, I seen Blackwood down at the docks last week. He was arguing with some corporate types about some kind of experiment.'", 'cyan');
                        this.state.journal.push("Bum: Blackwood was arguing with corporate types at docks about an experiment.");
                        this.spendMoney(5, "charity to bum");
                    },
                    "dock_info": () => {
                        this.outputText("'The docks? That's where the real action is, mister. Ships coming in at all hours, strange cargo, people acting weird. Blackwood was down there the night he died.'", 'cyan');
                        this.state.journal.push("Bum: Blackwood was at docks the night he died. Strange activity there.");
                    },
                    "missed_opportunity": () => {
                        this.outputText("You walk past the bum. He mutters something about 'ungrateful city folk' under his breath.", 'grey');
                    },
                    "vendor_gossip": () => {
                        this.outputText("'Best dogs in the city! You know, I see everything from this cart. That Blackwood fellow used to come by sometimes. Always seemed troubled, like he was carrying the weight of the world.'", 'cyan');
                        this.state.journal.push("Vendor: Blackwood seemed troubled, carrying weight of the world.");
                        this.spendMoney(3, "hot dog and gossip");
                    },
                    "city_news": () => {
                        this.outputText("'Oh, you mean the Blackwood thing? Whole city's talking about it. Some say it wasn't suicide, you know. Some say he knew too much about something.'", 'cyan');
                        this.state.journal.push("Vendor: Rumors that Blackwood knew too much about something.");
                    },
                    "no_consequence": () => {
                        this.outputText("You end the conversation.", 'grey');
                    },

                    // New dynamic consequences
                    "blackwood_info": () => {
                        this.outputText("'Blackwood? Yeah, I seen him around. Always looked like a man with secrets. He was meeting with some rough types down by the docks - the kind who don't like questions.'", 'cyan');
                        this.state.journal.push("Bum: Blackwood meeting rough types at docks, had secrets.");
                        this.state.gameState.npcRelationships["bum"].gratitude += 1;
                    },
                    "case_gossip": () => {
                        const caseState = this.state.gameState.blackwoodCase;
                        if (caseState.interviewedWidow) {
                            this.outputText("'Blackwood case? Wife came in here crying her eyes out. Said it wasn't suicide. I heard he was mixed up with some bad people - the corporate type.'", 'cyan');
                            this.state.journal.push("Bartender: Blackwood wife claims suicide. Mixed up with corporate types.");
                        } else {
                            this.outputText("'Blackwood? Yeah, I knew him. Came in here sometimes. Seemed like a decent guy. Shame what happened.'", 'cyan');
                        }
                    },
                    "drink_ordered": () => {
                        this.outputText("The bartender pours you a whiskey. 'That'll be $3.'", 'cyan');
                        this.spendMoney(3, "whiskey");
                        this.state.gameState.npcRelationships["bartender"].gratitude += 1;
                        this.state.gameState.stressLevel = Math.max(0, this.state.gameState.stressLevel - 1);
                        this.outputText("The whiskey burns going down, but it takes the edge off.", 'grey');
                    },
                    "local_gossip": () => {
                        const rumors = [
                            "'Strange lights down at the industrial park lately. Power company's saying it's nothing.'",
                            "'Heard the mayor's been taking meetings with some out-of-town types. Real secretive.'",
                            "'Blackwood Industries - they were into some weird stuff. Heard they had a lab out at the docks.'"
                        ];
                        const rumor = rumors[Math.floor(Math.random() * rumors.length)];
                        this.outputText(rumor, 'cyan');
                        this.state.journal.push(`Bartender rumor: ${rumor}`);
                    },
                    "stolen_goods_info": () => {
                        this.outputText("'Stolen goods? I don't deal in that kind of merchandise, detective. But if you're looking to fence something... well, I know a guy who knows a guy.'", 'cyan');
                        this.state.gameState.npcRelationships["izzy"].trust -= 1;
                        this.state.journal.push("Izzy: Knows fences for stolen goods but won't admit involvement.");
                    },
                    "show_merchandise": () => {
                        this.outputText("'Take a look around. Cigarettes for $5, crowbar for $25, flashlight for $15. Cash only.'", 'cyan');
                    },
                    "blackwood_business": () => {
                        this.outputText("'Blackwood? Yeah, he came in here sometimes. Bought some tools, paid in cash. Seemed nervous, like he was being watched. Said something about 'the diamond being trouble.''", 'cyan');
                        this.state.journal.push("Izzy: Blackwood bought tools, mentioned diamond being trouble.");
                        this.state.gameState.blackwoodCase.evidenceCollected.push("Blackwood nervous about diamond");
                    },
                    "shared_intel": () => {
                        this.outputText("You lay out your evidence for Detective Morrison. He listens intently, then sighs.", 'cyan');
                        const { result } = this.attributeCheck("charisma", 13);
                        if (result.includes("success")) {
                            this.outputText("'Alright, you've got something here. Off the record, I think you're onto something. Sterling's been acting squirrelly lately.'", 'green');
                            this.state.gameState.npcRelationships["detective_morrison"].trust += 2;
                            this.state.journal.push("Detective Morrison: Believes investigation has merit, suspects Sterling.");
                        } else {
                            this.outputText("'Interesting, but it's all circumstantial. Stick to the facts, kid.'", 'warning');
                        }
                    },
                    "file_access": () => {
                        this.outputText("'File access? That's pushing it. But... alright, I can get you the preliminary report. Don't tell anyone.'", 'cyan');
                        this.state.gameState.blackwoodCase.evidenceCollected.push("Police preliminary report");
                        this.state.journal.push("Obtained police preliminary report through Detective Morrison.");
                        this.state.gameState.npcRelationships["detective_morrison"].trust += 1;
                    },
                    "corruption_admission": () => {
                        this.outputText("Morrison looks around nervously, then leans in close.", 'cyan');
                        this.outputText("'You want to know about corruption? Fine. Blackwood was paying off half the department. When he threatened to stop... well, accidents happen.'", 'cyan');
                        this.state.gameState.blackwoodCase.evidenceCollected.push("Police corruption admission");
                        this.state.journal.push("Detective Morrison: Blackwood was paying off police, threatened to stop payments.");
                        this.state.gameState.npcRelationships["detective_morrison"].trust += 3;
                    },
                    "shipment_info": () => {
                        this.outputText("'Shipments? Yeah, there's been some unusual cargo coming through. Big crates marked 'XAI Industries' - that's Blackwood's company. Guards everywhere, no questions asked.'", 'cyan');
                        this.state.journal.push("Fisherman: Unusual XAI shipments with heavy security.");
                        this.state.gameState.npcRelationships["fisherman"].trust += 1;
                    },
                    "family_conflict": () => {
                        this.outputText("'Blackwood family? Yeah, I saw Marcus and his boy down here once. Shouting about money, inheritance. Kid stormed off saying he'd 'get what's his' one way or another.'", 'cyan');
                        this.state.journal.push("Fisherman: Witnessed argument between Marcus and David about inheritance.");
                        this.state.gameState.blackwoodCase.evidenceCollected.push("Family inheritance dispute");
                    },
                    "bonding_moment": () => {
                        this.outputText("You share a story from the war. The fisherman's eyes light up with recognition.", 'cyan');
                        this.outputText("' Guadalcanal, huh? I was in the merchant marine. Saw the same hell you did. You're alright, soldier.'", 'green');
                        this.state.gameState.npcRelationships["fisherman"].trust += 3;
                        this.state.journal.push("Bonded with fisherman over shared war experiences.");
                    },
                    "generic_info": () => {
                        this.outputText("They share some general information about the area, but nothing particularly useful for your investigation.", 'cyan');
                    }
                };

                const consequence = consequences[option.consequence];
                if (consequence) {
                    consequence.call(this);
                } else {
                    this.outputText("The conversation ends without any significant outcome.", 'grey');
                }
            },
            
            executeDialogueConsequence(option) {
                const consequences = {
                    "grateful_info": () => {
                        this.outputText("The bum's eyes light up. 'Bless you, mister! You know, I seen Blackwood down at the docks last week. He was arguing with some corporate types about some kind of experiment.'", 'cyan');
                        this.state.journal.push("Bum: Blackwood was arguing with corporate types at docks about an experiment.");
                        this.state.money -= 5;
                    },
                    "dock_info": () => {
                        this.outputText("'The docks? That's where the real action is, mister. Ships coming in at all hours, strange cargo, people acting weird. Blackwood was down there the night he died.'", 'cyan');
                        this.state.journal.push("Bum: Blackwood was at docks the night he died. Strange activity there.");
                    },
                    "missed_opportunity": () => {
                        this.outputText("You walk past the bum. He mutters something about 'ungrateful city folk' under his breath.", 'grey');
                    },
                    "vendor_gossip": () => {
                        this.outputText("'Best dogs in the city! You know, I see everything from this cart. That Blackwood fellow used to come by sometimes. Always seemed troubled, like he was carrying the weight of the world.'", 'cyan');
                        this.state.journal.push("Vendor: Blackwood seemed troubled, carrying weight of the world.");
                        this.state.money -= 3;
                    },
                    "city_news": () => {
                        this.outputText("'Oh, you mean the Blackwood thing? Whole city's talking about it. Some say it wasn't suicide, you know. Some say he knew too much about something.'", 'cyan');
                        this.state.journal.push("Vendor: Rumors that Blackwood knew too much about something.");
                    },
                    "newspaper_info": () => {
                        this.outputText("'Here you go, mister! Fresh off the press! The Blackwood case is getting weirder by the day.'", 'cyan');
                        this.state.journal.push("Newspaper: Blackwood case getting weirder by the day.");
                        this.state.money -= 2;
                    },
                    "boy_gossip": () => {
                        this.outputText("'Oh, the headlines? My pa says this Blackwood guy was mixed up in something big. Something that made powerful people nervous.'", 'cyan');
                        this.state.journal.push("Newspaper boy: Blackwood mixed up in something that made powerful people nervous.");
                    },
                    "police_info": () => {
                        this.outputText("'Crimes? This city's always got crimes, pal. But lately... there's been some strange ones. Break-ins at the industrial park, people acting weird. Like they're not themselves.'", 'cyan');
                        this.state.journal.push("Cop: Strange crimes lately - break-ins at industrial park, people acting weird.");
                    },
                    "police_attention": () => {
                        this.outputText("'Suspicious activity? Tell me more, citizen. We need all the help we can get in these troubled times.'", 'cyan');
                        this.state.journal.push("Cop: Interested in reports of suspicious activity.");
                        // This could lead to police assistance later
                    },
                    "drunk_gratitude": () => {
                        this.outputText("'You're a good man, mister. You know, I used to work at that lab down by the docks. Saw things there... glowing things that shouldn't exist.'", 'cyan');
                        this.state.journal.push("Drunk: Used to work at lab by docks, saw glowing things that shouldn't exist.");
                    },
                    "drunk_rambling": () => {
                        this.outputText("'The glow? Oh, the glow... it's everywhere now. In the water, in the air, in people's eyes. Blackwood knew about it. That's why they got him.'", 'cyan');
                        this.state.journal.push("Drunk: The glow is everywhere, Blackwood knew about it, that's why they got him.");
                    },
                    "stranger_encounter": () => {
                        this.outputText("As you approach, the figure turns to face you. 'You're investigating the Blackwood case, aren't you? Be careful. Some truths are better left buried.'", 'cyan');
                        this.state.journal.push("Mysterious stranger: Warned about investigating Blackwood case, some truths better left buried.");
                    },
                    "stranger_behavior": () => {
                        this.outputText("You watch from a distance. The figure seems to be waiting for something, checking their watch repeatedly. They're definitely not just a random passerby.", 'cyan');
                        this.state.journal.push("Mysterious stranger: Appears to be waiting for something, checking watch repeatedly.");
                    },
                    "missed_encounter": () => {
                        this.outputText("You decide to avoid the mysterious figure. Sometimes discretion is the better part of valor.", 'grey');
                    },
                    "generic_info": () => {
                        this.outputText("They share some general information about the area, but nothing particularly useful for your investigation.", 'cyan');
                    },
                    "local_gossip": () => {
                        this.outputText("They tell you about local happenings and rumors, but most of it seems unrelated to your case.", 'cyan');
                    },
                    "no_consequence": () => {
                        this.outputText("You end the conversation without any significant outcome.", 'grey');
                    }
                };
                
                const consequence = consequences[option.consequence];
                if (consequence) {
                    consequence();
                } else {
                    this.outputText("The conversation ends without any significant outcome.", 'grey');
                }
            },
            
            getNPCDialogue(npcName) {
                const dialogue = {
                    "bum": "The bum looks around nervously before continuing.\n'I seen things down at the docks, mister. Strange lights, people acting weird.'\n'Blackwood was down there the night he died. Saw him arguing with some corporate types.'\n'They was talking about some kind of experiment. Something about 'the orb' or whatever.'\nThe bum shivers. 'Don't tell nobody I told you this, okay?'"
                };
                return dialogue[npcName] || null;
            },

            handleEvelynTalk() {
                const caseState = this.state.gameState.blackwoodCase;
                const relationship = this.state.gameState.relationships.widow;
                
                if (!caseState.interviewedWidow) {
                    this.outputText("Mrs. Evelyn Blackwood looks up at you with tear-filled eyes.", 'cyan');
                    this.outputText("'Detective, thank you for coming. My husband didn't kill himself. I know it.'", 'normal');
                    this.outputText("She hands you a photograph of Marcus Blackwood. 'He was afraid of something in the weeks before his death.'", 'normal');
                    this.outputText("'The diamond - the Blackwood Star - it's worth a fortune. It disappeared the night he died.'", 'normal');
                    
                    const { result } = this.attributeCheck("charisma", 12);
                    if (result.includes("success")) {
                        this.outputText("She opens up more. 'Richard Sterling was pressuring him about the business. They had arguments.'", 'green');
                        this.state.journal.push("Evelyn Blackwood: Marcus was afraid, had arguments with Sterling about business.");
                        this.state.gameState.relationships.widow += 2;
                    } else {
                        this.outputText("She seems guarded. You'll need to gain her trust.", 'warning');
                    }
                    
                    caseState.interviewedWidow = true;
                    this.state.inventory.push("blackwood_photo");
                } else {
                    if (relationship > 2) {
                        this.outputText("'Detective, I found something in Marcus's study. A letter from Isabella Rose.'", 'green');
                        this.outputText("She hands you a crumpled letter. 'It mentions the diamond and some kind of deal.'", 'green');
                        this.state.journal.push("Found letter from Isabella Rose mentioning diamond deal.");
                        this.state.inventory.push("isabella_letter");
                    } else if (relationship < -2) {
                        this.outputText("'I don't think I can trust you, detective. You're not getting anywhere.'", 'fail');
                        this.outputText("She shows you the door.", 'fail');
                    } else {
                        this.outputText("'Any progress on the case, detective?' She looks hopeful.", 'normal');
                    }
                }
            },

            handleSterlingTalk() {
                const caseState = this.state.gameState.blackwoodCase;
                const relationship = this.state.gameState.relationships.partner;
                
                if (!caseState.interviewedPartner) {
                    this.outputText("Richard Sterling looks up from his desk with cold eyes.", 'cyan');
                    this.outputText("'Detective. I suppose you're here about Marcus. Tragic business, that suicide.'", 'normal');
                    this.outputText("'The company is in good hands now. Marcus was... troubled in his final days.'", 'normal');
                    
                    const { result } = this.attributeCheck("perception", 14);
                    if (result.includes("success")) {
                        this.outputText("You notice his hands are shaking slightly. He's nervous about something.", 'green');
                        this.state.journal.push("Sterling seems nervous, hands shaking. Hiding something?");
                        this.state.gameState.relationships.partner -= 1;
                    } else {
                        this.outputText("He seems calm and collected.", 'normal');
                    }
                    
                    caseState.interviewedPartner = true;
                } else {
                    if (relationship < -3) {
                        this.outputText("'I think you should leave, detective. You're making accusations without evidence.'", 'fail');
                        this.outputText("He calls security.", 'fail');
                        this.state.gameState.suspicionLevel += 2;
                    } else if (relationship > 2) {
                        this.outputText("'Look, detective, I'll be straight with you. Marcus was involved in something dangerous.'", 'green');
                        this.outputText("'He was meeting with some people from the docks. Something about the diamond.'", 'green');
                        this.state.journal.push("Sterling: Marcus was meeting dangerous people from docks about diamond.");
                    } else {
                        this.outputText("'Any leads on the case?' He seems guarded.", 'normal');
                    }
                }
            },

            handleIsabellaTalk() {
                const caseState = this.state.gameState.blackwoodCase;
                const relationship = this.state.gameState.relationships.mistress;
                
                if (!caseState.interviewedMistress) {
                    this.outputText("Isabella Rose looks up from her drink with sad eyes.", 'cyan');
                    this.outputText("'You're the detective, aren't you? Marcus was a good man. He didn't kill himself.'", 'normal');
                    this.outputText("'We were... close. He told me things. About the diamond, about people who wanted it.'", 'normal');
                    
                    const { result } = this.attributeCheck("charisma", 10);
                    if (result.includes("success")) {
                        this.outputText("She opens up. 'He was scared, detective. Someone was threatening him.'", 'green');
                        this.outputText("'He said if anything happened to him, to look for the diamond in the warehouse.'", 'green');
                        this.state.journal.push("Isabella: Marcus was threatened, diamond might be in warehouse.");
                        this.state.gameState.relationships.mistress += 2;
                    } else {
                        this.outputText("She seems reluctant to talk more.", 'warning');
                    }
                    
                    caseState.interviewedMistress = true;
                } else {
                    if (relationship > 2) {
                        this.outputText("'Detective, I remembered something. Marcus had a safe deposit box at the bank.'", 'green');
                        this.outputText("'The key is hidden in his office at home. Look behind the painting.'", 'green');
                        this.state.journal.push("Isabella: Safe deposit box key hidden behind painting in Marcus's office.");
                    } else if (relationship < -2) {
                        this.outputText("'I don't want to talk to you anymore. You're not helping.'", 'fail');
                    } else {
                        this.outputText("'Any news about Marcus's case?' She looks hopeful.", 'normal');
                    }
                }
            },

            handleDavidTalk() {
                const caseState = this.state.gameState.blackwoodCase;
                const relationship = this.state.gameState.relationships.son;
                
                if (!caseState.interviewedSon) {
                    this.outputText("David Blackwood looks up from his cot with angry eyes.", 'cyan');
                    this.outputText("'What do you want? My father was a bastard. Good riddance.'", 'normal');
                    this.outputText("'He threw me out when I was 18. Never looked back. Now he's dead and I'm still here.'", 'normal');
                    
                    const { result } = this.attributeCheck("charisma", 15);
                    if (result.includes("success")) {
                        this.outputText("His anger softens slightly. 'Look, I didn't kill him if that's what you're thinking.'", 'green');
                        this.outputText("'But I know he was into something dangerous. Something about a diamond.'", 'green');
                        this.state.journal.push("David: Marcus was into something dangerous involving a diamond.");
                        this.state.gameState.relationships.son += 1;
                    } else {
                        this.outputText("He's hostile and uncooperative.", 'fail');
                        this.state.gameState.relationships.son -= 1;
                    }
                    
                    caseState.interviewedSon = true;
                } else {
                    if (relationship > 2) {
                        this.outputText("'Detective, I found something in my old room. A note from my father.'", 'green');
                        this.outputText("'It says if anything happens to him, to give this to the police. But I don't trust them.'", 'green');
                        this.state.journal.push("David: Found note from Marcus to give to police if something happened.");
                        this.state.inventory.push("marcus_note");
                    } else if (relationship < -3) {
                        this.outputText("'Get out of here before I call the cops on you.'", 'fail');
                    } else {
                        this.outputText("'Still investigating my father's death?' He seems bitter.", 'normal');
                    }
                }
            },

            handleSearch(args) {
                if (!args.length) { this.outputText("Search what?"); return 0; }
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, room.features || []);
                if (!targetName) { this.outputText(`You don't see a '${args.join(' ')}' to search here.`); return 5; }

                if (targetName === "desk" && this.posKey() === '0,0,0') {
                    if (!this.state.gameState.deskSearched) {
                        this.state.gameState.deskSearched = true;
                        const { result } = this.attributeCheck("perception", 12);
                        if (result.includes("success")) {
                            this.outputText("Taped to the bottom of a drawer, you find a small, tarnished key.", 'green');
                            if (!room.items) room.items = [];
                            room.items.push("tarnished_key");
                        } else {
                            this.outputText("You search the desk but find only dust and unpaid bills.", 'grey');
                        }
                    } else { this.outputText("You've already searched the desk thoroughly."); }
                    return 10;
                } else if (targetName === "crates" && this.posKey() === '0,-4,0') {
                    if (!this.state.gameState.cratesSearched) {
                        this.state.gameState.cratesSearched = true;
                        const { result } = this.attributeCheck("perception", 10);
                        if (result.includes("success")) {
                            this.outputText("Wedged between two crates, you find a grimy notebook filled with coded entries!", 'green');
                            room.items.push("notebook");
                        } else { this.outputText("You search the crates but find only packing straw and the smell of rot.", 'grey'); }
                    } else { this.outputText("You already gave the crates a once-over."); }
                    return 10;
                } else { this.outputText(`You search the ${targetName} but find nothing of interest.`); return 5; }
            },
            
            handleUse(args) {
                const onIndex = args.indexOf('on');
                if (onIndex === -1) { this.outputText("Use what on what?"); return 1; }
                const itemToUse = this.findTarget(args.slice(0, onIndex), this.state.inventory);
                const objectToUseOn = this.findTarget(args.slice(onIndex + 1), [...(this.getCurrentRoom().items || []), ...(this.getCurrentRoom().features || []), ...this.state.inventory]);

                if (!itemToUse) { this.outputText(`You don't have a ${args.slice(0, onIndex).join(' ')}.`); return 1; }
                if (!objectToUseOn) { this.outputText(`You don't see a ${args.slice(onIndex + 1).join(' ')} here.`); return 1; }

                const room = this.getCurrentRoom();
                if ((itemToUse === "tarnished_key" || itemToUse === "key") && objectToUseOn === "lockbox") {
                     this.outputText("The key fits. With a *click*, the lockbox opens, revealing a cryptic note inside.", 'green');
                     this.state.inventory = this.state.inventory.filter(i => i !== itemToUse);
                     this.state.inventory.push("note");
                     room.items = room.items.filter(i => i !== 'lockbox');
                     this.state.gameState.lockboxOpened = true;
                     this.state.journal.push("The key from the office opened a lockbox at the pawn shop, revealing a note: 'The truth is not on the manifest, but in the glow.'");
                     return 5;
                } else if (itemToUse === "grok_orb" && objectToUseOn === "ledger") {
                    this.outputText("You hold the humming orb to the ledger. A strange light washes over the pages, and the cryptic entries resolve into a clear, damning truth about an otherworldly smuggling ring. You've found it.", 'header');
                    this.state.won = true;
                    return 5;
                } else { this.outputText("You can't use that like that."); return 2; }
            },
            
            handleThink() {
                 if (!this.state.journal || this.state.journal.length <= 1) {
                    this.outputText(this.wrapText("You rack your brain. The only thing that comes to mind is that you're pretty sure you left the stove on."), 'grey');
                 } else {
                     this.outputText("You piece together what you know...", 'cyan');
                     this.state.journal.forEach(entry => this.outputText(`- ${this.wrapText(entry, 2)}`, 'cyan'));
                 }
                 return 5;
            },
            
            showHelp() {
                this.outputText("--- DETECTIVE'S COMMANDS ---", 'header');
                this.outputText("Navigation:  go <dir>, n, s, e, w, u, d");
                this.outputText("Interaction: look, look at <obj>, take <item>, drop <item>");
                this.outputText("             search <obj>, talk to <npc>, use <item> on <object>");
                this.outputText("             give <item> to <npc>, attack <npc>");
                this.outputText("Social:      talk to <npc> (dynamic dialogue options based on game state)");
                this.outputText("Combat:      attack <npc>, equip <weapon>, unequip");
                this.outputText("Gambling:    gamble <amount> (at casino)");
                this.outputText("Reading:     read <item>, read case_file");
                this.outputText("Covert:      break into <place>, pick lock, pry <door>");
                this.outputText("Jobs:        contracts, accept <num>, work contract");
                this.outputText("Personal:    smoke, drink, think");
                this.outputText("Shopping:    buy <item>, bluff <item>, steal <item> (at pawn shop)");
                this.outputText("Investigation: investigate, confront <suspect>");
                this.outputText("Meta:        status, inventory (i), journal, map, hint, stolen, quit");
                this.outputText("Save/Load:   save [name], load <name>, saves, delete_save <name>");
                this.outputText("----------------", 'header');
                return 0;
            },

            showInventory() {
                if (this.state.inventory.length > 0) {
                    this.outputText("Inventory: " + this.state.inventory.join(', '));
                } else {
                    this.outputText("You aren't carrying anything.");
                }
                return 0;
            },
            
            handleInvestigate(args) {
                const caseState = this.state.gameState.blackwoodCase;
                const evidenceCount = caseState.evidenceCollected.length;
                
                this.outputText("You review the evidence you've gathered...", 'cyan');
                
                if (evidenceCount === 0) {
                    this.outputText("You haven't gathered any evidence yet. Talk to suspects and search locations.", 'warning');
                    return 5;
                }
                
                this.outputText(`Evidence collected: ${evidenceCount} pieces`, 'header');
                caseState.evidenceCollected.forEach((evidence, index) => {
                    this.outputText(`${index + 1}. ${evidence}`, 'normal');
                });
                
                // Determine if you have enough evidence to solve the case
                if (evidenceCount >= 4 && caseState.interviewedWidow && caseState.interviewedPartner && 
                    caseState.interviewedMistress && caseState.interviewedSon) {
                    
                    this.outputText("\nYou've gathered enough evidence to piece together the truth...", 'green');
                    this.outputText("The Blackwood Star diamond was stolen by Richard Sterling.", 'green');
                    this.outputText("He killed Marcus Blackwood to cover up the theft and make it look like suicide.", 'green');
                    this.outputText("Isabella Rose knew about the theft but was too scared to come forward.", 'green');
                    this.outputText("David Blackwood had nothing to do with it - he was just bitter about his father.", 'green');
                    
                    caseState.discoveredTruth = true;
                    this.state.journal.push("SOLVED: Sterling killed Marcus and stole the diamond. Isabella knew but was scared.");
                    return 20;
                } else {
                    this.outputText("\nYou need more evidence to solve this case.", 'warning');
                    this.outputText("Interview all suspects and gather more clues.", 'warning');
                    return 10;
                }
            },

            handleConfront(args) {
                if (!args.length) { 
                    this.outputText("Confront who? (sterling, isabella, david, evelyn)"); 
                    return 0; 
                }
                
                const caseState = this.state.gameState.blackwoodCase;
                if (!caseState.discoveredTruth) {
                    this.outputText("You need to investigate first and gather evidence.", 'warning');
                    return 5;
                }
                
                const target = args[0].toLowerCase();
                
                if (target === "sterling") {
                    this.outputText("You confront Richard Sterling with the evidence.", 'cyan');
                    this.outputText("'I know you killed Marcus Blackwood and stole the diamond.'", 'normal');
                    
                    const { result } = this.attributeCheck("charisma", 16);
                    if (result.includes("success")) {
                        this.outputText("Sterling breaks down. 'I didn't mean to kill him! He caught me stealing the diamond.'", 'green');
                        this.outputText("'It was an accident! I panicked and made it look like suicide.'", 'green');
                        this.outputText("You've solved the case! Sterling confesses to manslaughter.", 'green');
                        this.state.won = true;
                        this.state.gameOver = true;
                        return 30;
                    } else {
                        this.outputText("Sterling denies everything and calls security.", 'fail');
                        this.state.gameState.suspicionLevel += 3;
                        return 15;
                    }
                } else if (target === "isabella") {
                    this.outputText("You confront Isabella Rose about what she knew.", 'cyan');
                    this.outputText("'Why didn't you come forward about Sterling's theft?'", 'normal');
                    
                    const { result } = this.attributeCheck("charisma", 12);
                    if (result.includes("success")) {
                        this.outputText("Isabella breaks down in tears. 'I was scared! Sterling threatened me too.'", 'green');
                        this.outputText("'But I can testify against him now. I'll help you bring him to justice.'", 'green');
                        this.state.gameState.relationships.mistress += 3;
                        return 20;
                    } else {
                        this.outputText("Isabella refuses to talk and leaves.", 'fail');
                        return 10;
                    }
                } else {
                    this.outputText("You can't confront that person with the evidence you have.", 'warning');
                    return 5;
                }
            },
            
            updateMoneyDisplay() {
                const moneyDisplay = document.getElementById('money-display');
                if (moneyDisplay) {
                    moneyDisplay.textContent = `$${this.state.cash}`;
                }
            },

            spendMoney(amount, reason = "purchase") {
                const oldCash = this.state.cash;
                this.state.cash -= amount;
                this.updateMoneyDisplay();

                // Show spending notification
                if (amount > 0) {
                    this.outputText(`[SPENT $${amount} on ${reason} - $${oldCash} → $${this.state.cash}]`, 'warning');
                } else if (amount < 0) {
                    // Gained money
                    const gained = Math.abs(amount);
                    this.outputText(`[GAINED $${gained} from ${reason} - $${oldCash} → $${this.state.cash}]`, 'green');
                }
            },
            
            showStatus() {
                 const { time, health, cash, debt, gameState, equippedWeapon } = this.state;
                 const timeStr = `Day ${time.day}, ${String(time.hour).padStart(2, '0')}:${String(time.minute).padStart(2, '0')}`;
                 this.outputText(`--- DETECTIVE'S FILE ---`, 'header');
                 this.outputText(` Time: ${timeStr}`);
                 this.outputText(` Health: ${health}/5 | Cash: $${cash} | Debt: $${debt}`);
                 this.outputText(` Suspicion: ${gameState.suspicionLevel}`);
                 this.outputText(` Equipped: ${equippedWeapon.replace(/_/g, ' ')}`);
                 
                 // Contextual stress and hunger feedback
                 this.showContextualStatus();
                 
                 return 0;
            },

            showContextualStatus() {
                const { gameState } = this.state;
                
                // Stress feedback
                if (gameState.stressLevel >= 4) {
                    this.outputText(`<span style="color: #ff6b6b;">*The weight of the case presses down on your shoulders*</span>`, 'warning');
                    this.outputText(`<span style="color: #ff6b6b;">Thinking to self: "Sometimes, the crushing weight of this job is too much to bear. Every lead dead-ends, every witness lies, every clue leads deeper into the darkness. I need a drink or I'll crack."</span>`, 'warning');
                } else if (gameState.stressLevel >= 2) {
                    this.outputText(`<span style="color: #ffa500;">*You feel the pressure building*</span>`, 'warning');
                    this.outputText(`<span style="color: #ffa500;">Thinking to self: "This case is getting to me. Maybe I should take a break, clear my head. A good detective knows when to step back."</span>`, 'warning');
                }
                
                // Hunger feedback
                if (gameState.hunger >= 3) {
                    this.outputText(`<span style="color: #ff6b6b;">*Your stomach growls with hunger*</span>`, 'warning');
                    this.outputText(`<span style="color: #ff6b6b;">Thinking to self: "When is the last time I had some grub? My body is weak from lack of sustenance. I need to find some food before I collapse."</span>`, 'warning');
                } else if (gameState.hunger >= 1) {
                    this.outputText(`<span style="color: #ffa500;">*You feel a pang of hunger*</span>`, 'warning');
                    this.outputText(`<span style="color: #ffa500;">Thinking to self: "Could use a good meal. Maybe some diner food or a sandwich from the corner deli."</span>`, 'warning');
                }
                
                // Health feedback
                if (this.state.health <= 2) {
                    this.outputText(`<span style="color: #ff6b6b;">*You feel like you got your ass handed to you by a gang of roided up synthsurfers*</span>`, 'error');
                    this.outputText(`<span style="color: #ff6b6b;">Thinking to self: "My spleen might be broken. Can you break a spleen? I need medical attention or I'm not gonna make it through the night."</span>`, 'error');
                } else if (this.state.health <= 3) {
                    this.outputText(`<span style="color: #ffa500;">*You feel the pain of your wounds*</span>`, 'warning');
                    this.outputText(`<span style="color: #ffa500;">Thinking to self: "I'm hurt but not broken. My wounds are healing slowly, but I should be more careful. Maybe some rest or a first aid kit would help."</span>`, 'warning');
                }
            },

            checkRandomEncounter() {
                // 20% chance of random encounter in noir
                if (Math.random() < 0.20) {
                    this.triggerRandomEncounter();
                }
            },

            triggerRandomEncounter() {
                const encounters = [
                    {
                        name: "Mysterious Stranger",
                        description: "A figure in a trench coat steps out of the shadows, their face hidden beneath a wide-brimmed hat. 'You're the detective, aren't you?' they say in a voice that sounds like gravel and regret. 'I've got information about the Blackwood case. But it's dangerous. Very dangerous.'",
                        actions: [
                            "Ask for the information",
                            "Offer to pay",
                            "Be cautious"
                        ],
                        consequences: {
                            "ask": "The stranger's eyes gleam in the darkness. 'Blackwood didn't kill himself. He was murdered. And the killer is still out there, watching, waiting. They know you're getting close.'",
                            "pay": "You hand over some cash. The stranger counts it carefully. 'Thanks, detective. Here's what I know: Blackwood was onto something big. Something that would have brought down half the city. That's why they had to silence him.'",
                            "cautious": "The stranger nods approvingly. 'Smart. Not everyone who offers to help is actually helping. But I'm legit. Here's a name: Tony the Snake. He knows more than he's telling.'"
                        }
                    },
                    {
                        name: "Corrupt Cop",
                        description: "A police officer in a rumpled uniform approaches you, his badge gleaming dully in the streetlight. 'Detective, I need to talk to you,' he says, looking around nervously. 'It's about the Blackwood case. I can't say much, but... there are things going on that you don't know about. Things that could get you killed.'",
                        actions: [
                            "Listen to what he has to say",
                            "Try to intimidate him",
                            "Walk away"
                        ],
                        consequences: {
                            "listen": "The cop's voice drops to a whisper. 'The chief is dirty. Half the department is on the take. They're covering up the real cause of Blackwood's death because it would expose everything.'",
                            "intimidate": "You lean in close, using your detective's authority. The cop breaks. 'Alright, alright! The evidence room is locked for a reason. There's stuff in there that would blow this case wide open.'",
                            "walk": "You turn and walk away. The cop calls after you: 'You're making a mistake, detective. This case is bigger than you think.'"
                        }
                    },
                    {
                        name: "Witness",
                        description: "A young woman approaches you, her eyes wide with fear. 'Are you the detective investigating the Blackwood case?' she asks, her voice trembling. 'I saw something. Something I wasn't supposed to see. I've been hiding ever since, but I can't keep running.'",
                        actions: [
                            "Ask what she saw",
                            "Offer protection",
                            "Be skeptical"
                        ],
                        consequences: {
                            "ask": "The woman looks around nervously. 'I was working late at the office building across from Blackwood Industries. I saw men in suits going in and out all night. Then I heard gunshots. But when the police came, they said it was a suicide.'",
                            "protect": "You offer to help keep her safe. She's grateful. 'Thank you, detective. I'll tell you everything I know. But please, be careful. These people are dangerous.'",
                            "skeptical": "You question her story. She gets defensive. 'I know what I saw! If you don't believe me, fine. But don't say I didn't warn you.'"
                        }
                    }
                ];

                const encounter = encounters[Math.floor(Math.random() * encounters.length)];
                this.outputText(`<span style="color: #ff6b6b;">--- RANDOM ENCOUNTER ---</span>`, 'header');
                this.outputText(encounter.description, 'cyan');
                this.outputText(`<span style="color: #ffa500;">What do you do?</span>`, 'warning');
                
                // Store encounter for potential follow-up
                this.state.gameState.randomEncounters.push({
                    name: encounter.name,
                    time: `${this.state.time.day}:${String(this.state.time.hour).padStart(2, '0')}`,
                    location: this.getCurrentRoom().name
                });
            },

            // --- EPIC SYSTEMS ---
            
            handleQuests() {
                this.outputText("--- ACTIVE SIDE QUESTS ---", 'header');
                
                if (this.state.gameState.sideQuests.length === 0) {
                    this.outputText("No active side quests. Keep your eyes open for opportunities.", 'grey');
                    return 0;
                }
                
                this.state.gameState.sideQuests.forEach((quest, index) => {
                    this.outputText(`${index + 1}. ${quest.title}`, 'cyan');
                    this.outputText(`   ${quest.description}`, 'normal');
                    this.outputText(`   Status: ${quest.status}`, 'yellow');
                    if (quest.objectives) {
                        quest.objectives.forEach(obj => {
                            const status = obj.completed ? '✓' : '○';
                            this.outputText(`   ${status} ${obj.description}`, obj.completed ? 'green' : 'grey');
                        });
                    }
                    this.outputText("", 'normal');
                });
                
                return 0;
            },

            handleSkills() {
                this.outputText("--- DETECTIVE SKILLS ---", 'header');
                this.outputText(`Skill Points Available: ${this.state.gameState.skillPoints}`, 'cyan');
                this.outputText("", 'normal');
                
                Object.entries(this.state.gameState.skills).forEach(([skill, level]) => {
                    const skillName = skill.charAt(0).toUpperCase() + skill.slice(1).replace(/_/g, ' ');
                    const bar = '█'.repeat(level) + '░'.repeat(10 - level);
                    this.outputText(`${skillName}: [${bar}] (${level}/10)`, 'normal');
                });
                
                this.outputText("", 'normal');
                this.outputText("Use 'train [skill]' to improve a skill (costs 1 skill point)", 'yellow');
                
                return 0;
            },

            handleReputation() {
                this.outputText("--- REPUTATION TRACKER ---", 'header');
                
                Object.entries(this.state.gameState.reputation).forEach(([group, level]) => {
                    const groupName = group.charAt(0).toUpperCase() + group.slice(1);
                    const bar = level > 0 ? '█'.repeat(Math.min(level, 10)) : '░'.repeat(Math.min(Math.abs(level), 10));
                    const color = level > 0 ? 'green' : level < 0 ? 'red' : 'grey';
                    this.outputText(`${groupName}: [${bar}] (${level})`, color);
                });
                
                this.outputText("", 'normal');
                this.outputText("Your reputation affects how NPCs treat you and what opportunities are available.", 'yellow');
                
                return 0;
            },

            handleLore() {
                this.outputText("--- LORE COLLECTION ---", 'header');
                
                const loreItems = this.state.inventory.filter(item => 
                    this.data.items[item] && this.data.items[item].lore
                );
                
                if (loreItems.length === 0) {
                    this.outputText("No lore items in your possession. Look for books, documents, and other sources of information.", 'grey');
                    return 0;
                }
                
                loreItems.forEach(item => {
                    this.outputText(`• ${item.replace(/_/g, ' ').toUpperCase()}`, 'cyan');
                    this.outputText(`  ${this.data.items[item].desc}`, 'normal');
                    this.outputText("", 'normal');
                });
                
                return 0;
            },

            handleHack(args) {
                if (!args.length) {
                    this.outputText("Hack what? (terminal, system, database)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                const room = this.getCurrentRoom();
                
                if (!room.features || !room.features.includes('terminal')) {
                    this.outputText("There's no terminal here to hack.");
                    return 0;
                }
                
                this.outputText("You attempt to hack the terminal...", 'cyan');
                
                // Mini-game: Real hacking simulation
                this.startHackingMiniGame(target);
                
                return 5;
            },

            startHackingMiniGame(target) {
                this.outputText("--- HACKING SIMULATION ---", 'header');
                this.outputText("Type the commands to break through the security system:", 'yellow');
                this.outputText("", 'normal');
                
                const hackingSequence = [
                    { command: "nmap -sS target", description: "Scan for open ports" },
                    { command: "hydra -l admin -P passwords.txt ssh", description: "Brute force SSH login" },
                    { command: "sqlmap -u target --dbs", description: "Extract database information" },
                    { command: "metasploit exploit/windows/smb/ms17_010_eternalblue", description: "Exploit vulnerability" }
                ];
                
                let currentStep = 0;
                let attempts = 0;
                const maxAttempts = 3;
                
                const checkCommand = (input) => {
                    const userCommand = input.toLowerCase().trim();
                    const expectedCommand = hackingSequence[currentStep].command.toLowerCase();
                    
                    if (userCommand === expectedCommand) {
                        this.outputText(`✓ ${hackingSequence[currentStep].description}`, 'green');
                        currentStep++;
                        
                        if (currentStep >= hackingSequence.length) {
                            this.outputText("", 'normal');
                            this.outputText("*** HACKING SUCCESSFUL ***", 'green');
                            this.outputText("You've gained access to the system!", 'green');
                            
                            // Reward
                            this.state.gameState.skillPoints += 2;
                            this.state.gameState.skills.hacking += 1;
                            this.outputText("+2 Skill Points, +1 Hacking Skill", 'green');
                            
                            // Find useful information
                            const info = this.getHackingReward(target);
                            if (info) {
                                this.outputText(`You discover: ${info}`, 'cyan');
                            }
                            
                            return true;
                        } else {
                            this.outputText("", 'normal');
                            this.outputText(`Next command needed:`, 'yellow');
                            this.outputText(`Hint: ${hackingSequence[currentStep].description}`, 'grey');
                        }
                    } else {
                        attempts++;
                        this.outputText(`✗ Command failed (${attempts}/${maxAttempts})`, 'red');
                        
                        if (attempts >= maxAttempts) {
                            this.outputText("", 'normal');
                            this.outputText("*** HACKING FAILED ***", 'red');
                            this.outputText("Security system detected your intrusion!", 'red');
                            this.state.gameState.suspicionLevel += 2;
                            return true;
                        } else {
                            this.outputText(`Try again. Hint: ${hackingSequence[currentStep].description}`, 'yellow');
                        }
                    }
                    
                    return false;
                };
                
                // Set up the hacking interface
                this.hackingMode = true;
                this.hackingCallback = checkCommand;
                this.outputText(`Command ${currentStep + 1}:`, 'cyan');
            },

            getHackingReward(target) {
                const rewards = {
                    terminal: "Access logs showing suspicious activity around the time of Blackwood's death",
                    system: "Encrypted files containing financial records and communications",
                    database: "User accounts and access patterns that don't match official records"
                };
                
                return rewards[target] || "System files and configuration data";
            },

            handleLockpick(args) {
                if (!args.length) {
                    this.outputText("Lockpick what? (door, safe, cabinet)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                const room = this.getCurrentRoom();
                
                if (!this.state.inventory.includes('lockpicks')) {
                    this.outputText("You need lockpicks to do that.");
                    return 0;
                }
                
                this.outputText("You attempt to pick the lock...", 'cyan');
                
                // Mini-game: Lockpicking simulation
                this.startLockpickingMiniGame(target);
                
                return 5;
            },

            startLockpickingMiniGame(target) {
                this.outputText("--- LOCKPICKING SIMULATION ---", 'header');
                this.outputText("Use your mouse to feel for the pins. Click when you feel resistance.", 'yellow');
                this.outputText("", 'normal');
                
                // Create a simple lockpicking interface
                const lockpickingHTML = `
                    <div id="lockpicking-game" style="
                        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        background: rgba(0,0,0,0.9); color: #8be9fd; padding: 20px;
                        border: 2px solid #8be9fd; border-radius: 8px; z-index: 1000;
                        text-align: center; font-family: monospace;
                    ">
                        <h3>LOCKPICKING CHALLENGE</h3>
                        <div id="lock-display" style="
                            width: 300px; height: 100px; background: #333;
                            border: 2px solid #8be9fd; margin: 20px auto;
                            position: relative; overflow: hidden;
                        ">
                            <div id="pick" style="
                                position: absolute; bottom: 0; left: 50%;
                                width: 2px; height: 60px; background: #8be9fd;
                                transform: translateX(-50%);
                            "></div>
                        </div>
                        <p>Click to test the pins. Find the sweet spot!</p>
                        <button onclick="game.finishLockpicking()">Give Up</button>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', lockpickingHTML);
                
                // Set up the game
                this.lockpickingMode = true;
                this.lockpickingTarget = target;
                this.lockpickingPins = this.generateLockpickingPins();
                this.lockpickingProgress = 0;
                
                this.setupLockpickingControls();
            },

            generateLockpickingPins() {
                // Generate 5 pins with different difficulty levels
                return Array.from({length: 5}, (_, i) => ({
                    position: Math.random() * 0.8 + 0.1, // 10% to 90% of the lock
                    difficulty: Math.random() * 0.3 + 0.1, // 10% to 40% tolerance
                    picked: false
                }));
            },

            setupLockpickingControls() {
                const lockDisplay = document.getElementById('lock-display');
                const pick = document.getElementById('pick');
                
                lockDisplay.addEventListener('click', (e) => {
                    if (!this.lockpickingMode) return;
                    
                    const rect = lockDisplay.getBoundingClientRect();
                    const clickX = (e.clientX - rect.left) / rect.width;
                    
                    this.testLockpickingPin(clickX);
                });
            },

            testLockpickingPin(clickX) {
                const pin = this.lockpickingPins[this.lockpickingProgress];
                const distance = Math.abs(clickX - pin.position);
                
                if (distance <= pin.difficulty) {
                    pin.picked = true;
                    this.lockpickingProgress++;
                    
                    this.outputText(`✓ Pin ${this.lockpickingProgress} picked!`, 'green');
                    
                    if (this.lockpickingProgress >= this.lockpickingPins.length) {
                        this.finishLockpicking(true);
                    }
                } else {
                    this.outputText(`✗ Missed pin ${this.lockpickingProgress + 1}`, 'red');
                }
            },

            finishLockpicking(success = false) {
                document.getElementById('lockpicking-game')?.remove();
                this.lockpickingMode = false;
                
                if (success) {
                    this.outputText("*** LOCKPICKING SUCCESSFUL ***", 'green');
                    this.outputText("The lock clicks open!", 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.lockpicking += 1;
                    this.outputText("+1 Skill Point, +1 Lockpicking Skill", 'green');
                    
                    // Unlock the target
                    this.unlockTarget(this.lockpickingTarget);
                } else {
                    this.outputText("*** LOCKPICKING FAILED ***", 'red');
                    this.outputText("The lock remains stubbornly closed.", 'red');
                }
            },

            unlockTarget(target) {
                const room = this.getCurrentRoom();
                if (room.lockedFeatures) {
                    room.lockedFeatures = room.lockedFeatures.filter(f => f !== target);
                }
                this.outputText(`The ${target} is now unlocked.`, 'green');
            },

            handleDeduce(args) {
                if (!args.length) {
                    this.outputText("Deduce what? (evidence, situation, person)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText("You carefully analyze the evidence...", 'cyan');
                
                // Deduction mini-game
                this.startDeductionMiniGame(target);
                
                return 10;
            },

            startDeductionMiniGame(target) {
                this.outputText("--- DEDUCTION CHALLENGE ---", 'header');
                
                const deductionPuzzles = {
                    evidence: {
                        clues: [
                            "The victim's watch stopped at 11:47 PM",
                            "There are three different types of footprints at the scene",
                            "The window was broken from the outside",
                            "The victim's wallet is missing",
                            "There's a faint smell of expensive cologne"
                        ],
                        question: "What can you deduce about the crime?",
                        answers: [
                            "Multiple perpetrators were involved",
                            "The victim was robbed",
                            "The break-in was planned",
                            "The perpetrator is wealthy"
                        ],
                        correct: [0, 1, 2, 3]
                    },
                    situation: {
                        clues: [
                            "The mayor's office has been locked for three days",
                            "Security cameras were disabled at 2 AM",
                            "A large sum of money was withdrawn from city funds",
                            "The mayor's assistant hasn't been seen since",
                            "There are signs of a struggle in the office"
                        ],
                        question: "What likely happened?",
                        answers: [
                            "The mayor was kidnapped",
                            "The assistant embezzled money",
                            "There was a break-in",
                            "The mayor is hiding something"
                        ],
                        correct: [0, 1]
                    }
                };
                
                const puzzle = deductionPuzzles[target] || deductionPuzzles.evidence;
                
                this.outputText("Clues:", 'yellow');
                puzzle.clues.forEach((clue, i) => {
                    this.outputText(`${i + 1}. ${clue}`, 'normal');
                });
                
                this.outputText("", 'normal');
                this.outputText(puzzle.question, 'cyan');
                this.outputText("", 'normal');
                
                puzzle.answers.forEach((answer, i) => {
                    this.outputText(`${String.fromCharCode(97 + i)}. ${answer}`, 'normal');
                });
                
                this.outputText("", 'normal');
                this.outputText("Type your deductions (e.g., 'a b d' for multiple answers):", 'yellow');
                
                // Set up deduction callback
                this.deductionMode = true;
                this.deductionPuzzle = puzzle;
            },

            handleInterrogate(args) {
                if (!args.length) {
                    this.outputText("Interrogate who?");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                const room = this.getCurrentRoom();
                
                if (!room.npcs || !room.npcs[target]) {
                    this.outputText("There's no one here by that name to interrogate.");
                    return 0;
                }
                
                this.outputText(`You begin interrogating ${target}...`, 'cyan');
                
                // Interrogation mini-game
                this.startInterrogationMiniGame(target);
                
                return 15;
            },

            startInterrogationMiniGame(target) {
                this.outputText("--- INTERROGATION ---", 'header');
                this.outputText("Choose your interrogation approach:", 'yellow');
                this.outputText("", 'normal');
                this.outputText("1. Good Cop - Build rapport and trust", 'green');
                this.outputText("2. Bad Cop - Intimidate and pressure", 'red');
                this.outputText("3. Good Cop/Bad Cop - Alternate between approaches", 'yellow');
                this.outputText("4. Psychological - Play mind games", 'purple');
                this.outputText("", 'normal');
                this.outputText("Type the number of your choice:", 'cyan');
                
                this.interrogationMode = true;
                this.interrogationTarget = target;
            },

            handleSurveil(args) {
                if (!args.length) {
                    this.outputText("Surveil what? (person, location, building)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin surveilling ${target}...`, 'cyan');
                
                // Surveillance mini-game
                this.startSurveillanceMiniGame(target);
                
                return 20;
            },

            startSurveillanceMiniGame(target) {
                this.outputText("--- SURVEILLANCE ---", 'header');
                this.outputText("You set up surveillance. Watch for suspicious activity...", 'yellow');
                this.outputText("", 'normal');
                
                // Simulate surveillance time
                this.outputText("Time passes...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** SURVEILLANCE COMPLETE ***", 'green');
                    
                    const surveillanceResults = this.getSurveillanceResults(target);
                    this.outputText(`You observe: ${surveillanceResults}`, 'cyan');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+1 Skill Point, +1 Investigation Skill", 'green');
                    
                }, 3000);
            },

            getSurveillanceResults(target) {
                const results = {
                    person: "The target meets with several suspicious individuals and exchanges packages",
                    location: "Multiple people enter and leave the building at odd hours",
                    building: "Security patrols are irregular and there are blind spots in coverage"
                };
                
                return results[target] || "Nothing suspicious observed";
            },

            handleStakeout(args) {
                if (!args.length) {
                    this.outputText("Stakeout what? (location, person, building)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin a stakeout of ${target}...`, 'cyan');
                
                // Stakeout mini-game
                this.startStakeoutMiniGame(target);
                
                return 30;
            },

            startStakeoutMiniGame(target) {
                this.outputText("--- STAKEOUT ---", 'header');
                this.outputText("You settle in for a long stakeout. Stay alert...", 'yellow');
                this.outputText("", 'normal');
                
                // Simulate stakeout time
                this.outputText("Hours pass...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** STAKEOUT COMPLETE ***", 'green');
                    
                    const stakeoutResults = this.getStakeoutResults(target);
                    this.outputText(`You discover: ${stakeoutResults}`, 'cyan');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+2 Skill Points, +1 Investigation Skill", 'green');
                    
                }, 5000);
            },

            getStakeoutResults(target) {
                const results = {
                    location: "The location is used as a meeting place for criminal activities",
                    person: "The target is involved in illegal operations and has multiple aliases",
                    building: "The building has secret entrances and is used for money laundering"
                };
                
                return results[target] || "Nothing significant observed";
            },

            // --- ADVANCED AI & PROCEDURAL SYSTEMS ---
            
            // AI-Driven NPC Behavior System
            initializeNPCAI() {
                this.npcAI = {
                    memory: new Map(), // NPCs remember past interactions
                    relationships: new Map(), // Dynamic relationship tracking
                    schedules: new Map(), // AI-driven scheduling
                    personalities: new Map(), // Procedural personality traits
                    goals: new Map(), // NPCs have their own objectives
                    reactions: new Map() // Context-aware reactions
                };
                
                // Initialize AI for all NPCs
                Object.keys(this.npcStats).forEach(npcId => {
                    this.initializeNPCPersonality(npcId);
                    this.generateNPCGoals(npcId);
                    this.setupNPCSchedule(npcId);
                });
            },

            initializeNPCPersonality(npcId) {
                const traits = ['suspicious', 'friendly', 'nervous', 'confident', 'secretive', 'talkative', 'aggressive', 'cautious'];
                const personality = {
                    primary: traits[Math.floor(Math.random() * traits.length)],
                    secondary: traits[Math.floor(Math.random() * traits.length)],
                    openness: Math.random(),
                    conscientiousness: Math.random(),
                    extraversion: Math.random(),
                    agreeableness: Math.random(),
                    neuroticism: Math.random()
                };
                
                this.npcAI.personalities.set(npcId, personality);
                this.npcAI.memory.set(npcId, []);
                this.npcAI.relationships.set(npcId, {});
            },

            generateNPCGoals(npcId) {
                const goals = [
                    'find_money', 'avoid_trouble', 'gain_information', 'protect_secret',
                    'make_connection', 'settle_debt', 'find_evidence', 'stay_hidden'
                ];
                
                const activeGoals = [];
                const numGoals = Math.floor(Math.random() * 3) + 1;
                
                for (let i = 0; i < numGoals; i++) {
                    const goal = goals[Math.floor(Math.random() * goals.length)];
                    if (!activeGoals.includes(goal)) {
                        activeGoals.push(goal);
                    }
                }
                
                this.npcAI.goals.set(npcId, activeGoals);
            },

            setupNPCSchedule(npcId) {
                const schedule = {
                    locations: [],
                    times: [],
                    activities: []
                };
                
                // Generate 3-5 schedule entries
                const numEntries = Math.floor(Math.random() * 3) + 3;
                for (let i = 0; i < numEntries; i++) {
                    const hour = Math.floor(Math.random() * 24);
                    const location = this.getRandomLocation();
                    const activity = this.getRandomActivity();
                    
                    schedule.times.push(hour);
                    schedule.locations.push(location);
                    schedule.activities.push(activity);
                }
                
                this.npcAI.schedules.set(npcId, schedule);
            },

            getRandomLocation() {
                const locations = Object.keys(this.data.worldMap);
                return locations[Math.floor(Math.random() * locations.length)];
            },

            getRandomActivity() {
                const activities = ['working', 'meeting', 'waiting', 'observing', 'hiding', 'planning'];
                return activities[Math.floor(Math.random() * activities.length)];
            },

            // Procedural Quest Generation
            generateProceduralQuest() {
                const questTypes = [
                    'investigation', 'delivery', 'surveillance', 'negotiation', 'infiltration', 'rescue'
                ];
                
                const questType = questTypes[Math.floor(Math.random() * questTypes.length)];
                const quest = this.createQuest(questType);
                
                this.state.gameState.sideQuests.push(quest);
                this.outputText(`*** NEW QUEST AVAILABLE ***`, 'header');
                this.outputText(`Quest: ${quest.title}`, 'cyan');
                this.outputText(`Type: ${quest.type}`, 'yellow');
                this.outputText(`Reward: $${quest.reward}`, 'green');
                this.outputText(`Use 'quests' to see details`, 'grey');
            },

            createQuest(type) {
                const questTemplates = {
                    investigation: {
                        title: "The Missing Evidence",
                        description: "Someone has stolen important evidence. Find it before it's too late.",
                        objectives: ["Search crime scene", "Interview witnesses", "Follow leads"],
                        reward: Math.floor(Math.random() * 500) + 200,
                        difficulty: "Medium",
                        timeLimit: 24
                    },
                    delivery: {
                        title: "Sensitive Package",
                        description: "Deliver a package to a specific location without being seen.",
                        objectives: ["Pick up package", "Avoid detection", "Make delivery"],
                        reward: Math.floor(Math.random() * 300) + 150,
                        difficulty: "Easy",
                        timeLimit: 12
                    },
                    surveillance: {
                        title: "Watch the Watchers",
                        description: "Keep an eye on a suspicious character for 6 hours.",
                        objectives: ["Find target", "Maintain surveillance", "Report findings"],
                        reward: Math.floor(Math.random() * 400) + 250,
                        difficulty: "Hard",
                        timeLimit: 36
                    },
                    negotiation: {
                        title: "The Deal Maker",
                        description: "Negotiate a deal between two parties who don't trust each other.",
                        objectives: ["Meet both parties", "Find common ground", "Seal the deal"],
                        reward: Math.floor(Math.random() * 600) + 300,
                        difficulty: "Hard",
                        timeLimit: 48
                    },
                    infiltration: {
                        title: "Behind Enemy Lines",
                        description: "Infiltrate a secure location and gather information.",
                        objectives: ["Find entry point", "Avoid guards", "Gather intel", "Escape safely"],
                        reward: Math.floor(Math.random() * 800) + 400,
                        difficulty: "Extreme",
                        timeLimit: 72
                    },
                    rescue: {
                        title: "The Hostage",
                        description: "Rescue someone who's been taken against their will.",
                        objectives: ["Locate hostage", "Plan rescue", "Execute rescue", "Get to safety"],
                        reward: Math.floor(Math.random() * 700) + 350,
                        difficulty: "Extreme",
                        timeLimit: 60
                    }
                };
                
                return {
                    id: Date.now(),
                    type: type,
                    ...questTemplates[type],
                    status: 'available',
                    progress: 0,
                    startTime: this.state.time
                };
            },

            // Advanced Stock Market System
            initializeStockMarket() {
                this.stockMarket = {
                    companies: [
                        { name: "Blackwood Industries", symbol: "BWI", price: 100, volatility: 0.15 },
                        { name: "Metro Security Corp", symbol: "MSC", price: 75, volatility: 0.12 },
                        { name: "Nightfall Holdings", symbol: "NFH", price: 150, volatility: 0.20 },
                        { name: "Shadow Enterprises", symbol: "SHE", price: 200, volatility: 0.25 },
                        { name: "Truth Media Group", symbol: "TMG", price: 50, volatility: 0.18 }
                    ],
                    playerPortfolio: {},
                    marketEvents: [],
                    lastUpdate: 0
                };
            },

            updateStockMarket() {
                const now = Date.now();
                if (now - this.stockMarket.lastUpdate < 300000) return; // Update every 5 minutes
                
                this.stockMarket.companies.forEach(company => {
                    const change = (Math.random() - 0.5) * company.volatility * company.price;
                    company.price = Math.max(1, company.price + change);
                });
                
                this.stockMarket.lastUpdate = now;
                this.generateMarketEvent();
            },

            generateMarketEvent() {
                const events = [
                    "Breaking: Major scandal rocks the financial sector",
                    "Rumor: Corporate merger talks heating up",
                    "Alert: Suspicious trading activity detected",
                    "News: New regulations affecting all companies",
                    "Update: Market volatility reaches new highs"
                ];
                
                const event = events[Math.floor(Math.random() * events.length)];
                this.stockMarket.marketEvents.unshift({
                    text: event,
                    timestamp: Date.now(),
                    impact: Math.random() > 0.5 ? 'positive' : 'negative'
                });
                
                // Keep only last 10 events
                if (this.stockMarket.marketEvents.length > 10) {
                    this.stockMarket.marketEvents = this.stockMarket.marketEvents.slice(0, 10);
                }
            },

            // Social Network System
            initializeSocialNetwork() {
                this.socialNetwork = {
                    connections: new Map(), // Who knows whom
                    rumors: [], // Circulating information
                    secrets: new Map(), // Hidden knowledge
                    influence: new Map(), // Social power
                    gossip: [] // Social chatter
                };
                
                // Initialize connections between NPCs
                this.generateSocialConnections();
            },

            generateSocialConnections() {
                const npcIds = Object.keys(this.npcStats);
                
                npcIds.forEach(npcId => {
                    this.socialNetwork.connections.set(npcId, []);
                    this.socialNetwork.influence.set(npcId, Math.random());
                    
                    // Create 2-4 random connections
                    const numConnections = Math.floor(Math.random() * 3) + 2;
                    for (let i = 0; i < numConnections; i++) {
                        const otherNpc = npcIds[Math.floor(Math.random() * npcIds.length)];
                        if (otherNpc !== npcId && !this.socialNetwork.connections.get(npcId).includes(otherNpc)) {
                            this.socialNetwork.connections.get(npcId).push(otherNpc);
                            this.socialNetwork.connections.get(otherNpc).push(npcId);
                        }
                    }
                });
            },

            // Time Management System
            initializeTimeManagement() {
                this.timeManagement = {
                    appointments: [],
                    deadlines: [],
                    recurring: [],
                    priorities: new Map(),
                    timeBlocks: []
                };
            },

            scheduleAppointment(time, location, description, priority = 'medium') {
                this.timeManagement.appointments.push({
                    time: time,
                    location: location,
                    description: description,
                    priority: priority,
                    completed: false
                });
                
                this.outputText(`Appointment scheduled: ${description} at ${time}`, 'cyan');
            },

            checkDeadlines() {
                const now = this.state.time;
                const overdue = this.timeManagement.deadlines.filter(deadline => 
                    deadline.time < now && !deadline.completed
                );
                
                if (overdue.length > 0) {
                    this.outputText(`*** DEADLINE ALERT ***`, 'header');
                    overdue.forEach(deadline => {
                        this.outputText(`OVERDUE: ${deadline.description}`, 'red');
                    });
                }
            },

            // Skill Tree System
            initializeSkillTrees() {
                this.skillTrees = {
                    investigation: {
                        'Basic Detective Work': { cost: 0, unlocked: true, children: ['Advanced Deduction', 'Evidence Analysis'] },
                        'Advanced Deduction': { cost: 5, unlocked: false, children: ['Master Detective', 'Psychological Profiling'] },
                        'Evidence Analysis': { cost: 5, unlocked: false, children: ['Forensic Expert', 'Crime Scene Reconstruction'] },
                        'Master Detective': { cost: 15, unlocked: false, children: [] },
                        'Psychological Profiling': { cost: 15, unlocked: false, children: [] },
                        'Forensic Expert': { cost: 15, unlocked: false, children: [] },
                        'Crime Scene Reconstruction': { cost: 15, unlocked: false, children: [] }
                    },
                    combat: {
                        'Basic Self Defense': { cost: 0, unlocked: true, children: ['Martial Arts', 'Weapon Training'] },
                        'Martial Arts': { cost: 5, unlocked: false, children: ['Combat Master', 'Stealth Combat'] },
                        'Weapon Training': { cost: 5, unlocked: false, children: ['Weapon Master', 'Tactical Combat'] },
                        'Combat Master': { cost: 15, unlocked: false, children: [] },
                        'Stealth Combat': { cost: 15, unlocked: false, children: [] },
                        'Weapon Master': { cost: 15, unlocked: false, children: [] },
                        'Tactical Combat': { cost: 15, unlocked: false, children: [] }
                    },
                    social: {
                        'Basic Communication': { cost: 0, unlocked: true, children: ['Persuasion', 'Intimidation'] },
                        'Persuasion': { cost: 5, unlocked: false, children: ['Master Negotiator', 'Charisma'] },
                        'Intimidation': { cost: 5, unlocked: false, children: ['Fear Master', 'Authority'] },
                        'Master Negotiator': { cost: 15, unlocked: false, children: [] },
                        'Charisma': { cost: 15, unlocked: false, children: [] },
                        'Fear Master': { cost: 15, unlocked: false, children: [] },
                        'Authority': { cost: 15, unlocked: false, children: [] }
                    }
                };
            },

            // Multi-Step Puzzle Chains
            initializePuzzleChains() {
                this.puzzleChains = {
                    active: [],
                    completed: [],
                    templates: [
                        {
                            name: "The Code Breaker",
                            steps: [
                                { type: "cipher", difficulty: "easy", reward: "clue1" },
                                { type: "pattern", difficulty: "medium", reward: "clue2" },
                                { type: "logic", difficulty: "hard", reward: "final_answer" }
                            ],
                            finalReward: "master_code_breaker"
                        },
                        {
                            name: "The Evidence Trail",
                            steps: [
                                { type: "observation", difficulty: "easy", reward: "location1" },
                                { type: "deduction", difficulty: "medium", reward: "location2" },
                                { type: "investigation", difficulty: "hard", reward: "location3" },
                                { type: "confrontation", difficulty: "extreme", reward: "truth" }
                            ],
                            finalReward: "master_investigator"
                        }
                    ]
                };
            },

            startPuzzleChain(chainId) {
                const chain = this.puzzleChains.templates[chainId];
                if (!chain) return;
                
                const activeChain = {
                    id: Date.now(),
                    template: chain,
                    currentStep: 0,
                    progress: 0,
                    rewards: []
                };
                
                this.puzzleChains.active.push(activeChain);
                this.outputText(`*** PUZZLE CHAIN STARTED ***`, 'header');
                this.outputText(`Chain: ${chain.name}`, 'cyan');
                this.outputText(`Steps: ${chain.steps.length}`, 'yellow');
                this.outputText(`Use 'puzzle chain' to continue`, 'grey');
            },

            // Advanced Combat System
            initializeCombatSystem() {
                this.combatSystem = {
                    active: false,
                    participants: [],
                    currentTurn: 0,
                    battlefield: null,
                    tactics: {
                        aggressive: { damage: 1.2, accuracy: 0.8, defense: 0.7 },
                        defensive: { damage: 0.8, accuracy: 0.9, defense: 1.3 },
                        balanced: { damage: 1.0, accuracy: 1.0, defense: 1.0 },
                        stealth: { damage: 1.1, accuracy: 1.1, defense: 0.9 }
                    },
                    specialMoves: {
                        'knockout_punch': { cost: 3, damage: 2.0, accuracy: 0.6, description: 'A powerful punch to the jaw' },
                        'dirty_fight': { cost: 2, damage: 1.5, accuracy: 0.8, description: 'Use the environment to your advantage' },
                        'intimidation': { cost: 1, damage: 0.5, accuracy: 1.0, description: 'Scare your opponent into submission' },
                        'feint': { cost: 1, damage: 0.8, accuracy: 1.2, description: 'Fake out your opponent' }
                    }
                };
            },

            startCombat(opponent) {
                this.combatSystem.active = true;
                this.combatSystem.participants = [
                    { name: 'You', health: this.state.health, maxHealth: 5, tactics: 'balanced' },
                    { name: opponent.name, health: opponent.health || 5, maxHealth: 5, tactics: 'aggressive' }
                ];
                this.combatSystem.currentTurn = 0;
                this.combatSystem.battlefield = this.getCurrentRoom().name;
                
                this.outputText("*** COMBAT BEGINS ***", 'header');
                this.outputText(`You're fighting ${opponent.name} in ${this.combatSystem.battlefield}!`, 'red');
                this.outputText("", 'normal');
                this.showCombatStatus();
                this.outputText("", 'normal');
                this.outputText("Combat commands: attack, defend, special, tactics, flee", 'yellow');
            },

            showCombatStatus() {
                this.combatSystem.participants.forEach((participant, index) => {
                    const healthBar = '█'.repeat(Math.floor(participant.health)) + '░'.repeat(participant.maxHealth - Math.floor(participant.health));
                    const color = index === 0 ? 'cyan' : 'red';
                    this.outputText(`${participant.name}: [${healthBar}] ${participant.health}/${participant.maxHealth}`, color);
                });
            },

            processCombatTurn(action, target = 1) {
                if (!this.combatSystem.active) return;
                
                const player = this.combatSystem.participants[0];
                const opponent = this.combatSystem.participants[1];
                
                if (action === 'attack') {
                    this.performAttack(player, opponent);
                } else if (action === 'defend') {
                    this.performDefend(player);
                } else if (action === 'special') {
                    this.showSpecialMoves();
                    return;
                } else if (action === 'tactics') {
                    this.showTactics();
                    return;
                } else if (action === 'flee') {
                    this.fleeCombat();
                    return;
                }
                
                // Check if combat is over
                if (player.health <= 0) {
                    this.endCombat(false);
                    return;
                }
                if (opponent.health <= 0) {
                    this.endCombat(true);
                    return;
                }
                
                // Opponent's turn
                this.performOpponentTurn(opponent, player);
                
                // Check again after opponent's turn
                if (player.health <= 0) {
                    this.endCombat(false);
                    return;
                }
                if (opponent.health <= 0) {
                    this.endCombat(true);
                    return;
                }
                
                this.showCombatStatus();
            },

            performAttack(attacker, target) {
                const tactics = this.combatSystem.tactics[attacker.tactics];
                const baseAccuracy = tactics.accuracy;
                const baseDamage = tactics.damage;
                
                const hitRoll = Math.random();
                const damageRoll = Math.random();
                
                if (hitRoll < baseAccuracy) {
                    const damage = Math.max(1, Math.floor(damageRoll * baseDamage * 3));
                    target.health = Math.max(0, target.health - damage);
                    this.outputText(`${attacker.name} hits ${target.name} for ${damage} damage!`, 'green');
                } else {
                    this.outputText(`${attacker.name} misses ${target.name}!`, 'yellow');
                }
            },

            performDefend(defender) {
                this.outputText(`${defender.name} takes a defensive stance!`, 'cyan');
                // Defensive bonus for next attack
                defender.defenseBonus = 0.5;
            },

            performOpponentTurn(opponent, player) {
                const actions = ['attack', 'defend'];
                const action = actions[Math.floor(Math.random() * actions.length)];
                
                if (action === 'attack') {
                    this.performAttack(opponent, player);
                } else {
                    this.performDefend(opponent);
                }
            },

            showSpecialMoves() {
                this.outputText("--- SPECIAL MOVES ---", 'header');
                Object.entries(this.combatSystem.specialMoves).forEach(([move, data]) => {
                    this.outputText(`${move}: ${data.description} (Cost: ${data.cost}, Damage: ${data.damage}x)`, 'cyan');
                });
                this.outputText("", 'normal');
                this.outputText("Use 'special [move_name]' to use a special move", 'yellow');
            },

            showTactics() {
                this.outputText("--- COMBAT TACTICS ---", 'header');
                Object.entries(this.combatSystem.tactics).forEach(([tactic, stats]) => {
                    this.outputText(`${tactic}: Damage ${stats.damage}x, Accuracy ${stats.accuracy}x, Defense ${stats.defense}x`, 'cyan');
                });
                this.outputText("", 'normal');
                this.outputText("Use 'tactics [tactic_name]' to change your fighting style", 'yellow');
            },

            fleeCombat() {
                this.outputText("You attempt to flee from combat...", 'yellow');
                if (Math.random() < 0.7) {
                    this.outputText("You successfully escape!", 'green');
                    this.endCombat(false, 'fled');
                } else {
                    this.outputText("You couldn't get away! The fight continues.", 'red');
                }
            },

            endCombat(victory, reason = '') {
                this.combatSystem.active = false;
                
                if (victory) {
                    this.outputText("*** VICTORY! ***", 'header');
                    this.outputText("You won the fight!", 'green');
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.combat += 1;
                    this.outputText("+2 Skill Points, +1 Combat Skill", 'green');
                } else {
                    this.outputText("*** DEFEAT! ***", 'header');
                    if (reason === 'fled') {
                        this.outputText("You fled from combat.", 'yellow');
                    } else {
                        this.outputText("You were defeated in combat.", 'red');
                        this.state.health = Math.max(1, this.state.health - 2);
                    }
                }
                
                this.combatSystem.participants = [];
                this.combatSystem.currentTurn = 0;
            },

            // Dynamic Storytelling System
            initializeStorytelling() {
                this.storytelling = {
                    storylines: new Map(),
                    plotPoints: [],
                    characterArcs: new Map(),
                    worldEvents: [],
                    narrativeThreads: [],
                    storySeeds: [
                        'corruption_scandal', 'missing_person', 'organized_crime', 'political_conspiracy',
                        'corporate_espionage', 'family_secret', 'old_wound', 'betrayal', 'redemption'
                    ]
                };
            },

            generateStoryline(seed) {
                const storyline = {
                    id: Date.now(),
                    seed: seed,
                    title: this.generateStoryTitle(seed),
                    description: this.generateStoryDescription(seed),
                    status: 'active',
                    progress: 0,
                    characters: [],
                    locations: [],
                    plotPoints: [],
                    rewards: this.generateStoryRewards(seed)
                };
                
                this.storytelling.storylines.set(storyline.id, storyline);
                this.outputText(`*** NEW STORYLINE DISCOVERED ***`, 'header');
                this.outputText(`Title: ${storyline.title}`, 'cyan');
                this.outputText(`Description: ${storyline.description}`, 'normal');
                this.outputText(`Use 'story' to explore this storyline`, 'yellow');
                
                return storyline;
            },

            generateStoryTitle(seed) {
                const titles = {
                    corruption_scandal: "The City Hall Conspiracy",
                    missing_person: "The Vanishing Act",
                    organized_crime: "The Family Business",
                    political_conspiracy: "The Power Play",
                    corporate_espionage: "The Corporate War",
                    family_secret: "The Family Secret",
                    old_wound: "The Old Wound",
                    betrayal: "The Betrayal",
                    redemption: "The Redemption"
                };
                return titles[seed] || "The Mystery";
            },

            generateStoryDescription(seed) {
                const descriptions = {
                    corruption_scandal: "A web of corruption reaches the highest levels of city government. Follow the money trail.",
                    missing_person: "Someone important has disappeared without a trace. Find them before it's too late.",
                    organized_crime: "The mob is making moves in the city. Discover their plans and stop them.",
                    political_conspiracy: "Politicians are playing dangerous games. Uncover the truth behind the lies.",
                    corporate_espionage: "Big business is fighting dirty. Expose their secrets and bring them down.",
                    family_secret: "A family's dark past is coming to light. Help them face the truth.",
                    old_wound: "An old case is reopened. The past won't stay buried forever.",
                    betrayal: "Someone you trusted has betrayed you. Find out why and make them pay.",
                    redemption: "A chance for redemption presents itself. Will you take it?"
                };
                return descriptions[seed] || "A mystery unfolds before you.";
            },

            generateStoryRewards(seed) {
                const rewards = {
                    corruption_scandal: { money: 1000, reputation: 50, items: ['evidence_file'] },
                    missing_person: { money: 800, reputation: 40, items: ['gratitude_letter'] },
                    organized_crime: { money: 1200, reputation: 60, items: ['mob_ledger'] },
                    political_conspiracy: { money: 1500, reputation: 80, items: ['political_dossier'] },
                    corporate_espionage: { money: 2000, reputation: 100, items: ['corporate_secrets'] },
                    family_secret: { money: 600, reputation: 30, items: ['family_heirloom'] },
                    old_wound: { money: 700, reputation: 35, items: ['closure'] },
                    betrayal: { money: 900, reputation: 45, items: ['justice'] },
                    redemption: { money: 500, reputation: 25, items: ['peace'] }
                };
                return rewards[seed] || { money: 500, reputation: 25, items: [] };
            },

            advanceStoryline(storylineId, action) {
                const storyline = this.storytelling.storylines.get(storylineId);
                if (!storyline) return;
                
                storyline.progress += 10;
                
                if (storyline.progress >= 100) {
                    this.completeStoryline(storyline);
                } else {
                    this.outputText(`Storyline progress: ${storyline.progress}%`, 'cyan');
                    this.outputText(`Action: ${action}`, 'yellow');
                }
            },

            completeStoryline(storyline) {
                storyline.status = 'completed';
                this.outputText(`*** STORYLINE COMPLETED ***`, 'header');
                this.outputText(`Title: ${storyline.title}`, 'cyan');
                this.outputText(`You have successfully resolved this mystery!`, 'green');
                
                // Apply rewards
                this.state.cash += storyline.rewards.money;
                this.state.gameState.reputation.police += storyline.rewards.reputation;
                storyline.rewards.items.forEach(item => {
                    this.state.inventory.push(item);
                });
                
                this.outputText(`Reward: $${storyline.rewards.money}, +${storyline.rewards.reputation} reputation`, 'green');
                this.outputText(`Items: ${storyline.rewards.items.join(', ')}`, 'cyan');
            },

            // Performance Optimization
            optimizePerformance() {
                // Debounce frequent operations
                this.debounceMap = new Map();
                
                // Cache frequently accessed data
                this.cache = {
                    roomDescriptions: new Map(),
                    npcDialogue: new Map(),
                    itemDescriptions: new Map()
                };
                
                // Batch DOM updates
                this.pendingUpdates = [];
                this.updateBatch = null;
            },

            debounce(key, func, delay = 300) {
                if (this.debounceMap.has(key)) {
                    clearTimeout(this.debounceMap.get(key));
                }
                
                const timeoutId = setTimeout(() => {
                    func();
                    this.debounceMap.delete(key);
                }, delay);
                
                this.debounceMap.set(key, timeoutId);
            },

            batchUpdate(updateFunc) {
                this.pendingUpdates.push(updateFunc);
                
                if (!this.updateBatch) {
                    this.updateBatch = requestAnimationFrame(() => {
                        this.pendingUpdates.forEach(update => update());
                        this.pendingUpdates = [];
                        this.updateBatch = null;
                    });
                }
            },

            // --- ADVANCED SYSTEMS ---
            
            handleMemory(args) {
                if (!args.length) {
                    this.outputText("Memory what? (test, train, recall, pattern)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You focus your memory on ${action}...`, 'cyan');
                
                // Memory mini-game
                this.startMemoryMiniGame(action);
                
                return 5;
            },

            startMemoryMiniGame(action) {
                this.outputText("--- MEMORY CHALLENGE ---", 'header');
                this.outputText(`Testing ${action} memory...`, 'yellow');
                this.outputText("", 'normal');
                
                if (action === 'pattern') {
                    this.startPatternMemoryGame();
                } else if (action === 'sequence') {
                    this.startSequenceMemoryGame();
                } else if (action === 'faces') {
                    this.startFacesMemoryGame();
                } else {
                    this.startGeneralMemoryGame();
                }
            },

            startPatternMemoryGame() {
                this.outputText("Remember this pattern:", 'yellow');
                const pattern = this.generateMemoryPattern();
                this.outputText(pattern, 'cyan');
                this.outputText("", 'normal');
                this.outputText("You have 10 seconds to memorize it...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now recreate the pattern:", 'yellow');
                    this.outputText("Type the pattern exactly as shown:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memoryPattern = pattern;
                }, 10000);
            },

            generateMemoryPattern() {
                const symbols = ['●', '○', '■', '□', '▲', '△', '◆', '◇'];
                let pattern = '';
                for (let i = 0; i < 8; i++) {
                    pattern += symbols[Math.floor(Math.random() * symbols.length)] + ' ';
                }
                return pattern.trim();
            },

            startSequenceMemoryGame() {
                this.outputText("Remember this sequence:", 'yellow');
                const sequence = this.generateMemorySequence();
                this.outputText(sequence, 'cyan');
                this.outputText("", 'normal');
                this.outputText("You have 15 seconds to memorize it...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now recreate the sequence:", 'yellow');
                    this.outputText("Type the sequence exactly as shown:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memorySequence = sequence;
                }, 15000);
            },

            generateMemorySequence() {
                const numbers = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
                let sequence = '';
                for (let i = 0; i < 6; i++) {
                    sequence += numbers[Math.floor(Math.random() * numbers.length)] + ' ';
                }
                return sequence.trim();
            },

            startFacesMemoryGame() {
                this.outputText("Remember these faces:", 'yellow');
                const faces = this.generateMemoryFaces();
                faces.forEach(face => {
                    this.outputText(face, 'cyan');
                });
                this.outputText("", 'normal');
                this.outputText("You have 20 seconds to memorize them...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now describe the faces:", 'yellow');
                    this.outputText("Type the descriptions exactly as shown:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memoryFaces = faces;
                }, 20000);
            },

            generateMemoryFaces() {
                const faces = [
                    "Man with brown hair, blue eyes, mustache",
                    "Woman with blonde hair, green eyes, glasses",
                    "Man with black hair, brown eyes, beard",
                    "Woman with red hair, blue eyes, freckles"
                ];
                return faces.slice(0, 3);
            },

            startGeneralMemoryGame() {
                this.outputText("Remember this information:", 'yellow');
                const info = this.generateMemoryInfo();
                this.outputText(info, 'cyan');
                this.outputText("", 'normal');
                this.outputText("You have 30 seconds to memorize it...", 'grey');
                
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("Now answer the question:", 'yellow');
                    this.outputText("Type your answer:", 'cyan');
                    
                    this.memoryMode = true;
                    this.memoryInfo = info;
                }, 30000);
            },

            generateMemoryInfo() {
                const info = [
                    "The suspect was last seen at 3:47 PM wearing a blue jacket and black pants.",
                    "The victim's wallet contained $47.50 and a photo of a young woman.",
                    "The crime scene had three different types of footprints and a broken window.",
                    "The witness described a tall man with a limp and a scar on his left hand."
                ];
                return info[Math.floor(Math.random() * info.length)];
            },

            handlePuzzle(args) {
                if (!args.length) {
                    this.outputText("Puzzle what? (logic, math, word, visual)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You begin solving a ${type} puzzle...`, 'cyan');
                
                // Puzzle mini-game
                this.startPuzzleMiniGame(type);
                
                return 10;
            },

            startPuzzleMiniGame(type) {
                this.outputText("--- PUZZLE CHALLENGE ---", 'header');
                this.outputText(`Solving ${type} puzzle...`, 'yellow');
                this.outputText("", 'normal');
                
                if (type === 'logic') {
                    this.startLogicPuzzle();
                } else if (type === 'math') {
                    this.startMathPuzzle();
                } else if (type === 'word') {
                    this.startWordPuzzle();
                } else if (type === 'visual') {
                    this.startVisualPuzzle();
                }
            },

            startLogicPuzzle() {
                this.outputText("Logic Puzzle:", 'yellow');
                this.outputText("Three suspects: A, B, and C", 'normal');
                this.outputText("A says: 'B is lying'", 'normal');
                this.outputText("B says: 'C is lying'", 'normal');
                this.outputText("C says: 'A is lying'", 'normal');
                this.outputText("", 'normal');
                this.outputText("Who is telling the truth?", 'cyan');
                this.outputText("Type your answer (A, B, or C):", 'yellow');
                
                this.puzzleMode = true;
                this.puzzleType = 'logic';
                this.puzzleAnswer = 'B';
            },

            startMathPuzzle() {
                this.outputText("Math Puzzle:", 'yellow');
                const a = Math.floor(Math.random() * 10) + 1;
                const b = Math.floor(Math.random() * 10) + 1;
                const c = a + b;
                this.outputText(`If a detective solves ${a} cases in the first month`, 'normal');
                this.outputText(`and ${b} cases in the second month`, 'normal');
                this.outputText(`how many cases did they solve in total?`, 'normal');
                this.outputText("", 'normal');
                this.outputText("Type your answer:", 'cyan');
                
                this.puzzleMode = true;
                this.puzzleType = 'math';
                this.puzzleAnswer = c.toString();
            },

            startWordPuzzle() {
                this.outputText("Word Puzzle:", 'yellow');
                this.outputText("Unscramble this word:", 'normal');
                const word = "DETECTIVE";
                const scrambled = this.scrambleWord(word);
                this.outputText(scrambled, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Type the unscrambled word:", 'yellow');
                
                this.puzzleMode = true;
                this.puzzleType = 'word';
                this.puzzleAnswer = word;
            },

            scrambleWord(word) {
                return word.split('').sort(() => Math.random() - 0.5).join('');
            },

            startVisualPuzzle() {
                this.outputText("Visual Puzzle:", 'yellow');
                this.outputText("Count the number of triangles in this pattern:", 'normal');
                this.outputText("▲▲▲", 'cyan');
                this.outputText("▲▲▲", 'cyan');
                this.outputText("▲▲▲", 'cyan');
                this.outputText("", 'normal');
                this.outputText("Type your answer:", 'yellow');
                
                this.puzzleMode = true;
                this.puzzleType = 'visual';
                this.puzzleAnswer = '9';
            },

            handleFaction(args) {
                if (!args.length) {
                    this.outputText("Faction what? (status, join, leave, info)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} faction operations...`, 'cyan');
                
                // Faction system
                this.handleFactionAction(action);
                
                return 5;
            },

            handleFactionAction(action) {
                this.outputText("--- FACTION STATUS ---", 'header');
                
                Object.entries(this.state.gameState.factionLoyalty).forEach(([faction, loyalty]) => {
                    const factionName = faction.charAt(0).toUpperCase() + faction.slice(1);
                    const bar = loyalty > 0 ? '█'.repeat(Math.min(loyalty, 10)) : '░'.repeat(Math.min(Math.abs(loyalty), 10));
                    const color = loyalty > 0 ? 'green' : loyalty < 0 ? 'red' : 'grey';
                    this.outputText(`${factionName}: [${bar}] (${loyalty})`, color);
                });
                
                this.outputText("", 'normal');
                this.outputText("Your faction loyalty affects available opportunities and NPC reactions.", 'yellow');
            },

            handleLoyalty(args) {
                if (!args.length) {
                    this.outputText("Loyalty what? (check, improve, betray)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} loyalty operations...`, 'cyan');
                
                // Loyalty system
                this.handleLoyaltyAction(action);
                
                return 5;
            },

            handleLoyaltyAction(action) {
                this.outputText("--- LOYALTY SYSTEM ---", 'header');
                this.outputText("Your loyalty to different factions affects your reputation and opportunities.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'faction' to check your current standing.", 'cyan');
            },

            handleCraft(args) {
                if (!args.length) {
                    this.outputText("Craft what? (item, tool, weapon, armor)");
                    return 0;
                }
                
                const item = args[0].toLowerCase();
                this.outputText(`You begin crafting ${item}...`, 'cyan');
                
                // Crafting mini-game
                this.startCraftingMiniGame(item);
                
                return 15;
            },

            startCraftingMiniGame(item) {
                this.outputText("--- CRAFTING ---", 'header');
                this.outputText(`Crafting ${item}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate crafting
                this.outputText("Gathering materials...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** CRAFTING SUCCESSFUL ***", 'green');
                    this.outputText(`${item} has been crafted!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 2;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+2 Skill Points, +1 Investigation Skill", 'green');
                    
                    // Add crafted item
                    this.state.inventory.push(item);
                    this.outputText(`${item} added to inventory.`, 'cyan');
                    
                }, 5000);
            },

            handleEnhance(args) {
                if (!args.length) {
                    this.outputText("Enhance what? (weapon, armor, tool)");
                    return 0;
                }
                
                const item = args[0].toLowerCase();
                this.outputText(`You begin enhancing ${item}...`, 'cyan');
                
                // Enhancement mini-game
                this.startEnhancementMiniGame(item);
                
                return 10;
            },

            startEnhancementMiniGame(item) {
                this.outputText("--- ENHANCEMENT ---", 'header');
                this.outputText(`Enhancing ${item}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate enhancement
                this.outputText("Applying improvements...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** ENHANCEMENT SUCCESSFUL ***", 'green');
                    this.outputText(`${item} has been enhanced!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+1 Skill Point, +1 Investigation Skill", 'green');
                    
                    // Apply enhancement
                    this.applyEnhancement(item);
                    
                }, 3000);
            },

            applyEnhancement(item) {
                this.outputText(`${item} is now more effective.`, 'cyan');
            },

            handleRomance(args) {
                if (!args.length) {
                    this.outputText("Romance what? (check, flirt, date, break)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} romance operations...`, 'cyan');
                
                // Romance system
                this.handleRomanceAction(action);
                
                return 5;
            },

            handleRomanceAction(action) {
                this.outputText("--- ROMANCE SYSTEM ---", 'header');
                this.outputText("Your romantic relationships affect your reputation and opportunities.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'flirt' to interact with potential romantic interests.", 'cyan');
            },

            handleFlirt(args) {
                if (!args.length) {
                    this.outputText("Flirt with who? (bartender, witness, informant)");
                    return 0;
                }
                
                const target = args[0].toLowerCase();
                this.outputText(`You begin flirting with ${target}...`, 'cyan');
                
                // Flirt mini-game
                this.startFlirtMiniGame(target);
                
                return 5;
            },

            startFlirtMiniGame(target) {
                this.outputText("--- FLIRTING ---", 'header');
                this.outputText(`Flirting with ${target}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate flirting
                this.outputText("Making your move...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** FLIRTING SUCCESSFUL ***", 'green');
                    this.outputText(`${target} is interested!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.persuasion += 1;
                    this.outputText("+1 Skill Point, +1 Persuasion Skill", 'green');
                    
                    // Apply romance effect
                    this.applyRomanceEffect(target);
                    
                }, 2000);
            },

            applyRomanceEffect(target) {
                this.outputText(`${target} is now more friendly towards you.`, 'cyan');
            },

            handleAchievement(args) {
                if (!args.length) {
                    this.outputText("Achievement what? (list, check, claim)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} achievement operations...`, 'cyan');
                
                // Achievement system
                this.handleAchievementAction(action);
                
                return 0;
            },

            handleAchievementAction(action) {
                this.outputText("--- ACHIEVEMENTS ---", 'header');
                
                if (this.state.gameState.achievements.length === 0) {
                    this.outputText("No achievements yet. Keep playing to unlock them!", 'grey');
                    return 0;
                }
                
                this.state.gameState.achievements.forEach((achievement, index) => {
                    this.outputText(`${index + 1}. ${achievement.name}`, 'cyan');
                    this.outputText(`   ${achievement.description}`, 'normal');
                    this.outputText(`   Status: ${achievement.completed ? 'Completed' : 'In Progress'}`, achievement.completed ? 'green' : 'yellow');
                    this.outputText("", 'normal');
                });
            },

            handleTrophy(args) {
                if (!args.length) {
                    this.outputText("Trophy what? (list, check, display)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} trophy operations...`, 'cyan');
                
                // Trophy system
                this.handleTrophyAction(action);
                
                return 0;
            },

            handleTrophyAction(action) {
                this.outputText("--- TROPHIES ---", 'header');
                
                if (this.state.gameState.trophies.length === 0) {
                    this.outputText("No trophies yet. Keep playing to earn them!", 'grey');
                    return 0;
                }
                
                this.state.gameState.trophies.forEach((trophy, index) => {
                    this.outputText(`${index + 1}. ${trophy.name}`, 'cyan');
                    this.outputText(`   ${trophy.description}`, 'normal');
                    this.outputText(`   Earned: ${trophy.date}`, 'green');
                    this.outputText("", 'normal');
                });
            },

            handleWeather(args) {
                if (!args.length) {
                    this.outputText("Weather what? (check, forecast, change)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} weather operations...`, 'cyan');
                
                // Weather system
                this.handleWeatherAction(action);
                
                return 0;
            },

            handleWeatherAction(action) {
                this.outputText("--- WEATHER SYSTEM ---", 'header');
                this.outputText(`Current weather: ${this.state.gameState.worldState.weather}`, 'cyan');
                this.outputText(`Temperature: ${this.state.gameState.worldState.temperature}`, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Weather affects NPC behavior and available activities.", 'yellow');
            },

            handleForecast(args) {
                if (!args.length) {
                    this.outputText("Forecast what? (weather, crime, activity)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You check the ${type} forecast...`, 'cyan');
                
                // Forecast system
                this.handleForecastAction(type);
                
                return 0;
            },

            handleForecastAction(type) {
                this.outputText("--- FORECAST ---", 'header');
                this.outputText(`${type.charAt(0).toUpperCase() + type.slice(1)} forecast:`, 'cyan');
                this.outputText("", 'normal');
                
                if (type === 'weather') {
                    this.outputText("Tomorrow: Foggy with a chance of rain", 'normal');
                    this.outputText("Day after: Clear skies expected", 'normal');
                } else if (type === 'crime') {
                    this.outputText("Tomorrow: High crime activity expected", 'normal');
                    this.outputText("Day after: Moderate crime levels", 'normal');
                } else if (type === 'activity') {
                    this.outputText("Tomorrow: Busy day for investigations", 'normal');
                    this.outputText("Day after: Quiet day, good for research", 'normal');
                }
            },

            handleEconomy(args) {
                if (!args.length) {
                    this.outputText("Economy what? (check, trade, invest)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} economy operations...`, 'cyan');
                
                // Economy system
                this.handleEconomyAction(action);
                
                return 0;
            },

            handleEconomyAction(action) {
                this.outputText("--- ECONOMY ---", 'header');
                this.outputText(`Current inflation: ${this.state.gameState.economy.inflation}x`, 'cyan');
                this.outputText(`Black market access: ${this.state.gameState.economy.blackMarket ? 'Yes' : 'No'}`, 'cyan');
                this.outputText("", 'normal');
                this.outputText("Economic conditions affect item prices and availability.", 'yellow');
            },

            handleTrade(args) {
                if (!args.length) {
                    this.outputText("Trade what? (items, information, favors)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You begin trading ${type}...`, 'cyan');
                
                // Trading mini-game
                this.startTradingMiniGame(type);
                
                return 10;
            },

            startTradingMiniGame(type) {
                this.outputText("--- TRADING ---", 'header');
                this.outputText(`Trading ${type}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate trading
                this.outputText("Negotiating terms...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** TRADING SUCCESSFUL ***", 'green');
                    this.outputText(`${type} trade completed!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.persuasion += 1;
                    this.outputText("+1 Skill Point, +1 Persuasion Skill", 'green');
                    
                    // Apply trade effect
                    this.applyTradeEffect(type);
                    
                }, 3000);
            },

            applyTradeEffect(type) {
                this.outputText(`You've gained valuable ${type}.`, 'cyan');
            },

            handleCombat(args) {
                if (!args.length) {
                    this.outputText("Combat what? (attack, defend, tactics, special)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} combat operations...`, 'cyan');
                
                // Combat system
                this.handleCombatAction(action);
                
                return 5;
            },

            handleCombatAction(action) {
                this.outputText("--- COMBAT SYSTEM ---", 'header');
                this.outputText("Your combat abilities affect your effectiveness in confrontations.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'tactics' to plan your approach.", 'cyan');
            },

            handleTactics(args) {
                if (!args.length) {
                    this.outputText("Tactics what? (plan, execute, review)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} tactical operations...`, 'cyan');
                
                // Tactics mini-game
                this.startTacticsMiniGame(action);
                
                return 10;
            },

            startTacticsMiniGame(action) {
                this.outputText("--- TACTICS ---", 'header');
                this.outputText(`Planning ${action}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate tactics
                this.outputText("Analyzing the situation...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** TACTICS SUCCESSFUL ***", 'green');
                    this.outputText(`${action} plan executed!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.combat += 1;
                    this.outputText("+1 Skill Point, +1 Combat Skill", 'green');
                    
                    // Apply tactics effect
                    this.applyTacticsEffect(action);
                    
                }, 2000);
            },

            applyTacticsEffect(action) {
                this.outputText(`Your ${action} approach is now more effective.`, 'cyan');
            },

            handleMystery(args) {
                if (!args.length) {
                    this.outputText("Mystery what? (solve, clue, suspect, timeline)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} mystery operations...`, 'cyan');
                
                // Mystery system
                this.handleMysteryAction(action);
                
                return 5;
            },

            handleMysteryAction(action) {
                this.outputText("--- MYSTERY SYSTEM ---", 'header');
                this.outputText("Your mystery-solving abilities affect your investigation effectiveness.", 'yellow');
                this.outputText("", 'normal');
                this.outputText("Use 'clue' to analyze evidence.", 'cyan');
            },

            handleClue(args) {
                if (!args.length) {
                    this.outputText("Clue what? (analyze, connect, verify)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} clue operations...`, 'cyan');
                
                // Clue mini-game
                this.startClueMiniGame(action);
                
                return 10;
            },

            startClueMiniGame(action) {
                this.outputText("--- CLUE ANALYSIS ---", 'header');
                this.outputText(`Analyzing ${action}...`, 'yellow');
                this.outputText("", 'normal');
                
                // Simulate clue analysis
                this.outputText("Examining evidence...", 'grey');
                setTimeout(() => {
                    this.outputText("", 'normal');
                    this.outputText("*** CLUE ANALYSIS SUCCESSFUL ***", 'green');
                    this.outputText(`${action} analysis complete!`, 'green');
                    
                    // Reward
                    this.state.gameState.skillPoints += 1;
                    this.state.gameState.skills.investigation += 1;
                    this.outputText("+1 Skill Point, +1 Investigation Skill", 'green');
                    
                    // Apply clue effect
                    this.applyClueEffect(action);
                    
                }, 3000);
            },

            applyClueEffect(action) {
                this.outputText(`You've gained new insights from ${action}.`, 'cyan');
            },

            // --- ADVANCED AI & PROCEDURAL HANDLERS ---
            
            handleAI(args) {
                if (!args.length) {
                    this.outputText("AI what? (init, status, analyze, predict)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You analyze AI systems for ${action}...`, 'cyan');
                
                if (action === 'init') {
                    this.initializeNPCAI();
                    this.outputText("AI systems initialized. NPCs now have advanced behavior patterns.", 'green');
                } else if (action === 'status') {
                    this.outputText("--- AI STATUS ---", 'header');
                    this.outputText(`Active NPCs: ${Object.keys(this.npcStats).length}`, 'cyan');
                    this.outputText(`AI Memory Entries: ${this.npcAI ? this.npcAI.memory.size : 0}`, 'cyan');
                    this.outputText(`Social Connections: ${this.socialNetwork ? this.socialNetwork.connections.size : 0}`, 'cyan');
                } else if (action === 'analyze') {
                    this.outputText("Analyzing NPC behavior patterns...", 'yellow');
                    this.outputText("AI systems are functioning optimally.", 'green');
                } else if (action === 'predict') {
                    this.outputText("Predicting future NPC actions...", 'yellow');
                    this.outputText("Patterns suggest increased activity in the downtown area.", 'cyan');
                }
                
                return 5;
            },

            handleNPC(args) {
                if (!args.length) {
                    this.outputText("NPC what? (list, info, track, analyze)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} NPC operations...`, 'cyan');
                
                if (action === 'list') {
                    this.outputText("--- ACTIVE NPCS ---", 'header');
                    Object.keys(this.npcStats).forEach(npcId => {
                        const npc = this.npcStats[npcId];
                        this.outputText(`${npcId}: ${npc.name} (${npc.role})`, 'cyan');
                    });
                } else if (action === 'info') {
                    if (args.length < 2) {
                        this.outputText("Info about which NPC?");
                        return 0;
                    }
                    const npcId = args[1];
                    if (this.npcStats[npcId]) {
                        const npc = this.npcStats[npcId];
                        this.outputText(`--- ${npc.name.toUpperCase()} ---`, 'header');
                        this.outputText(`Role: ${npc.role}`, 'cyan');
                        this.outputText(`Location: ${npc.location}`, 'cyan');
                        this.outputText(`Status: ${npc.status}`, 'cyan');
                        if (this.npcAI && this.npcAI.personalities.has(npcId)) {
                            const personality = this.npcAI.personalities.get(npcId);
                            this.outputText(`Personality: ${personality.primary}, ${personality.secondary}`, 'yellow');
                        }
                    } else {
                        this.outputText("NPC not found.", 'red');
                    }
                } else if (action === 'track') {
                    this.outputText("Tracking NPC movements...", 'yellow');
                    this.outputText("Several NPCs are on the move. Check individual locations.", 'cyan');
                } else if (action === 'analyze') {
                    this.outputText("Analyzing NPC behavior...", 'yellow');
                    this.outputText("Patterns detected: Increased suspicious activity.", 'cyan');
                }
                
                return 5;
            },

            handlePersonality(args) {
                if (!args.length) {
                    this.outputText("Personality what? (test, analyze, influence, read)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} personality analysis...`, 'cyan');
                
                if (action === 'test') {
                    this.outputText("--- PERSONALITY TEST ---", 'header');
                    this.outputText("Answer these questions to determine your detective personality:", 'yellow');
                    this.outputText("1. When investigating, do you prefer to work alone or with a partner?", 'normal');
                    this.outputText("2. How do you handle pressure situations?", 'normal');
                    this.outputText("3. What motivates you most in your work?", 'normal');
                } else if (action === 'analyze') {
                    this.outputText("Analyzing personality traits...", 'yellow');
                    this.outputText("Your detective style: Methodical and persistent", 'cyan');
                } else if (action === 'influence') {
                    this.outputText("Influencing NPC personalities...", 'yellow');
                    this.outputText("Your charisma affects how NPCs respond to you.", 'cyan');
                } else if (action === 'read') {
                    this.outputText("Reading personality cues...", 'yellow');
                    this.outputText("You can sense when someone is hiding something.", 'cyan');
                }
                
                return 5;
            },

            handleQuest(args) {
                if (!args.length) {
                    this.outputText("Quest what? (list, accept, complete, abandon, generate)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} quest operations...`, 'cyan');
                
                if (action === 'list') {
                    this.outputText("--- ACTIVE QUESTS ---", 'header');
                    if (this.state.gameState.sideQuests.length === 0) {
                        this.outputText("No active quests. Use 'quest generate' to create new ones.", 'grey');
                        return 0;
                    }
                    
                    this.state.gameState.sideQuests.forEach((quest, index) => {
                        this.outputText(`${index + 1}. ${quest.title}`, 'cyan');
                        this.outputText(`   Type: ${quest.type} | Reward: $${quest.reward}`, 'yellow');
                        this.outputText(`   Status: ${quest.status} | Progress: ${quest.progress}%`, 'green');
                        this.outputText("", 'normal');
                    });
                } else if (action === 'accept') {
                    if (args.length < 2) {
                        this.outputText("Accept which quest? (use quest number)");
                        return 0;
                    }
                    const questIndex = parseInt(args[1]) - 1;
                    if (questIndex >= 0 && questIndex < this.state.gameState.sideQuests.length) {
                        const quest = this.state.gameState.sideQuests[questIndex];
                        quest.status = 'active';
                        this.outputText(`Quest accepted: ${quest.title}`, 'green');
                    } else {
                        this.outputText("Invalid quest number.", 'red');
                    }
                } else if (action === 'complete') {
                    if (args.length < 2) {
                        this.outputText("Complete which quest? (use quest number)");
                        return 0;
                    }
                    const questIndex = parseInt(args[1]) - 1;
                    if (questIndex >= 0 && questIndex < this.state.gameState.sideQuests.length) {
                        const quest = this.state.gameState.sideQuests[questIndex];
                        quest.status = 'completed';
                        this.state.cash += quest.reward;
                        this.outputText(`Quest completed: ${quest.title}`, 'green');
                        this.outputText(`Reward: $${quest.reward}`, 'green');
                    } else {
                        this.outputText("Invalid quest number.", 'red');
                    }
                } else if (action === 'generate') {
                    this.generateProceduralQuest();
                }
                
                return 5;
            },

            handleGenerate(args) {
                if (!args.length) {
                    this.outputText("Generate what? (quest, npc, event, location, rumor)");
                    return 0;
                }
                
                const type = args[0].toLowerCase();
                this.outputText(`You generate ${type} content...`, 'cyan');
                
                if (type === 'quest') {
                    this.generateProceduralQuest();
                } else if (type === 'npc') {
                    this.outputText("Generating new NPC...", 'yellow');
                    this.outputText("A new character has appeared in the city.", 'cyan');
                } else if (type === 'event') {
                    this.outputText("Generating random event...", 'yellow');
                    this.outputText("Something interesting is happening downtown.", 'cyan');
                } else if (type === 'location') {
                    this.outputText("Generating new location...", 'yellow');
                    this.outputText("A previously unknown area has been discovered.", 'cyan');
                } else if (type === 'rumor') {
                    this.outputText("Generating rumor...", 'yellow');
                    this.outputText("Word on the street: Someone saw something suspicious last night.", 'cyan');
                }
                
                return 5;
            },

            handleStock(args) {
                if (!args.length) {
                    this.outputText("Stock what? (list, buy, sell, portfolio, news)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} stock operations...`, 'cyan');
                
                if (!this.stockMarket) {
                    this.initializeStockMarket();
                }
                
                if (action === 'list') {
                    this.outputText("--- STOCK MARKET ---", 'header');
                    this.stockMarket.companies.forEach(company => {
                        this.outputText(`${company.symbol}: $${company.price.toFixed(2)} (${company.name})`, 'cyan');
                    });
                } else if (action === 'buy') {
                    if (args.length < 3) {
                        this.outputText("Buy how many shares of which stock? (e.g., 'buy 10 BWI')");
                        return 0;
                    }
                    const shares = parseInt(args[1]);
                    const symbol = args[2].toUpperCase();
                    const company = this.stockMarket.companies.find(c => c.symbol === symbol);
                    if (company) {
                        const cost = shares * company.price;
                        if (this.state.cash >= cost) {
                            this.state.cash -= cost;
                            this.stockMarket.playerPortfolio[symbol] = (this.stockMarket.playerPortfolio[symbol] || 0) + shares;
                            this.outputText(`Bought ${shares} shares of ${symbol} for $${cost.toFixed(2)}`, 'green');
                        } else {
                            this.outputText("Insufficient funds.", 'red');
                        }
                    } else {
                        this.outputText("Stock not found.", 'red');
                    }
                } else if (action === 'sell') {
                    if (args.length < 3) {
                        this.outputText("Sell how many shares of which stock? (e.g., 'sell 5 BWI')");
                        return 0;
                    }
                    const shares = parseInt(args[1]);
                    const symbol = args[2].toUpperCase();
                    const company = this.stockMarket.companies.find(c => c.symbol === symbol);
                    if (company && this.stockMarket.playerPortfolio[symbol] >= shares) {
                        const value = shares * company.price;
                        this.state.cash += value;
                        this.stockMarket.playerPortfolio[symbol] -= shares;
                        this.outputText(`Sold ${shares} shares of ${symbol} for $${value.toFixed(2)}`, 'green');
                    } else {
                        this.outputText("Insufficient shares or stock not found.", 'red');
                    }
                } else if (action === 'portfolio') {
                    this.outputText("--- PORTFOLIO ---", 'header');
                    Object.entries(this.stockMarket.playerPortfolio).forEach(([symbol, shares]) => {
                        const company = this.stockMarket.companies.find(c => c.symbol === symbol);
                        const value = shares * company.price;
                        this.outputText(`${symbol}: ${shares} shares ($${value.toFixed(2)})`, 'cyan');
                    });
                } else if (action === 'news') {
                    this.outputText("--- MARKET NEWS ---", 'header');
                    this.stockMarket.marketEvents.forEach(event => {
                        this.outputText(event.text, 'normal');
                    });
                }
                
                return 5;
            },

            handleMarket(args) {
                this.handleStock(['list']);
                return 5;
            },

            handleInvest(args) {
                this.handleStock(['buy', ...args.slice(1)]);
                return 5;
            },

            handleSocial(args) {
                if (!args.length) {
                    this.outputText("Social what? (network, influence, rumor, gossip, connections)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} social operations...`, 'cyan');
                
                if (!this.socialNetwork) {
                    this.initializeSocialNetwork();
                }
                
                if (action === 'network') {
                    this.outputText("--- SOCIAL NETWORK ---", 'header');
                    this.socialNetwork.connections.forEach((connections, npcId) => {
                        this.outputText(`${npcId}: Connected to ${connections.length} people`, 'cyan');
                    });
                } else if (action === 'influence') {
                    this.outputText("--- INFLUENCE LEVELS ---", 'header');
                    this.socialNetwork.influence.forEach((level, npcId) => {
                        this.outputText(`${npcId}: ${(level * 100).toFixed(1)}% influence`, 'cyan');
                    });
                } else if (action === 'rumor') {
                    this.outputText("--- CURRENT RUMORS ---", 'header');
                    if (this.socialNetwork.rumors.length === 0) {
                        this.outputText("No rumors circulating.", 'grey');
                    } else {
                        this.socialNetwork.rumors.forEach(rumor => {
                            this.outputText(rumor, 'normal');
                        });
                    }
                } else if (action === 'gossip') {
                    this.outputText("--- GOSSIP ---", 'header');
                    if (this.socialNetwork.gossip.length === 0) {
                        this.outputText("No gossip to share.", 'grey');
                    } else {
                        this.socialNetwork.gossip.forEach(gossip => {
                            this.outputText(gossip, 'normal');
                        });
                    }
                } else if (action === 'connections') {
                    this.outputText("--- YOUR CONNECTIONS ---", 'header');
                    this.outputText("You have connections throughout the city.", 'cyan');
                    this.outputText("Use 'talk' to interact with NPCs and build relationships.", 'yellow');
                }
                
                return 5;
            },

            handleNetwork(args) {
                this.handleSocial(['network']);
                return 5;
            },

            handleRumor(args) {
                this.handleSocial(['rumor']);
                return 5;
            },

            handleSchedule(args) {
                if (!args.length) {
                    this.outputText("Schedule what? (list, add, check, clear)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} schedule operations...`, 'cyan');
                
                if (!this.timeManagement) {
                    this.initializeTimeManagement();
                }
                
                if (action === 'list') {
                    this.outputText("--- SCHEDULE ---", 'header');
                    if (this.timeManagement.appointments.length === 0) {
                        this.outputText("No appointments scheduled.", 'grey');
                    } else {
                        this.timeManagement.appointments.forEach((apt, index) => {
                            this.outputText(`${index + 1}. ${apt.description} at ${apt.time}`, 'cyan');
                        });
                    }
                } else if (action === 'add') {
                    if (args.length < 4) {
                        this.outputText("Add what? (e.g., 'schedule add 14:00 downtown meeting')");
                        return 0;
                    }
                    const time = args[1];
                    const location = args[2];
                    const description = args.slice(3).join(' ');
                    this.scheduleAppointment(time, location, description);
                } else if (action === 'check') {
                    this.checkDeadlines();
                } else if (action === 'clear') {
                    this.timeManagement.appointments = [];
                    this.outputText("Schedule cleared.", 'green');
                }
                
                return 5;
            },

            handleAppointment(args) {
                this.handleSchedule(['add', ...args]);
                return 5;
            },

            handleDeadline(args) {
                this.handleSchedule(['check']);
                return 5;
            },

            handleSkillTree(args) {
                if (!args.length) {
                    this.outputText("Skill tree what? (list, view, unlock, progress)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} skill tree operations...`, 'cyan');
                
                if (!this.skillTrees) {
                    this.initializeSkillTrees();
                }
                
                if (action === 'list') {
                    this.outputText("--- SKILL TREES ---", 'header');
                    Object.keys(this.skillTrees).forEach(tree => {
                        this.outputText(`${tree.charAt(0).toUpperCase() + tree.slice(1)} Skills`, 'cyan');
                    });
                } else if (action === 'view') {
                    if (args.length < 2) {
                        this.outputText("View which skill tree? (investigation, combat, social)");
                        return 0;
                    }
                    const tree = args[1].toLowerCase();
                    if (this.skillTrees[tree]) {
                        this.outputText(`--- ${tree.toUpperCase()} SKILL TREE ---`, 'header');
                        Object.entries(this.skillTrees[tree]).forEach(([skill, data]) => {
                            const status = data.unlocked ? 'UNLOCKED' : 'LOCKED';
                            const cost = data.cost > 0 ? ` (${data.cost} points)` : '';
                            this.outputText(`${skill}: ${status}${cost}`, data.unlocked ? 'green' : 'red');
                        });
                    } else {
                        this.outputText("Skill tree not found.", 'red');
                    }
                } else if (action === 'unlock') {
                    if (args.length < 2) {
                        this.outputText("Unlock which skill? (e.g., 'unlock Advanced Deduction')");
                        return 0;
                    }
                    const skillName = args.slice(1).join(' ');
                    this.outputText(`Attempting to unlock ${skillName}...`, 'yellow');
                    this.outputText("Skill unlocked! You feel more capable.", 'green');
                } else if (action === 'progress') {
                    this.outputText("--- SKILL PROGRESS ---", 'header');
                    this.outputText(`Available Skill Points: ${this.state.gameState.skillPoints}`, 'cyan');
                    this.outputText("Use 'unlock' to spend points on new abilities.", 'yellow');
                }
                
                return 5;
            },

            handleUnlock(args) {
                this.handleSkillTree(['unlock', ...args]);
                return 5;
            },

            handlePuzzleChain(args) {
                if (!args.length) {
                    this.outputText("Puzzle chain what? (list, start, continue, status)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} puzzle chain operations...`, 'cyan');
                
                if (!this.puzzleChains) {
                    this.initializePuzzleChains();
                }
                
                if (action === 'list') {
                    this.outputText("--- AVAILABLE PUZZLE CHAINS ---", 'header');
                    this.puzzleChains.templates.forEach((chain, index) => {
                        this.outputText(`${index + 1}. ${chain.name} (${chain.steps.length} steps)`, 'cyan');
                    });
                } else if (action === 'start') {
                    if (args.length < 2) {
                        this.outputText("Start which chain? (use chain number)");
                        return 0;
                    }
                    const chainId = parseInt(args[1]) - 1;
                    this.startPuzzleChain(chainId);
                } else if (action === 'continue') {
                    this.outputText("--- ACTIVE PUZZLE CHAINS ---", 'header');
                    if (this.puzzleChains.active.length === 0) {
                        this.outputText("No active puzzle chains.", 'grey');
                    } else {
                        this.puzzleChains.active.forEach((chain, index) => {
                            this.outputText(`${index + 1}. ${chain.template.name} (Step ${chain.currentStep + 1}/${chain.template.steps.length})`, 'cyan');
                        });
                    }
                } else if (action === 'status') {
                    this.outputText("--- PUZZLE CHAIN STATUS ---", 'header');
                    this.outputText(`Active: ${this.puzzleChains.active.length}`, 'cyan');
                    this.outputText(`Completed: ${this.puzzleChains.completed.length}`, 'green');
                }
                
                return 5;
            },

            handleChain(args) {
                this.handlePuzzleChain(['continue']);
                return 5;
            },

            handleOptimize(args) {
                this.outputText("Optimizing game performance...", 'yellow');
                this.optimizePerformance();
                this.outputText("Performance optimizations applied.", 'green');
                return 5;
            },

            handlePerformance(args) {
                this.handleOptimize([]);
                return 5;
            },

            // --- ADVANCED COMBAT & STORYTELLING HANDLERS ---
            
            handleCombat(args) {
                if (!this.combatSystem) {
                    this.initializeCombatSystem();
                }
                
                if (!args.length) {
                    this.outputText("Combat what? (start, status, end, help)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} combat operations...`, 'cyan');
                
                if (action === 'start') {
                    if (args.length < 2) {
                        this.outputText("Start combat with who? (e.g., 'combat start thug')");
                        return 0;
                    }
                    const opponentName = args.slice(1).join(' ');
                    const opponent = { name: opponentName, health: 5 };
                    this.startCombat(opponent);
                } else if (action === 'status') {
                    if (this.combatSystem.active) {
                        this.showCombatStatus();
                    } else {
                        this.outputText("No active combat.", 'grey');
                    }
                } else if (action === 'end') {
                    if (this.combatSystem.active) {
                        this.endCombat(false, 'ended');
                    } else {
                        this.outputText("No active combat to end.", 'grey');
                    }
                } else if (action === 'help') {
                    this.outputText("--- COMBAT HELP ---", 'header');
                    this.outputText("Commands: attack, defend, special, tactics, flee", 'cyan');
                    this.outputText("Special moves: knockout_punch, dirty_fight, intimidation, feint", 'yellow');
                    this.outputText("Tactics: aggressive, defensive, balanced, stealth", 'yellow');
                }
                
                return 5;
            },

            handleAttack(args) {
                if (!this.combatSystem || !this.combatSystem.active) {
                    this.outputText("You're not in combat!", 'red');
                    return 0;
                }
                
                this.processCombatTurn('attack');
                return 5;
            },

            handleDefend(args) {
                if (!this.combatSystem || !this.combatSystem.active) {
                    this.outputText("You're not in combat!", 'red');
                    return 0;
                }
                
                this.processCombatTurn('defend');
                return 5;
            },

            handleFlee(args) {
                if (!this.combatSystem || !this.combatSystem.active) {
                    this.outputText("You're not in combat!", 'red');
                    return 0;
                }
                
                this.processCombatTurn('flee');
                return 5;
            },

            handleSpecial(args) {
                if (!this.combatSystem || !this.combatSystem.active) {
                    this.outputText("You're not in combat!", 'red');
                    return 0;
                }
                
                if (!args.length) {
                    this.showSpecialMoves();
                    return 0;
                }
                
                const move = args[0].toLowerCase();
                if (this.combatSystem.specialMoves[move]) {
                    this.outputText(`You use ${move}!`, 'cyan');
                    // Implement special move logic here
                    this.processCombatTurn('special', move);
                } else {
                    this.outputText("Unknown special move. Use 'special' to see available moves.", 'red');
                }
                
                return 5;
            },

            handleTactics(args) {
                if (!this.combatSystem) {
                    this.initializeCombatSystem();
                }
                
                if (!args.length) {
                    this.showTactics();
                    return 0;
                }
                
                const tactic = args[0].toLowerCase();
                if (this.combatSystem.tactics[tactic]) {
                    this.combatSystem.participants[0].tactics = tactic;
                    this.outputText(`You switch to ${tactic} tactics!`, 'green');
                } else {
                    this.outputText("Unknown tactic. Use 'tactics' to see available tactics.", 'red');
                }
                
                return 5;
            },

            handleStory(args) {
                if (!this.storytelling) {
                    this.initializeStorytelling();
                }
                
                if (!args.length) {
                    this.outputText("Story what? (list, start, continue, complete, generate)");
                    return 0;
                }
                
                const action = args[0].toLowerCase();
                this.outputText(`You ${action} story operations...`, 'cyan');
                
                if (action === 'list') {
                    this.outputText("--- ACTIVE STORYLINES ---", 'header');
                    if (this.storytelling.storylines.size === 0) {
                        this.outputText("No active storylines. Use 'story generate' to create one.", 'grey');
                        return 0;
                    }
                    
                    this.storytelling.storylines.forEach((storyline, id) => {
                        this.outputText(`${id}. ${storyline.title}`, 'cyan');
                        this.outputText(`   Progress: ${storyline.progress}% | Status: ${storyline.status}`, 'yellow');
                        this.outputText(`   ${storyline.description}`, 'normal');
                        this.outputText("", 'normal');
                    });
                } else if (action === 'start') {
                    if (args.length < 2) {
                        this.outputText("Start which storyline? (use storyline number)");
                        return 0;
                    }
                    const storylineId = parseInt(args[1]);
                    const storyline = this.storytelling.storylines.get(storylineId);
                    if (storyline) {
                        this.outputText(`Starting storyline: ${storyline.title}`, 'green');
                        this.outputText(`Description: ${storyline.description}`, 'normal');
                    } else {
                        this.outputText("Storyline not found.", 'red');
                    }
                } else if (action === 'continue') {
                    if (args.length < 3) {
                        this.outputText("Continue which storyline with what action? (e.g., 'story continue 1 investigate')");
                        return 0;
                    }
                    const storylineId = parseInt(args[1]);
                    const action = args.slice(2).join(' ');
                    this.advanceStoryline(storylineId, action);
                } else if (action === 'complete') {
                    if (args.length < 2) {
                        this.outputText("Complete which storyline? (use storyline number)");
                        return 0;
                    }
                    const storylineId = parseInt(args[1]);
                    const storyline = this.storytelling.storylines.get(storylineId);
                    if (storyline) {
                        this.completeStoryline(storyline);
                    } else {
                        this.outputText("Storyline not found.", 'red');
                    }
                } else if (action === 'generate') {
                    const seed = this.storytelling.storySeeds[Math.floor(Math.random() * this.storytelling.storySeeds.length)];
                    this.generateStoryline(seed);
                }
                
                return 5;
            },
            
            // --- MISSING COMMAND HANDLERS ---
            
            handleSmoke(args) {
                if (this.state.inventory.includes('cigarettes')) {
                    this.state.inventory = this.state.inventory.filter(item => item !== 'cigarettes');
                    const thoughts = [
                        "The smoke curls in the humid air, each wisp a ghost of a bad decision.",
                        "You take a long drag. It doesn't solve anything, but for a second, it feels like it might.",
                        "Through the haze, you think of her. A memory best left in the ashtray of the past."
                    ];
                    this.outputText(thoughts[Math.floor(Math.random() * thoughts.length)], 'grey');
                    this.state.gameState.suspicionLevel += 1;
                    return 5;
                } else {
                    this.outputText("You're all out of smokes.");
                    return 1;
                }
            },
            
            handleDrink(args) {
                if (this.state.inventory.includes('whiskey')) {
                    this.state.inventory = this.state.inventory.filter(item => item !== 'whiskey');
                    this.outputText("You take a swig of whiskey. It burns, but it's a familiar fire.", 'grey');
                    if (this.state.gameState.stressLevel > 0) {
                        this.outputText("Your nerves feel a little steadier.", 'green');
                        this.state.gameState.stressLevel -= 1;
                    }
                    return 3;
                } else {
                    this.outputText("The bottle's dry.");
                    return 1;
                }
            },
            
            handleGamble(args) {
                const room = this.getCurrentRoom();
                if (room.name !== "Lucky Strike Casino") {
                    this.outputText("This is no place to gamble.");
                    return 1;
                }
                
                try {
                    const bet = parseInt(args[0]);
                    if (bet <= 0) {
                        this.outputText("You gotta bet something, pal.");
                        return 1;
                    }
                    if (this.state.cash >= bet) {
                        this.outputText(`You put $${bet} on the table and roll the dice...`);
                        this.spendMoney(bet, "gambling bet");
                        const { result } = this.attributeCheck("luck", 13);
                        if (result.includes("success")) {
                            const winnings = bet * 2;
                            this.outputText(`The dice come up in your favor! You win $${winnings}.`, 'green');
                            this.spendMoney(-winnings, "gambling winnings");
                        } else {
                            this.outputText("The house always wins. You lose your bet.", 'fail');
                        }
                        return 15;
                    } else {
                        this.outputText("You don't have enough cash for that bet.");
                        return 2;
                    }
                } catch (e) {
                    this.outputText("How much do you want to bet? (e.g., 'gamble 20')");
                    return 1;
                }
            },
            
            handleContracts(args) {
                const room = this.getCurrentRoom();
                if (room.name !== "The Bar") {
                    this.outputText("You need to be at the bar to see the contracts board.");
                    return 1;
                }
                
                this.outputText("--- AVAILABLE CONTRACTS ---", 'header');
                this.state.contracts.forEach((contract, index) => {
                    if (!contract.completed) {
                        this.outputText(`${index + 1}. ${contract.type}: ${contract.description}`);
                        this.outputText(`   Payout: $${contract.payout} | Location: ${contract.target_location}`);
                    }
                });
                this.outputText("Type 'accept <number>' to take a contract.", 'cyan');
                return 0;
            },
            
            handleAcceptContract(args) {
                try {
                    const contractNum = parseInt(args[0]) - 1;
                    if (contractNum >= 0 && contractNum < this.state.contracts.length) {
                        const contract = this.state.contracts[contractNum];
                        if (!contract.completed) {
                            contract.completed = true;
                            this.state.activeContracts.push(contract);
                            this.outputText(`You accept the ${contract.type} contract.`, 'green');
                            this.outputText(`Go to ${contract.target_location} and type 'work contract' to complete it.`);
                            return 2;
                        } else {
                            this.outputText("That contract is already completed.");
                            return 1;
                        }
                    } else {
                        this.outputText("Invalid contract number.");
                        return 1;
                    }
                } catch (e) {
                    this.outputText("Usage: accept <number>");
                    return 1;
                }
            },
            
            handleWorkContract(args) {
                if (this.state.activeContracts.length === 0) {
                    this.outputText("You don't have any active contracts.");
                    return 1;
                }
                
                const contract = this.state.activeContracts[0];
                const room = this.getCurrentRoom();
                const roomName = room.name.toLowerCase();
                
                if (roomName.includes(contract.target_location.toLowerCase())) {
                    this.outputText(`You complete the ${contract.type} contract.`, 'green');
                    this.spendMoney(-contract.payout, "contract completion");
                    this.outputText(`You earn $${contract.payout}.`);
                    
                    // Story impact
                    if (contract.storyImpact) {
                        this.state.gameState.sideQuests[contract.storyImpact].completed = true;
                        this.state.gameState.blackwoodCase.trustLevel += contract.trustReward;
                        this.outputText(`Your reputation grows. Trust level: ${this.state.gameState.blackwoodCase.trustLevel}`, 'cyan');
                        
                        // Add story-specific consequences
                        if (contract.storyImpact === "missingGirl") {
                            this.outputText("Sarah Chen's family is grateful. They might have information about the Blackwood case.", 'green');
                            this.state.journal.push("Found Sarah Chen. Her family mentioned seeing suspicious activity at the Blackwood estate.");
                        } else if (contract.storyImpact === "corruptCop") {
                            this.outputText("Detective Morrison is now your enemy, but you've gained leverage.", 'warning');
                            this.state.journal.push("Exposed Detective Morrison's corruption. He might know something about the Blackwood case.");
                        } else if (contract.storyImpact === "gamblingDebt") {
                            this.outputText("Big Tony owes you a favor. He has connections.", 'green');
                            this.state.journal.push("Helped Big Tony. He mentioned seeing someone matching Blackwood's description at the casino.");
                        } else if (contract.storyImpact === "blackmailCase") {
                            this.outputText("The mayor is in your debt. Political connections could be useful.", 'green');
                            this.state.journal.push("Solved the blackmail case. The mayor might have information about Blackwood's business dealings.");
                        }
                    }
                    
                    this.state.activeContracts.shift();
                    return 30;
                } else {
                    this.outputText(`You need to be at ${contract.target_location} to work this contract.`);
                    return 1;
                }
            },
            
            handleBuy(args) {
                const room = this.getCurrentRoom();
                if (room.name === "Pawn Shop") {
                    const items = ["cigarettes", "crowbar", "flashlight"];
                    const costs = { "cigarettes": 5, "crowbar": 25, "flashlight": 15 };
                    
                    const itemName = this.findTarget(args, items);
                    if (itemName && costs[itemName]) {
                        // Check if Izzy is present
                        const isIzzyPresent = room.npcs && room.npcs["izzy"];

                        if (isIzzyPresent) {
                            // Normal purchase with Izzy present
                        if (this.state.cash >= costs[itemName]) {
                                this.spendMoney(costs[itemName], itemName);
                            this.state.inventory.push(itemName);
                                this.outputText(`Izzy rings you up. You buy ${itemName} for $${costs[itemName]}.`, 'green');
                                // Improve relationship with Izzy
                                if (this.state.gameState.npcRelationships["izzy"]) {
                                    this.state.gameState.npcRelationships["izzy"].gratitude += 1;
                                }
                            return 2;
                        } else {
                                this.outputText(`Izzy shakes her head. "You need $${costs[itemName]} to buy ${itemName}, pal."`);
                            return 1;
                        }
                    } else {
                            // Izzy not present - could be stealing opportunity
                            this.outputText("Izzy's not here to ring you up. You could try to take it... but that might not be wise.", 'warning');
                            return 1;
                        }
                    } else {
                        this.outputText("Izzy's got: cigarettes ($5), crowbar ($25), flashlight ($15)");
                        return 1;
                    }
                } else {
                    this.outputText("There's nothing to buy here.");
                    return 1;
                }
            },

            handleBluff(args) {
                const room = this.getCurrentRoom();
                if (room.name !== "Pawn Shop") {
                    this.outputText("This isn't the place for bluffing.");
                    return 1;
                }

                const items = ["cigarettes", "crowbar", "flashlight"];
                const costs = { "cigarettes": 5, "crowbar": 25, "flashlight": 15 };

                const itemName = this.findTarget(args, items);
                if (!itemName || !costs[itemName]) {
                    this.outputText("What are you trying to bluff for? Available: cigarettes, crowbar, flashlight");
                    return 1;
                }

                // Check if Izzy is present
                const isIzzyPresent = room.npcs && room.npcs["izzy"];
                if (!isIzzyPresent) {
                    this.outputText("There's no one here to bluff.");
                    return 1;
                }

                // Attempt to bluff using Charisma
                this.outputText("You try to talk Izzy into giving you a better deal...", 'cyan');
                const { result } = this.attributeCheck("charisma", 14);

                if (result.includes("success")) {
                    // Success - get item at reduced price or free
                    const discountRoll = Math.random();
                    if (discountRoll > 0.7) {
                        // Free item!
                        this.state.inventory.push(itemName);
                        this.outputText(`Izzy chuckles. "Alright, you win. Take the ${itemName} - on the house."`, 'green');
                        this.state.gameState.npcRelationships["izzy"].gratitude += 2;
                    } else {
                        // Half price
                        const halfPrice = Math.floor(costs[itemName] / 2);
                        if (this.state.cash >= halfPrice) {
                            this.spendMoney(halfPrice, itemName + " (negotiated)");
                            this.state.inventory.push(itemName);
                            this.outputText(`Izzy grins. "Fine, you talked me down. $${halfPrice} for the ${itemName}."`, 'green');
                            this.state.gameState.npcRelationships["izzy"].gratitude += 1;
                        } else {
                            this.outputText(`"Half price is $${halfPrice}, pal. You got that much?"`);
                            return 1;
                        }
                    }
                    return 3;
                } else {
                    // Failure - worse deal or suspicion
                    this.outputText("Izzy narrows her eyes. 'Nice try, gumshoe. But I wasn't born yesterday.'", 'warning');
                    this.state.gameState.npcRelationships["izzy"].trust -= 1;
                    this.state.gameState.npcRelationships["izzy"].fear += 1;
                    // Slight increase in suspicion
                    this.state.gameState.suspicionLevel += 1;
                    return 2;
                }
            },

            handleSteal(args) {
                if (!args.length) {
                    this.outputText("Steal what?");
                    return 1;
                }

                const room = this.getCurrentRoom();
                const itemName = this.findTarget(args, room.items || []);
                if (!itemName) {
                    this.outputText(`You don't see ${args.join(' ')} here to steal.`);
                    return 1;
                }

                // Check if item is stealable
                const itemData = this.data.items[itemName];
                if (!itemData || !itemData.takeable) {
                    this.outputText(`You can't steal the ${itemName} - it's not something you can carry.`);
                    return 1;
                }

                // Check ownership and difficulty
                let difficulty = 12; // Base difficulty
                let owner = null;
                let witnesses = [];

                // Check for item ownership
                if (itemData.owned_by) {
                    owner = itemData.owned_by;
                    difficulty += 4; // Much harder to steal owned items
                }

                // Check for witnesses (NPCs in room)
                if (room.npcs) {
                    witnesses = Object.keys(room.npcs);
                    if (witnesses.length > 0) {
                        difficulty += witnesses.length * 2; // More witnesses = harder
                    }
                }

                // Special handling for shop items
                if (room.name === "Pawn Shop") {
                    const isIzzyPresent = room.npcs && room.npcs["izzy"];
                    if (isIzzyPresent) {
                        owner = "izzy";
                        difficulty = 16;
                    }
                }

                this.outputText(`You attempt to steal the ${itemName}...`, 'warning');

                const { result } = this.attributeCheck("dexterity", difficulty);

                if (result.includes("success")) {
                    // Success!
                    this.state.inventory.push(itemName);
                    room.items = room.items.filter(item => item !== itemName);

                    // Mark item as stolen
                    if (!this.state.gameState.stolenItems) {
                        this.state.gameState.stolenItems = [];
                    }
                    this.state.gameState.stolenItems.push({
                        item: itemName,
                        from: room.name,
                        owner: owner,
                        time: `${this.state.time.day}:${String(this.state.time.hour).padStart(2, '0')}`
                    });

                    this.outputText(`You successfully pocket the ${itemName}!`, 'green');

                    // Consequences based on witnesses/owner
                    if (witnesses.length > 0) {
                        this.state.gameState.suspicionLevel += Math.min(witnesses.length, 3);
                        this.outputText("Someone might have seen that...", 'warning');
                    }

                    if (owner) {
                        // Damage relationship with owner
                        if (this.state.gameState.npcRelationships[owner]) {
                            this.state.gameState.npcRelationships[owner].trust -= 3;
                            this.state.gameState.npcRelationships[owner].fear += 1;
                        }

                        // Add to journal
                        this.state.journal.push(`Stole ${itemName} from ${owner}. This might come back to haunt me.`);

                        // Higher suspicion for stealing from known owners
                        this.state.gameState.suspicionLevel += 2;
                    }

                    return 4;
                } else {
                    // Failure!
                    this.outputText("You fumble the attempt!", 'fail');

                    // Consequences
                    if (witnesses.length > 0) {
                        this.outputText("Someone noticed your attempt!", 'fail');
                        this.state.gameState.suspicionLevel += witnesses.length * 2;

                        // Witnesses might react
                        witnesses.forEach(npc => {
                            if (this.state.gameState.npcRelationships[npc]) {
                                this.state.gameState.npcRelationships[npc].trust -= 1;
                                this.state.gameState.npcRelationships[npc].fear += 1;
                            }
                        });

                        // Chance of being confronted
                        if (Math.random() > 0.6) {
                            this.outputText("They call for help! You should leave immediately.", 'fail');
                            this.state.gameState.suspicionLevel += 3;
                        }
                    } else if (owner) {
                        // Owner notices missing item later
                        this.state.gameState.suspicionLevel += 1;
                        this.outputText("The owner might notice this is missing soon...", 'warning');
                    }

                    return 3;
                }
            },

            handleStolen() {
                if (!this.state.gameState.stolenItems || this.state.gameState.stolenItems.length === 0) {
                    this.outputText("You haven't stolen anything... yet.", 'normal');
                    return 0;
                }

                this.outputText("--- ITEMS YOU'VE STOLEN ---", 'header');
                this.state.gameState.stolenItems.forEach((stolen, index) => {
                    const consequences = stolen.owner ?
                        ` (stolen from ${stolen.owner} - relationship damaged)` :
                        " (stolen anonymously)";
                    this.outputText(`${index + 1}. ${stolen.item} from ${stolen.from} at ${stolen.time}${consequences}`, 'warning');
                });

                // Calculate total suspicion from stolen items
                let totalSuspicionPenalty = 0;
                this.state.gameState.stolenItems.forEach(stolen => {
                    totalSuspicionPenalty += stolen.owner ? 3 : 1; // Higher penalty for owned items
                });

                this.outputText("", 'normal');
                this.outputText(`Total suspicion penalty from theft: +${totalSuspicionPenalty}`, 'warning');
                this.outputText("These items may have consequences if discovered...", 'warning');

                return 0;
            },
            
            handleBreakInto(args) {
                this.outputText("You attempt to break in...", 'warning');
                this.state.gameState.suspicionLevel += 3;
                const { result } = this.attributeCheck("strength", 15);
                if (result.includes("success")) {
                    this.outputText("You force your way in, but the noise draws attention.", 'green');
                    return 10;
                } else {
                    this.outputText("The door holds firm. You've made too much noise.", 'fail');
                    return 5;
                }
            },
            
            handlePickLock(args) {
                if (!this.state.inventory.includes('lockpicks')) {
                    this.outputText("You need lockpicks to pick locks.");
                    return 1;
                }
                
                this.outputText("You work the lock with delicate precision...", 'cyan');
                const { result } = this.attributeCheck("dexterity", 12);
                if (result.includes("success")) {
                    this.outputText("The lock clicks open.", 'green');
                    return 5;
                } else {
                    this.outputText("The lock resists your efforts.", 'fail');
                    return 3;
                }
            },
            
            handlePry(args) {
                if (!this.state.inventory.includes('crowbar')) {
                    this.outputText("You need a crowbar to pry things open.");
                    return 1;
                }
                
                this.outputText("You wedge the crowbar and apply leverage...", 'cyan');
                const { result } = this.attributeCheck("strength", 10);
                if (result.includes("success")) {
                    this.outputText("Whatever it was gives way with a satisfying creak.", 'green');
                    return 5;
                } else {
                    this.outputText("It's stuck fast.", 'fail');
                    return 3;
                }
            },
            
            // Trigger background events based on game actions
            triggerBackgroundEvent(triggerType) {
                if (!this.state.gameState.playerBackground || !this.state.gameState.playerBackground.events) {
                    return;
                }

                const background = this.state.gameState.playerBackground;
                const relevantEvents = background.events.filter(event => event.trigger === triggerType);

                for (const event of relevantEvents) {
                    if (Math.random() < event.chance) {
                        this.outputText("", 'normal');
                        this.outputText("--- BACKGROUND FLASHBACK ---", 'header');
                        this.outputText(this.wrapText(event.message), 'warning');
                        this.outputText("", 'normal');

                        if (event.consequences) {
                            event.consequences.call(this);
                        }

                        // Add to journal for reflection
                        this.state.journal.push(`Background event triggered: ${event.message.substring(0, 50)}...`);

                        // Only trigger one event per trigger type to avoid spam
                        break;
                    }
                }
            },

            // Enhanced NPC interactions based on background
            getBackgroundDialogue(npcName) {
                const background = this.state.gameState.playerBackground;
                if (!background || !background.specialInteractions) return null;

                return background.specialInteractions[npcName] || null;
            },
            
            // --- UI & OUTPUT ---
            async typeWriter(text, className = 'normal', speed = 20) {
                const p = document.createElement('p');
                const colorClasses = { header: 'text-amber-300 font-bold', cyan: 'text-cyan-400', green: 'text-green-400', fail: 'text-red-500', warning: 'text-yellow-500', grey: 'text-gray-500', bold: 'font-bold', normal: 'text-gray-300' };
                p.className = `game-response ${colorClasses[className] || colorClasses['normal']}`.replace('text-', 'color-'); // Simplified for style attr
                if (className === 'header') p.style.color = 'var(--accent-color)';
                else if (className === 'cyan') p.style.color = '#8be9fd';
                else if (className === 'green') p.style.color = '#50fa7b';
                else if (className === 'fail') p.style.color = '#ff5555';
                else if (className === 'warning') p.style.color = '#f1fa8c';
                else if (className === 'grey') p.style.color = '#6272a4';

                output.appendChild(p);

                for (let i = 0; i < text.length; i++) {
                    p.textContent += text.charAt(i);
                    output.scrollTop = output.scrollHeight;
                    await new Promise(resolve => setTimeout(resolve, speed));
                }
                 output.scrollTop = output.scrollHeight;
            },
            
            outputText(text, className = 'normal', indent = 0) {
                const p = document.createElement('div');
                if (className === 'header') p.style.color = 'var(--accent-color)';
                else if (className === 'cyan') p.style.color = '#8be9fd';
                else if (className === 'green') p.style.color = '#50fa7b';
                else if (className === 'fail') p.style.color = '#ff5555';
                else if (className === 'warning') p.style.color = '#f1fa8c';
                else if (className === 'grey') p.style.color = '#6272a4';
                p.style.paddingLeft = `${indent * 4}px`;
                // Use innerHTML if text contains HTML tags, otherwise use textContent
                if (text.includes('<span class="npc-name">')) {
                    p.innerHTML = text;
                } else {
                p.textContent = text;
                }
                output.appendChild(p);
                output.scrollTop = output.scrollHeight;
            },
            
            wrapText(text, indent = 0) {
                if (!text || typeof text !== 'string') {
                    return '';
                }
                const prefix = ' '.repeat(indent);
                const width = 80;
                let wrappedText = '';
                const lines = text.split('\n');
                for (const line of lines) {
                    let currentLine = prefix;
                    const words = line.split(' ');
                    for (const word of words) {
                        if ((currentLine + word).length > width) {
                            wrappedText += currentLine.trimEnd() + '\n';
                            currentLine = prefix + word + ' ';
                        } else {
                            currentLine += word + ' ';
                        }
                    }
                    wrappedText += currentLine.trimEnd() + '\n';
                }
                return wrappedText.trim();
            },

            getIntroText() {
                return this.wrapText(`The rain is a constant drumbeat on the city's tired streets. It's a rhythm you know well. Another case, another dame, another reason to wish you'd picked a different life. But you didn't. You're a gumshoe. In your office, a case file sits on your desk, its title mocking you in the dim light:\n\n'THE CASE OF THE GLOWING ORB'\n\n(Type 'help' for a list of commands)`);
            },
            
            posKey() {
                return `${this.state.playerPos.x},${this.state.playerPos.y},${this.state.playerPos.z}`;
            },

            // --- SAVE/LOAD (Database-backed) ---
            async saveGame(saveName = 'Auto Save') {
                try {
                    // Try to save with authentication first
                    const authToken = localStorage.getItem('authToken');
                    const saveData = {
                        gameType: 'noir',
                        saveName: saveName,
                        gameState: this.state,
                        variant: 'noir'
                    };

                    let response;
                    if (authToken && API_BASE_URL) {
                        // Authenticated save
                        response = await fetch(`${API_BASE_URL}/api/games/save`, {
                        method: 'POST',
                        headers: {
                                'Authorization': `Bearer ${authToken}`,
                                'Content-Type': 'application/json'
                            },
                            credentials: 'include',
                            body: JSON.stringify(saveData)
                        });
                    } else {
                        // Local storage fallback for demo/testing
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '{}');
                        saves[saveName] = {
                            gameState: this.state,
                            timestamp: new Date().toISOString(),
                            variant: 'noir'
                        };
                        localStorage.setItem('gumshoe_saves', JSON.stringify(saves));
                        this.outputText(`Game saved locally as "${saveName}"! (Demo mode)`, 'success');
                        return true;
                    }

                    if (response.ok) {
                        this.outputText(`Game saved as "${saveName}"!`, 'success');
                        return true;
                    } else {
                        // Fallback to local storage if server save fails
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '{}');
                        saves[saveName] = {
                            gameState: this.state,
                            timestamp: new Date().toISOString(),
                            variant: 'noir'
                        };
                        localStorage.setItem('gumshoe_saves', JSON.stringify(saves));
                        this.outputText(`Game saved locally as "${saveName}"! (Server unavailable)`, 'warning');
                        return true;
                    }
                } catch (error) {
                    console.error('Error saving game:', error);
                    // Fallback to local storage
                    try {
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '{}');
                        const saveName = args.length > 0 ? args.join(' ') : 'Auto Save';
                        saves[saveName] = {
                            gameState: this.state,
                            timestamp: new Date().toISOString(),
                            variant: 'noir'
                        };
                        localStorage.setItem('gumshoe_saves', JSON.stringify(saves));
                        this.outputText(`Game saved locally as "${saveName}"! (Network error)`, 'warning');
                        return true;
                    } catch (localError) {
                        this.outputText('Error saving game: ' + error.message, 'error');
                    return false;
                    }
                }
            },

            async loadGame(saveName) {
                try {
                    if (!API_BASE_URL) {
                        // Offline mode - load from localStorage
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '[]');
                        const save = saves.find(s => s.name === saveName);
                        
                        if (!save) {
                            this.outputText(`Save "${saveName}" not found.`, 'error');
                            return false;
                        }
                        
                        this.state = { ...this.state, ...save.gameState };
                        output.innerHTML = '';
                        this.updateMoneyDisplay();
                        this.outputText(`Game loaded: "${saveName}" (Offline mode)`, 'success');
                        this.outputText("--- GAME LOADED ---", 'header');
                        this.outputText(`Location: ${this.getCurrentRoom().name}`, 'cyan');
                        this.outputText(`Cash: $${this.state.cash}`, 'cyan');
                        this.outputText(`Health: ${this.state.health}/5`, 'cyan');
                        this.outputText("", 'normal');
                        this.handleLook([]);
                        this.showStatus();
                        input.disabled = false;
                        return true;
                    }
                    
                    const authToken = localStorage.getItem('authToken');
                    if (!authToken) {
                        this.outputText("You must be logged in to load games.", 'error');
                        return false;
                    }

                    const response = await fetch(`${API_BASE_URL}/api/games/load/noir/${encodeURIComponent(saveName)}`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        // Restore the full state, not just gameState
                        this.state = { ...this.state, ...data.gameState };
                        output.innerHTML = '';
                        this.updateMoneyDisplay(); // Update money display immediately
                        this.outputText(`Game loaded: "${saveName}"`, 'success');
                        this.outputText("--- GAME LOADED ---", 'header');
                        this.outputText(`Location: ${this.getCurrentRoom().name}`, 'cyan');
                        this.outputText(`Cash: $${this.state.cash}`, 'cyan');
                        this.outputText(`Health: ${this.state.health}/5`, 'cyan');
                        this.outputText("", 'normal');
                        this.handleLook([]);
                        this.showStatus();
                        input.disabled = false;
                        return true;
                    } else {
                        const error = await response.json();
                        this.outputText(`Load failed: ${error.message}`, 'error');
                        return false;
                    }
                } catch (error) {
                    this.outputText(`Load failed: ${error.message}`, 'error');
                    return false;
                }
            },

            async listSaves() {
                try {
                    if (!API_BASE_URL) {
                        // Offline mode - list from localStorage
                        const saves = JSON.parse(localStorage.getItem('gumshoe_saves') || '[]');
                        if (saves.length === 0) {
                            this.outputText("No saved games found. (Offline mode)", 'warning');
                            return;
                        }
                        
                        this.outputText("=== SAVED GAMES (Offline) ===", 'header');
                        saves.forEach(save => {
                            const date = new Date(save.timestamp).toLocaleString();
                            this.outputText(`• ${save.name} - ${date}`, 'cyan');
                        });
                        return;
                    }
                    
                    const authToken = localStorage.getItem('authToken');
                    if (!authToken) {
                        this.outputText("You must be logged in to list saves.", 'error');
                        return;
                    }

                    const response = await fetch(`${API_BASE_URL}/api/games/saves/noir`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (response.ok) {
                        const saves = await response.json();
                        this.outputText("--- YOUR SAVED GAMES ---", 'header');
                        if (saves.length === 0) {
                            this.outputText("No saved games found.", 'normal');
                        } else {
                            saves.forEach(save => {
                                const date = new Date(save.updated_at).toLocaleString();
                                this.outputText(`• ${save.save_name} (${date})`, 'cyan');
                            });
                        }
                        this.outputText("", 'normal');
                        this.outputText("Use 'load <save_name>' to load a game.", 'green');
                    } else {
                        const error = await response.json();
                        this.outputText(`Failed to list saves: ${error.message}`, 'error');
                    }
                } catch (error) {
                    this.outputText(`Failed to list saves: ${error.message}`, 'error');
                }
            },

            async deleteSave(saveName) {
                try {
                    const authToken = localStorage.getItem('authToken');
                    if (!authToken) {
                        this.outputText("You must be logged in to delete saves.", 'error');
                        return false;
                    }

                    const response = await fetch(`${API_BASE_URL}/api/games/delete/noir/${encodeURIComponent(saveName)}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        }
                    });

                    if (response.ok) {
                        this.outputText(`Save "${saveName}" deleted successfully.`, 'success');
                        return true;
                    } else {
                        const error = await response.json();
                        this.outputText(`Delete failed: ${error.message}`, 'error');
                        return false;
                    }
                } catch (error) {
                    this.outputText(`Delete failed: ${error.message}`, 'error');
                    return false;
                }
            },

            // Enhanced command handlers
            handleSave(args) {
                const saveName = args.length > 0 ? args.join(' ') : 'Auto Save';
                this.saveGame(saveName);
                return 0;
            },

            handleLoad(args) {
                if (!args.length) {
                    this.outputText("Load which save? Use 'saves' to see available saves.", 'error');
                    return 0;
                }
                const saveName = args.join(' ');
                this.loadGame(saveName);
                return 0;
            },

            handleSaves() {
                this.listSaves();
                return 0;
            },

            handleDeleteSave(args) {
                if (!args.length) {
                    this.outputText("Delete which save? Use 'saves' to see available saves.", 'error');
                    return 0;
                }
                const saveName = args.join(' ');
                this.deleteSave(saveName);
                return 0;
            },

            handleAttack(args) {
                if (!args.length) {
                    this.outputText("Attack what?");
                    return 0;
                }
                
                const room = this.getCurrentRoom();
                const targetName = this.findTarget(args, Object.keys(room.npcs || {}));
                
                if (!targetName) {
                    this.outputText(`You don't see ${args.join(' ')} here.`);
                    return 0;
                }
                
                // Combat system
                const playerStrength = this.state.attributes.strength;
                const targetStrength = Math.floor(Math.random() * 10) + 5; // NPC strength
                
                this.outputText(`You attack ${targetName}!`);
                
                if (playerStrength > targetStrength) {
                    this.outputText(`${targetName} is defeated! You gain experience.`);
                    this.state.gameState.experience = (this.state.gameState.experience || 0) + 10;
                    this.state.attributes.strength += 1;

                    // Trigger background event for combat success (military flashbacks)
                    this.triggerBackgroundEvent("combat_success");
                } else {
                    this.outputText(`${targetName} fights back! You take damage.`);
                    this.state.health -= 2;
                }
                
                if (this.state.health <= 0) {
                    this.outputText("You have been defeated!");
                    this.state.gameOver = true;
                }
                return 5;
            },

            handleEquip(args) {
                if (!args.length) {
                    this.outputText("Equip what?");
                    return 0;
                }
                
                const item = args.join(' ').toLowerCase();
                
                if (!this.state.inventory.includes(item)) {
                    this.outputText(`You don't have ${item}.`);
                    return 0;
                }
                
                // Check if item is a weapon by looking at game data
                const itemData = this.data.items[item];
                const isWeapon = itemData && (itemData.type === 'weapon' || itemData.damage || item.includes('gun') || item.includes('knife') || item.includes('bat') || item.includes('pipe') || item.includes('crowbar') || item.includes('pistol') || item.includes('revolver') || item.includes('blade') || item.includes('club'));
                
                if (isWeapon) {
                    this.state.equippedWeapon = item;
                    this.outputText(`You equip ${item}.`);
                } else {
                    this.outputText(`${item} is not a weapon.`);
                }
                return 0;
            },

            handleUnequip() {
                if (this.state.equippedWeapon) {
                    this.outputText(`You unequip ${this.state.equippedWeapon}.`);
                    this.state.equippedWeapon = null;
                } else {
                    this.outputText("You're not equipping anything.");
                }
                return 0;
            },

            handleGive(args) {
                if (args.length < 2) {
                    this.outputText("Usage: give <item> to <npc>");
                    return 0;
                }
                
                const itemIndex = args.indexOf('to');
                if (itemIndex === -1 || itemIndex === 0 || itemIndex === args.length - 1) {
                    this.outputText("Usage: give <item> to <npc>");
                    return 0;
                }
                
                const item = args.slice(0, itemIndex).join(' ').toLowerCase();
                const npc = args.slice(itemIndex + 1).join(' ').toLowerCase();
                
                if (!this.state.inventory.includes(item)) {
                    this.outputText(`You don't have ${item}.`);
                    return 0;
                }
                
                const room = this.getCurrentRoom();
                
                if (!room.npcs || !Object.keys(room.npcs).includes(npc)) {
                    this.outputText(`You don't see ${npc} here.`);
                    return 0;
                }
                
                // Remove item from inventory
                const itemIndex_inv = this.state.inventory.indexOf(item);
                this.state.inventory.splice(itemIndex_inv, 1);
                
                this.outputText(`You give ${item} to ${npc}.`);
                
                // NPC reactions based on item
                if (item === 'cash' && npc === 'bartender') {
                    this.outputText("The bartender nods appreciatively. 'Thanks, detective. Maybe I can help you with some information.'");
                    this.state.charisma += 1;
                } else if (item === 'whiskey' && npc === 'bartender') {
                    this.outputText("The bartender smiles. 'A man after my own heart. What can I tell you?'");
                } else {
                    this.outputText(`${npc} accepts the ${item} but doesn't seem particularly interested.`);
                }
                return 0;
            }
        };

        // --- GAME DATA (STATIC) ---
        game.data = {
            worldMap: {
                '0,0,0': { name: "Your Office", baseDesc: "Your dingy office on the third floor of a building that's seen better days. The whole place reeks of stale smoke, desperation, and the faint metallic tang of the radiator that's been clanking since '47. Dust motes dance in the single shaft of light that manages to pierce the grime-streaked window. A case file sits on your desk like a sleeping dragon: 'The Blackwood Diamond Affair'. The walls are papered with newspaper clippings, photographs of suspects, and a map of the city marked with red pins. Your chair creaks ominously as you sit, and the desk drawer sticks when you try to open it. This is where dreams come to die, but it's home.", items: ["case_file", "whiskey"], features: ["desk", "poster", "crack"], npcs: {"landlord": "Mrs. Kowalski, your perpetually angry landlord, is banging on the door demanding this month's rent. Again."}},
                '0,-1,0': { name: "Main Street - Office Front", baseDesc: "The rain-slicked street stretches before you like a ribbon of obsidian, reflecting the neon signs of the city in fractured, distorted patterns. Steam rises from a manhole cover like the breath of some sleeping giant beneath the streets. The air is thick with the smell of wet asphalt, exhaust fumes, and something else - something that makes your skin crawl. A newspaper stand shows headlines about the Blackwood suicide, the ink bleeding in the humidity. The streetlights buzz with an electric hum that seems to carry whispers of the city's secrets. This is where it all begins - and where it might all end.", items: ["newspaper"], features: ["manhole"], exitsOverride: {'d': [0, -1, -1]} },
                '0,-2,0': { name: "The Alley", baseDesc: "A dark alley reeking of garbage and broken dreams. A dumpster sits against the brick wall. Graffiti reads 'Blackwood was here'. A torn poster advertises 'PADFOOT: The Great Adventure' - some kind of fantasy game.", items: ["newspaper"], features: ["dumpster"]},
                '-1,-2,0': { name: "The Bar", baseDesc: "The bar is thick with smoke, a veil of mystery. A corkboard shows various jobs and missing person notices. A flickering neon sign reads 'Visit Neon City - Where the Future Lives!'", features: ["bar_counter"], npcs: {"bartender": "The bartender polishes a glass with a rag that's seen better days, his eyes scanning the room like a cop on patrol.", "regular": "A regular sits at the end of the bar, nursing a whiskey and staring into space like he's lost everything worth living for."}},
                '0,-3,0': { name: "Pawn Shop", baseDesc: "The pawn shop smells of old oil and secrets. The counter is cluttered with forgotten dreams.", items: [], features: ["pawn_counter"]},
                '0,-4,0': { name: "Warehouse District", baseDesc: "Dust motes dance in the single beam of light piercing the gloom of the warehouse. Crates are stacked to the ceiling. Blackwood Industries shipping labels are visible.", items: ["ledger"], features: ["crates", "barrels"]},
                '1,-4,0': { name: "The Docks", baseDesc: "The docks stretch into the darkness like the fingers of a drowning man, reaching for salvation that will never come. The air is thick with the smell of salt, decay, and something else - something that makes your blood run cold. Ships creak in the night like the bones of ancient leviathans, their hulls black against the starless sky. The dark water slaps against the rotting pylons with a rhythm that seems almost... intentional. A missing person poster for Sarah Chen is taped to a post, the paper flapping in the wind like a dying bird. The fog rolls in from the harbor, carrying with it whispers of the deep and secrets that should never see the light of day. This is where the city's soul goes to die.", features: ["pier", "ships"], npcs: {"dock_worker": "A burly dock worker unloads crates from a ship, his muscles straining under the weight. He looks like he could break you in half without breaking a sweat.", "fisherman": "An old fisherman sits on a crate, mending his nets with calloused hands. His eyes have seen too many storms."}},
                '1,-4,-1': { name: "XAI Lab", baseDesc: "This place is different. It smells of ozone and overclocked circuits. An otherworldly presence fills the air. Blackwood was an investor here.", items: ["grok_orb"], features: ["glowing_sign"]},
                '0,-1,-1': { name: "Sewer Entrance", baseDesc: "The sewers beneath the city. Water drips from corroded pipes. Rats watch you with intelligent eyes.", items: ["rusty_key"], features: ["manhole_cover"]},
                '2,-1,0': { name: "Lucky Strike Casino", baseDesc: "The Lucky Strike Casino - all chrome and broken promises. Card sharks and desperate gamblers fill the smoky interior. Big Tony runs the back room.", features: ["slot_machines", "card_tables"]},
                '1,-3,0': { name: "City Hall", baseDesc: "The imposing city hall building. The mayor's office is on the third floor. Security is tight after recent threats.", features: ["security_desk", "elevator"]},
                '2,-3,0': { name: "44th Precinct", baseDesc: "The 44th Precinct. Cops in rumpled suits shuffle papers and drink cold coffee. Detective Morrison's desk is in the back. The evidence room is locked.", features: ["evidence_room", "detective_desk"], npcs: {"desk_sergeant": "A grizzled desk sergeant types laboriously at an ancient typewriter, his fingers stained yellow from years of chain-smoking. He looks up at you with eyes that have seen too many bad endings.", "detective_morrison": "Detective Morrison sits at his desk, feet propped up, hat tilted back. He's the kind of cop who thinks the law is just another tool in his toolbox."}},
                '3,-2,0': { name: "Blackwood Estate", baseDesc: "The imposing Blackwood mansion. Mrs. Evelyn Blackwood lives here alone now. The garden is overgrown, and the house has an air of neglect.", items: ["blackwood_photo", "isabella_letter"], features: ["mansion_gate", "garden"], npcs: {"evelyn": "Mrs. Evelyn Blackwood sits in the parlor, her eyes red from crying. 'Please, find out what really happened to my husband.'"}},
                '3,-3,0': { name: "Blackwood Industries Office", baseDesc: "The corporate headquarters of Blackwood Industries. Marcus Blackwood's office is on the top floor. His business partner, Richard Sterling, now runs the company.", features: ["reception_desk", "elevator"], npcs: {"sterling": "Richard Sterling looks up from his desk. 'Marcus was troubled. The suicide didn't surprise me.'"}},
                '4,-2,0': { name: "The Velvet Lounge", baseDesc: "An upscale nightclub where the city's elite gather. This is where Marcus Blackwood met his mistress, Isabella Rose. The place reeks of money and secrets.", features: ["bar", "dance_floor"], npcs: {"isabella": "Isabella Rose sits alone at a corner table, nursing a drink. 'Marcus was a good man. He didn't kill himself.'"}},
                '4,-3,0': { name: "The Flophouse", baseDesc: "A rundown boarding house where Marcus Blackwood's estranged son, David, lives. The place smells of desperation and broken dreams.", items: ["marcus_note"], features: ["front_desk", "stairs"], npcs: {"david": "David Blackwood looks up from his cot. 'My father was a bastard. Good riddance.'"}},
            },
            items: {
                "case_file": {
                    desc: "A dog-eared manila folder that smells of desperation and cheap ink. 'Blackwood Diamond Affair' is scrawled across the front in your own handwriting. The edges are frayed from countless nights of pouring over these pages, each one a dead end that led you here. Inside: photographs of a man who looked like he carried the weight of the world, financial records that don't add up, and a single word circled in red: 'suicide?'",
                    takeable: true
                },
                // LORE ITEMS - Deep worldbuilding
                "police_gazette": {
                    desc: "A crumpled copy of the Police Gazette, its pages stained with coffee and desperation. The headlines scream of corruption and cover-ups: 'Detective Found Dead in Alley - Suicide or Murder?' 'Mayor's Office Denies Bribery Allegations' 'New Evidence in the Black Dahlia Case.' Between the lines, you can read the real story - a city drowning in its own lies, where justice is just another commodity to be bought and sold.",
                    takeable: true,
                    lore: true
                },
                "mob_ledger": {
                    desc: "A leather-bound ledger with pages that smell of blood and money. The entries are written in code, but you can make out names, dates, and amounts. 'Tony the Snake - $500 - Protection' 'Fat Louie - $1000 - Information' 'The Mayor - $5000 - Silence.' This isn't just a book of accounts - it's a map of the city's corruption, showing how every institution has been bought and paid for.",
                    takeable: true,
                    lore: true
                },
                "missing_persons_file": {
                    desc: "A thick file folder marked 'CONFIDENTIAL' in red ink. Inside are photographs of missing persons - young women, mostly, their faces frozen in time. Each photo is accompanied by a report: 'Last seen at the Blue Moon Club' 'Disappeared after meeting with unknown man' 'Body found in warehouse district.' The pattern is clear to anyone who knows how to read between the lines - someone is hunting in this city, and the police are looking the other way.",
                    takeable: true,
                    lore: true
                },
                "corrupt_cop_dossier": {
                    desc: "A manila envelope containing photographs and documents that would destroy careers. Pictures of police officers meeting with known criminals, receipts for expensive gifts, transcripts of phone calls that should never have been recorded. This is the kind of evidence that gets people killed, but it's also the kind that can bring down an entire system of corruption.",
                    takeable: true,
                    lore: true
                },
                "underground_newspaper": {
                    desc: "A mimeographed newsletter from the underground resistance, its pages crinkled and yellowed with age. The articles tell stories the mainstream press won't touch - police brutality, political assassinations, the systematic oppression of the working class. It's written in the passionate voice of people who have nothing left to lose, and it's a reminder that in this city of shadows, there are still those who fight for the truth.",
                    takeable: true,
                    lore: true
                },
                "old_case_file": {
                    desc: "A dusty case file from the archives, its edges worn smooth by countless hands. The case is marked 'CLOSED - UNSOLVED' but the evidence tells a different story. Witness statements that don't add up, evidence that mysteriously disappeared, suspects who were never properly questioned. This isn't just an old case - it's a blueprint for how justice fails in this city.",
                    takeable: true,
                    lore: true
                },
                "whistleblower_letter": {
                    desc: "A handwritten letter from someone who claims to be a former police officer. The writing is shaky, as if written by someone who's been through hell. 'They're all in on it,' it reads. 'The mayor, the chief, half the department. They've been running this city like their own private fiefdom for years. I tried to stop them, but they made me disappear. If you're reading this, you're already in danger.'",
                    takeable: true,
                    lore: true
                },
                "crime_scene_photos": {
                    desc: "A stack of crime scene photographs that were never supposed to see the light of day. The images are graphic and disturbing, showing evidence of systematic violence and cover-ups. Bodies arranged in ways that suggest ritual, evidence that was clearly planted, signs of a cover-up that goes all the way to the top. These photos could bring down the entire system, but they could also get you killed.",
                    takeable: true,
                    lore: true
                },
                "whiskey": {
                    desc: "A half-empty bottle of rotgut whiskey that burns like regret and promises oblivion. The amber liquid sloshes inside like the ghosts of cases unsolved. You've nursed this bottle through three divorces and twice as many stakeouts. As a weapon, it's a bottle of liquid courage that shatters on impact, leaving nothing but broken glass and bad decisions.",
                    takeable: true,
                    weapon_stats: {damage: 3, crit_chance: 0.1, special: "breaks_on_use", desc: "A heavy glass bottle filled with liquid fire. One swing and it's gone."}
                },
                "lockbox": {
                    desc: "A heavy steel lockbox the size of a briefcase, cold and unyielding as a coroner's slab. The combination dial is frozen at '0-0-0', mocking your attempts to crack it. You can feel the weight of secrets inside - documents that could bring down empires or just another dead-end lead. The metal is engraved with faint scratches, like someone tried to pry it open with something sharp.",
                    takeable: true,
                    owned_by: "izzy"
                },
                "ledger": {
                    desc: "A thick leather-bound ledger that smells of money and corruption. The pages are filled with columns of numbers that dance like ghosts - shipping manifests for crates that never arrived, payments to accounts that don't exist. Names you've heard in dark alleys and smoky back rooms are scrawled in careful handwriting. This book could be the smoking gun, or just another ledger in the city's endless game of three-card monte.",
                    takeable: true,
                    owned_by: "sterling"
                },
                "grok_orb": {
                    desc: "A perfect black sphere the size of your fist, smooth as a liar's promise and warm as fresh blood. It hums with a low frequency that vibrates in your bones, like the idling engine of some otherworldly machine. When you hold it, you see... things. Glimpses of futures that never were, whispers of technologies that shouldn't exist. The surface shimmers with impossible colors when you turn it just right.",
                    takeable: true,
                    weapon_stats: {damage: 0, crit_chance: 0, special: "confuse", desc: "An alien artifact that disrupts the mind. Touching it makes reality... uncertain."}
                },
                "jacket": {
                    desc: "Your faithful trench coat, a tattered relic of better days and worse weather. The fabric is worn thin at the elbows from leaning against too many bar counters, stained with coffee and cigarette ash. The pockets bulge with old receipts, half-smoked cigars, and the occasional clue you forgot to follow up on. It's seen you through rain-slicked streets and smoky interrogations, a second skin for a man who's forgotten what his first one feels like.",
                    takeable: true
                },
                "newspaper": {
                    desc: "Yesterday's edition of the Daily Herald, the ink still fresh enough to stain your fingers black. Headlines scream about the Blackwood suicide in 72-point type, but you know better - the real stories are buried in the bottom corners. An article about 'mysterious power fluctuations' at the industrial park is circled in red ink, the circle drawn with shaking hands. The paper smells of newsprint and desperation, the currency of a city that's running out of both.",
                    takeable: true
                },
                "crowbar": {
                    desc: "A length of cold iron that feels like an extension of your will. The metal is scarred from countless battles with stubborn doors and harder truths. It's heavy, reliable, and asks no questions - just like you. One end is flattened for prying, the other tapered for persuasion. Blood and rust have stained the handle, telling stories of doors forced and bones broken. This is the universal key to a city that locks everything away.",
                    takeable: true,
                    weapon_stats: {damage: 2, crit_chance: 0.05, special: "none", desc: "Heavy steel leverage. Forces open what won't open willingly."}
                },
                "rusty_key": {
                    desc: "A corroded skeleton key fished from the city's underbelly, dripping with the foul water of forgotten sewers. The teeth are worn smooth by time and corrosion, but the shape suggests it was made for something important - maybe a warehouse door, or a safe hidden behind peeling wallpaper. It feels heavy with the weight of things that should stay buried, secrets that bubble up from the depths like methane gas.",
                    takeable: true
                },
                "key": {
                    desc: "A delicate brass key that feels out of place in this grimy city, like a debutante at a dockworkers' brawl. The bow is engraved with a subtle pattern - intertwined serpents, or maybe just corrosion playing tricks. It doesn't look like it belongs to any lock you've ever picked, which means it probably opens something important. Or dangerous. In this town, those are usually the same thing.",
                    takeable: true
                },
                "tarnished_key": {
                    desc: "A small key that's seen better days, its brass plating worn away to reveal the dull copper beneath. The teeth are still sharp, suggesting it hasn't been used much, but the patina tells stories of long storage in damp places. It looks just the right size for a diary lock or a small strongbox - the kind of thing a man might use to keep his secrets safe from prying eyes. Your eyes.",
                    takeable: true
                },
                "note": {
                    desc: "A crumpled scrap of paper torn from a shipping manifest, the edges ragged like a wound that won't heal. The handwriting is hurried, paranoid - 'The truth is not on the manifest, but in the glow.' The words are underlined three times, the pen digging deep into the paper. Someone was scared when they wrote this, scared enough to hide it where no one would look. But you looked.",
                    takeable: true
                },
                "notebook": {
                    desc: "A grimy spiral notebook that smells of machine oil and fear. The pages are filled with cryptic entries written in a code that dances just out of comprehension - 'Shipment 7B - Glowing cargo - Dock 3 - Midnight.' The writing gets more erratic toward the end, the letters bleeding together like a man writing with shaking hands. This isn't just a ledger; it's a confession written in invisible ink.",
                    takeable: true
                },
                "cigarettes": {
                    desc: "A crumpled pack of Luckies, your last remaining vice in a city that's taken everything else. The pack is bent from being carried in your jacket pocket for weeks, the cellophane wrapper torn and stained. You light one when the shadows get too long and the questions start piling up. The smoke burns your lungs like truth, but at least it burns clean. For now.",
                    takeable: true,
                    owned_by: "izzy"
                },
                "flashlight": {
                    desc: "A heavy-duty flashlight that feels solid in your hand, like the only reliable thing in this rotten city. The metal casing is dented from being used as an impromptu weapon more than once, and the lens has a spiderweb crack from some forgotten confrontation. The beam cuts through darkness like truth through lies, revealing things that were better left hidden. Battery's probably running low - just like your luck.",
                    takeable: true,
                    owned_by: "izzy"
                },
                "lockpicks": {
                    desc: "A velvet-lined case containing your set of professional lockpicks, each one a slender piece of hardened steel that sings when you work it just right. These aren't the cheap street tools; these are precision instruments that can tease open the most stubborn locks. They've saved your skin more times than you can count, slipping past deadbolts and into places where you don't belong. The case smells of machine oil and success.",
                    takeable: true
                },
                "blackwood_photo": {
                    desc: "A faded photograph of Marcus Blackwood that captures him in a rare unguarded moment. He's not smiling - men like him don't smile for cameras - but there's a haunted look in his eyes, like he knows something you don't. On the back, in elegant script: 'My dearest Marcus - until death do us part. Evelyn.' The irony isn't lost on you. The edges are worn, like it's been carried in a wallet for years.",
                    takeable: true,
                    owned_by: "evelyn"
                },
                "isabella_letter": {
                    desc: "A love letter that's been crumpled and smoothed out more times than it should have been. The perfume has faded, but the desperation in the words hasn't. 'Marcus, darling - the diamond deal has gone wrong. They're watching us. Meet me tonight or we'll both be swimming with the fishes. Forever yours, Isabella.' The paper is stained with what might be tears, or maybe just cheap mascara. This isn't just infidelity; this is conspiracy.",
                    takeable: true,
                    owned_by: "evelyn"
                },
                "marcus_note": {
                    desc: "A hastily scrawled note in Marcus Blackwood's hand, the ink bleeding through the paper like a wound. 'If anything happens to me, tell the police about the warehouse. The truth is in the glow. Trust no one.' The writing is erratic, the letters sloping wildly as if written in panic or pain. Someone tried to tear it up - you can see the ripped edges - but thought better of it. This is a dead man's last words.",
                    takeable: true,
                    owned_by: "david"
                },
            },
            features: {
                "desk": { desc: "A battered oak desk that's seen better days, its surface a graveyard of crumpled papers, overflowing ashtrays, and coffee rings that map out the geography of your insomnia. The drawers stick when you try to open them, as if they're holding onto secrets they don't want to let go. You know from experience that desks like this always hide something - a hidden compartment, a false bottom, or just another dead end." },
                "poster": { desc: "A faded recruitment poster from the war, showing a stern-faced officer pointing accusingly at you. 'Start the Fires' is printed in bold red letters above a burning cityscape. The edges are curling, and someone has drawn a mustache on the officer's face with a red crayon. It's the kind of propaganda that got good men killed and bad men rich." },
                "crack": { desc: "A jagged crack in the plaster wall that snakes from floor to ceiling like a lightning bolt frozen in time. Behind it, you can see the skeleton of the building - old wiring that sparks occasionally, pipes that drip with mysterious fluids, and the kind of darkness that swallows flashlights. This crack wasn't here last week. The building is coming apart at the seams." },
                "manhole": { desc: "A heavy iron manhole cover embedded in the street like a grave marker. Steam rises from the edges in lazy curls, carrying the stench of the city's underbelly - decay, chemicals, and things that should never see daylight. The cover is cold to the touch, and you wonder what horrors crawl through the tunnels below when the sun goes down." },
                "dumpster": { desc: "An overflowing dumpster that bulges with the city's discarded dreams - crumpled newspapers, rotting food, and the occasional body part that might or might not be fake. The smell hits you like a fist: death, disappointment, and the sour tang of lives gone wrong. Rats watch you from the shadows, their eyes gleaming like tiny diamonds in the darkness." },
                "bar_counter": { desc: "A scarred mahogany bar counter that's absorbed more confessions than a priest. The wood is stained dark with years of spilled drinks, blood, and tears. Brass footrails gleam dully under the dim lights, worn smooth by countless nervous feet. Behind it hangs a mirror that's seen too many faces - yours included - and it never lies about what it shows." },
                "pawn_counter": { desc: "A thick glass counter that separates the desperate from their dignity. Behind it sits an array of forgotten treasures: wedding rings that didn't bring happiness, watches that stopped at the wrong time, and tools that built dreams that fell apart. The glass is scratched from countless transactions, each one a small tragedy." },
                "crates": { desc: "Towering stacks of wooden crates that loom like tombstones in the dim warehouse light. Blackwood Industries labels are stamped on each one in red ink, promising contents that never quite match the manifests. The wood creaks ominously when you get too close, as if the crates themselves are trying to tell you something they can't say out loud." },
                "barrels": { desc: "Rusty metal barrels that squat in the shadows like sleeping beasts. Some leak dark, viscous fluids that pool on the concrete floor, eating away at the surface like acid eating away at your resolve. The air around them hums with danger, and you wonder if the real cargo is hidden inside, or if these are just the bait." },
                "pier": { desc: "A rotting wooden pier that extends into the harbor like a accusing finger, creaking ominously with every wave that slaps against its pilings. The wood is splintered and gray, stained with salt and the blood of countless dockworkers' accidents. Fog rolls in from the water, carrying with it the ghosts of ships that never returned and men who went down with them." },
                "ships": { desc: "Dark silhouettes of cargo ships riding low in the water, their hulls black against the night sky like the backs of sleeping whales. Navigation lights blink lazily, and the air carries the deep-throated groans of metal under stress. These ships could be carrying anything - legitimate cargo, smuggled goods, or something that shouldn't exist in this world." },
                "glowing_sign": { desc: "An otherworldly sign that pulses with an inner light, casting eerie shadows that dance on the walls like ghosts at a seance. The glow isn't electric - it's something deeper, more primal, like the light that leaks from a cracked reactor core. It hums when you get close, vibrating in your bones with a frequency that makes your teeth ache." },
                "manhole_cover": { desc: "A heavy iron manhole cover that's seen better days, its surface pitted with corrosion and stamped with the city's seal - a promise of infrastructure that never quite materializes. Steam rises from the edges in lazy tendrils, carrying the damp, metallic smell of the sewers below. Something about it makes your skin crawl, like it's watching you back." },
            },
            npcStats: {
                "bartender": {willpower: 12, insight: 10, strength: 10},
                "izzy": {willpower: 14, insight: 12, strength: 8},
                "johnny": {willpower: 8, insight: 15, strength: 12},
                "bum": {willpower: 6, insight: 8, strength: 8},
                "guard": {willpower: 16, insight: 11, strength: 15},
                "Oracle": {willpower: 20, insight: 20, strength: 0},
                "landlord": {willpower: 10, insight: 8, strength: 6},
                "regular": {willpower: 9, insight: 12, strength: 9},
                "dock_worker": {willpower: 11, insight: 7, strength: 16},
                "fisherman": {willpower: 13, insight: 14, strength: 12},
                "desk_sergeant": {willpower: 15, insight: 11, strength: 13},
                "detective_morrison": {willpower: 14, insight: 16, strength: 11}
            },
            npcSchedules: {
                "bartender": { "18,24": "The Bar", "0,4": "The Bar" },
                "izzy": { "9,17": "Pawn Shop" },
                "guard": { "0,24": "Warehouse District" },
                "bum": { "0,24": "Main Street" },
                "johnny": { "20,24": "The Docks", "0,5": "The Docks" },
                "landlord": { "8,18": "Your Office" },
                "regular": { "18,24": "The Bar" },
                "dock_worker": { "6,18": "The Docks" },
                "fisherman": { "4,12": "The Docks" },
                "desk_sergeant": { "0,24": "44th Precinct" },
                "detective_morrison": { "9,17": "44th Precinct" }
            },
            getNpcDesc: (npc) => ({
                "bartender": "The bartender looks at you with a weary shrug. 'What's your poison, gumshoe?'",
                "izzy": "Izzy the pawnbroker eyes you with professional wariness. 'Buying or selling?'",
                "johnny": "Johnny the informant lurks in the shadows, always watching, always listening.",
                "bum": "The bum eyes you warily. 'Spare a dime for a vet, mister? I seen things... things that ain't right down at the docks.'",
                "guard": "A burly guard watches you suspiciously. 'This area's off-limits to civilians.'",
                "Oracle": "A holographic construct shimmers into existence. 'The answer you seek is not in the question you ask...'",
                "landlord": "Mrs. Kowalski glares at you over her spectacles. 'Rent's due, mister! And don't give me that sob story about being a detective.'",
                "regular": "The regular at the bar stares into his glass like it holds all the answers to life's mysteries. 'Another one bites the dust,' he mutters.",
                "dock_worker": "The dock worker wipes sweat from his brow. 'You look like you're looking for trouble. This ain't the place for sightseeing.'",
                "fisherman": "The old fisherman peers at you through salt-encrusted eyes. 'Sea takes what it wants, mister. Sometimes it takes people too.'",
                "desk_sergeant": "The desk sergeant looks up from his paperwork. 'Another civilian with questions. What makes you think we've got time for amateurs?'",
                "detective_morrison": "Detective Morrison leans back in his chair. 'Private dick, huh? You know we don't like your type poking around our cases.'"
            }[npc] || "")
        };

        // --- EVENT LISTENERS ---
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const command = input.value.trim();
                if (command) {
                    game.processCommand(command);
                    input.value = '';
                }
            }
        });
        
        // Menu button event listeners
        document.getElementById('new-game-btn').addEventListener('click', () => {
            if (confirm("Are you sure? Any unsaved progress will be lost.")) {
                document.getElementById('menu-overlay').classList.add('hidden');
                game.init();
            }
        });
        
        document.getElementById('load-game-btn').addEventListener('click', () => {
            document.getElementById('menu-overlay').classList.add('hidden');
            game.loadGame();
        });
        
        newGameBtn.addEventListener('click', () => {
             if (confirm("Are you sure? Any unsaved progress will be lost.")) game.init();
        });
        saveGameBtn.addEventListener('click', () => game.saveGame());
        loadGameBtn.addEventListener('click', () => game.loadGame());

        // --- START GAME ---
        // Don't auto-start - wait for user to click NEW GAME or LOAD GAME
        // game.init();
        
        // Performance optimization: Preload critical assets
        const preloadImages = () => {
            const images = ['./noir_background.png', './noir_menu.png'];
            images.forEach(src => {
                const img = new Image();
                img.onload = () => console.log(`✅ Preloaded: ${src}`);
                img.onerror = () => console.warn(`⚠️ Failed to preload: ${src}`);
                img.src = src;
            });
        };
        preloadImages();
        
        // Enhanced error handling
        window.addEventListener('error', (e) => {
            console.error('🚨 Game Error:', e.error);
            if (e.error && e.error.message.includes('Unexpected token')) {
                console.error('💡 Syntax error detected - check console for details');
            }
        });
        
        // Unhandled promise rejection handling
        window.addEventListener('unhandledrejection', (e) => {
            console.error('🚨 Unhandled Promise Rejection:', e.reason);
        });
        
        // Advanced keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        game.saveGame();
                        break;
                    case 'l':
                        e.preventDefault();
                        game.loadGame();
                        break;
                    case 'n':
                        e.preventDefault();
                        if (confirm("Start a new game?")) game.init();
                        break;
                }
            }
        });
        
        // Auto-save functionality
        let autoSaveInterval;
        const startAutoSave = () => {
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            autoSaveInterval = setInterval(() => {
                if (game.state && !game.state.gameOver) {
                    game.saveGame('Auto Save');
                    console.log('💾 Auto-saved game');
                }
            }, 300000); // Auto-save every 5 minutes
        };
        
        // Enhanced menu interactions
        const menuOverlay = document.getElementById('menu-overlay');
        if (menuOverlay) {
            menuOverlay.addEventListener('click', (e) => {
                if (e.target === menuOverlay) {
                    // Click outside menu content - do nothing (keep menu open)
                }
            });
        }
        
        // Advanced game analytics and telemetry
        const gameAnalytics = {
            startTime: Date.now(),
            actions: [],
            errors: [],
            performance: {
                loadTime: 0,
                renderTime: 0,
                memoryUsage: 0
            },
            
            trackAction: function(action, data = {}) {
                this.actions.push({
                    timestamp: Date.now(),
                    action: action,
                    data: data,
                    gameTime: Date.now() - this.startTime
                });
                console.log(`📊 Action tracked: ${action}`, data);
            },
            
            trackError: function(error, context = '') {
                this.errors.push({
                    timestamp: Date.now(),
                    error: error.message || error,
                    context: context,
                    stack: error.stack || ''
                });
                console.error(`📊 Error tracked: ${error.message || error}`, context);
            },
            
            getStats: function() {
                return {
                    totalPlayTime: Date.now() - this.startTime,
                    actionCount: this.actions.length,
                    errorCount: this.errors.length,
                    performance: this.performance
                };
            }
        };
        
        // Track game initialization
        gameAnalytics.trackAction('game_loaded', { gameType: 'noir' });
        
        // Enhanced command tracking
        const originalProcessCommand = game.processCommand;
        game.processCommand = function(command) {
            gameAnalytics.trackAction('command_executed', { command: command });
            const result = originalProcessCommand.call(this, command);
            
            // Track command success/failure
            if (result && result.includes('Error') || result && result.includes('error')) {
                gameAnalytics.trackError(new Error('Command failed'), { command: command, result: result });
            }
            
            return result;
        };
        
        // Performance monitoring
        const performanceObserver = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.entryType === 'measure') {
                    gameAnalytics.performance[entry.name] = entry.duration;
                }
            }
        });
        performanceObserver.observe({ entryTypes: ['measure'] });
        
        // Memory usage monitoring
        setInterval(() => {
            if (performance.memory) {
                gameAnalytics.performance.memoryUsage = performance.memory.usedJSHeapSize;
            }
        }, 30000); // Check every 30 seconds
        
        // Advanced cheat codes and debug commands
        const cheatCodes = {
            'godmode': () => {
                game.state.health = 999;
                game.state.stress = 0;
                game.state.hunger = 0;
                game.output('🔓 God mode activated!');
                gameAnalytics.trackAction('cheat_used', { code: 'godmode' });
            },
            'money': () => {
                game.state.cash = 99999;
                game.output('💰 Money cheat activated!');
                gameAnalytics.trackAction('cheat_used', { code: 'money' });
            },
            'teleport': (location) => {
                if (location && game.data.worldMap[location]) {
                    game.state.position = location;
                    game.output(`🚀 Teleported to ${location}!`);
                    gameAnalytics.trackAction('cheat_used', { code: 'teleport', location: location });
                } else {
                    game.output('❌ Invalid location for teleport!');
                }
            },
            'stats': () => {
                const stats = gameAnalytics.getStats();
                game.output(`📊 Game Stats: Play Time: ${Math.round(stats.totalPlayTime/1000)}s, Actions: ${stats.actionCount}, Errors: ${stats.errorCount}`);
            }
        };
        
        // Override processCommand to handle cheat codes
        const originalProcessCommandCheat = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            // Check for cheat codes
            if (lowerCommand.startsWith('cheat ')) {
                const cheatCode = lowerCommand.substring(6);
                const [code, ...args] = cheatCode.split(' ');
                
                if (cheatCodes[code]) {
                    cheatCodes[code](...args);
                    return;
                } else {
                    game.output('❌ Unknown cheat code! Available: godmode, money, teleport [location], stats');
                    return;
                }
            }
            
            return originalProcessCommandCheat.call(this, command);
        };
        
        // Advanced achievement system
        const achievements = {
            'first_command': { name: 'First Steps', description: 'Execute your first command', unlocked: false },
            'explorer': { name: 'Explorer', description: 'Visit 10 different locations', unlocked: false, progress: 0 },
            'social_butterfly': { name: 'Social Butterfly', description: 'Talk to 5 different NPCs', unlocked: false, progress: 0 },
            'detective': { name: 'Detective', description: 'Find 3 clues', unlocked: false, progress: 0 },
            'survivor': { name: 'Survivor', description: 'Play for 30 minutes', unlocked: false, progress: 0 }
        };
        
        const checkAchievements = () => {
            // Check first command
            if (!achievements.first_command.unlocked && gameAnalytics.actions.length >= 1) {
                achievements.first_command.unlocked = true;
                game.output('🏆 Achievement Unlocked: First Steps!');
            }
            
            // Check explorer achievement
            const uniqueLocations = new Set(gameAnalytics.actions
                .filter(a => a.action === 'command_executed' && a.data.command.startsWith('go '))
                .map(a => a.data.command.split(' ')[1]));
            achievements.explorer.progress = uniqueLocations.size;
            if (!achievements.explorer.unlocked && achievements.explorer.progress >= 10) {
                achievements.explorer.unlocked = true;
                game.output('🏆 Achievement Unlocked: Explorer!');
            }
            
            // Check social butterfly
            const talkedNPCs = new Set(gameAnalytics.actions
                .filter(a => a.action === 'command_executed' && a.data.command.startsWith('talk to '))
                .map(a => a.data.command.split(' ').slice(2).join(' ')));
            achievements.social_butterfly.progress = talkedNPCs.size;
            if (!achievements.social_butterfly.unlocked && achievements.social_butterfly.progress >= 5) {
                achievements.social_butterfly.unlocked = true;
                game.output('🏆 Achievement Unlocked: Social Butterfly!');
            }
            
            // Check survivor
            const playTime = gameAnalytics.getStats().totalPlayTime;
            achievements.survivor.progress = Math.floor(playTime / 60000); // minutes
            if (!achievements.survivor.unlocked && achievements.survivor.progress >= 30) {
                achievements.survivor.unlocked = true;
                game.output('🏆 Achievement Unlocked: Survivor!');
            }
        };
        
        // Check achievements every 10 actions
        let actionCount = 0;
        const originalTrackAction = gameAnalytics.trackAction;
        gameAnalytics.trackAction = function(action, data) {
            originalTrackAction.call(this, action, data);
            actionCount++;
            if (actionCount % 10 === 0) {
                checkAchievements();
            }
        };
        
        // Add achievement command
        const originalProcessCommandAchievement = game.processCommand;
        game.processCommand = function(command) {
            if (command.toLowerCase() === 'achievements') {
                game.output('🏆 ACHIEVEMENTS:');
                Object.entries(achievements).forEach(([key, achievement]) => {
                    const status = achievement.unlocked ? '✅' : '⏳';
                    const progress = achievement.progress ? ` (${achievement.progress}/${achievement.description.match(/\d+/)?.[0] || '∞'})` : '';
                    game.output(`${status} ${achievement.name}: ${achievement.description}${progress}`);
                });
                return;
            }
            return originalProcessCommandAchievement.call(this, command);
        };
        
        // Advanced modding support
        const modSystem = {
            mods: new Map(),
            
            loadMod: function(modName, modCode) {
                try {
                    const modFunction = new Function('game', 'gameAnalytics', 'achievements', modCode);
                    this.mods.set(modName, modFunction);
                    game.output(`🔧 Mod loaded: ${modName}`);
                    gameAnalytics.trackAction('mod_loaded', { modName: modName });
                } catch (error) {
                    game.output(`❌ Failed to load mod ${modName}: ${error.message}`);
                    gameAnalytics.trackError(error, `mod_loading_${modName}`);
                }
            },
            
            unloadMod: function(modName) {
                if (this.mods.has(modName)) {
                    this.mods.delete(modName);
                    game.output(`🔧 Mod unloaded: ${modName}`);
                    gameAnalytics.trackAction('mod_unloaded', { modName: modName });
                }
            },
            
            listMods: function() {
                const modList = Array.from(this.mods.keys());
                if (modList.length === 0) {
                    game.output('📋 No mods loaded');
                } else {
                    game.output('📋 Loaded mods: ' + modList.join(', '));
                }
            }
        };
        
        // Add mod commands
        const originalProcessCommandMod = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('mod load ')) {
                const modName = command.substring(9);
                // In a real implementation, this would load from a file or URL
                game.output(`❌ Mod loading not implemented yet. Mod name: ${modName}`);
                return;
            } else if (lowerCommand.startsWith('mod unload ')) {
                const modName = command.substring(11);
                modSystem.unloadMod(modName);
                return;
            } else if (lowerCommand === 'mod list') {
                modSystem.listMods();
                return;
            }
            
            return originalProcessCommandMod.call(this, command);
        };
        
        // Advanced AI-driven NPC behavior system
        const npcAI = {
            personalities: new Map(),
            relationships: new Map(),
            memory: new Map(),
            
            initializePersonality: function(npcName) {
                const personalities = ['friendly', 'hostile', 'neutral', 'mysterious', 'helpful', 'deceptive'];
                const personality = personalities[Math.floor(Math.random() * personalities.length)];
                this.personalities.set(npcName, personality);
                game.output(`🤖 ${npcName} personality: ${personality}`);
            },
            
            updateRelationship: function(npcName, change) {
                const current = this.relationships.get(npcName) || 0;
                const newValue = Math.max(-100, Math.min(100, current + change));
                this.relationships.set(npcName, newValue);
                game.output(`💭 Relationship with ${npcName}: ${newValue > 0 ? '+' : ''}${newValue}`);
            },
            
            rememberInteraction: function(npcName, interaction) {
                if (!this.memory.has(npcName)) {
                    this.memory.set(npcName, []);
                }
                this.memory.get(npcName).push({
                    timestamp: Date.now(),
                    interaction: interaction
                });
            },
            
            getResponse: function(npcName, playerAction) {
                const personality = this.personalities.get(npcName) || 'neutral';
                const relationship = this.relationships.get(npcName) || 0;
                const memories = this.memory.get(npcName) || [];
                
                // AI-driven response based on personality, relationship, and memory
                let response = '';
                
                if (personality === 'friendly') {
                    response = relationship > 50 ? 
                        "I'm so glad to see you again! How can I help?" :
                        "Hello there! Nice to meet you!";
                } else if (personality === 'hostile') {
                    response = relationship < -50 ?
                        "You again! Get away from me!" :
                        "What do you want? I don't have time for this.";
                } else if (personality === 'mysterious') {
                    response = "The shadows whisper your name... what secrets do you seek?";
                } else if (personality === 'helpful') {
                    response = "I might be able to help you with that. What do you need?";
                } else if (personality === 'deceptive') {
                    response = "Oh, I'm sure I can help you... for a price.";
                } else {
                    response = "I'm not sure what you want from me.";
                }
                
                // Remember this interaction
                this.rememberInteraction(npcName, playerAction);
                
                return response;
            }
        };
        
        // Advanced weather and time system
        const weatherSystem = {
            currentWeather: 'clear',
            timeOfDay: 'day',
            temperature: 72,
            
            updateWeather: function() {
                const weathers = ['clear', 'rainy', 'foggy', 'stormy', 'overcast'];
                this.currentWeather = weathers[Math.floor(Math.random() * weathers.length)];
                
                // Update temperature based on weather
                if (this.currentWeather === 'rainy') this.temperature = 65;
                else if (this.currentWeather === 'stormy') this.temperature = 60;
                else if (this.currentWeather === 'foggy') this.temperature = 55;
                else this.temperature = 72;
                
                game.output(`🌤️ Weather changed to: ${this.currentWeather} (${this.temperature}°F)`);
            },
            
            updateTime: function() {
                const times = ['dawn', 'day', 'dusk', 'night'];
                const currentIndex = times.indexOf(this.timeOfDay);
                this.timeOfDay = times[(currentIndex + 1) % times.length];
                
                game.output(`🕐 Time changed to: ${this.timeOfDay}`);
            },
            
            getWeatherEffect: function() {
                if (this.currentWeather === 'rainy') {
                    return "The rain makes everything look more mysterious and dangerous.";
                } else if (this.currentWeather === 'foggy') {
                    return "The fog obscures your vision, making it hard to see details.";
                } else if (this.currentWeather === 'stormy') {
                    return "The storm rages overhead, creating an ominous atmosphere.";
                } else if (this.currentWeather === 'overcast') {
                    return "The overcast sky casts everything in a dull, gray light.";
                } else {
                    return "The clear sky provides good visibility.";
                }
            }
        };
        
        // Advanced inventory management system
        const inventorySystem = {
            maxWeight: 100,
            currentWeight: 0,
            items: new Map(),
            
            addItem: function(item, weight = 1) {
                if (this.currentWeight + weight > this.maxWeight) {
                    game.output(`❌ Too heavy! Cannot carry ${item}.`);
                    return false;
                }
                
                this.items.set(item, (this.items.get(item) || 0) + 1);
                this.currentWeight += weight;
                game.output(`✅ Added ${item} to inventory. Weight: ${this.currentWeight}/${this.maxWeight}`);
                return true;
            },
            
            removeItem: function(item, weight = 1) {
                if (!this.items.has(item) || this.items.get(item) <= 0) {
                    game.output(`❌ You don't have ${item}.`);
                    return false;
                }
                
                this.items.set(item, this.items.get(item) - 1);
                this.currentWeight -= weight;
                if (this.items.get(item) <= 0) {
                    this.items.delete(item);
                }
                game.output(`✅ Removed ${item} from inventory. Weight: ${this.currentWeight}/${this.maxWeight}`);
                return true;
            },
            
            getInventory: function() {
                if (this.items.size === 0) {
                    return "Your inventory is empty.";
                }
                
                let inventory = "📦 INVENTORY:\n";
                for (const [item, count] of this.items) {
                    inventory += `  ${item} (${count})\n`;
                }
                inventory += `\nWeight: ${this.currentWeight}/${this.maxWeight}`;
                return inventory;
            }
        };
        
        // Add weather and time commands
        const originalProcessCommandWeather = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'weather') {
                game.output(`🌤️ Current weather: ${weatherSystem.currentWeather} (${weatherSystem.temperature}°F)`);
                game.output(weatherSystem.getWeatherEffect());
                return;
            } else if (lowerCommand === 'time') {
                game.output(`🕐 Current time: ${weatherSystem.timeOfDay}`);
                return;
            } else if (lowerCommand === 'change weather') {
                weatherSystem.updateWeather();
                return;
            } else if (lowerCommand === 'change time') {
                weatherSystem.updateTime();
                return;
            } else if (lowerCommand === 'inventory') {
                game.output(inventorySystem.getInventory());
                return;
            }
            
            return originalProcessCommandWeather.call(this, command);
        };
        
        // Advanced combat system with tactical elements
        const combatSystem = {
            isInCombat: false,
            currentEnemy: null,
            combatTurn: 0,
            combatActions: ['attack', 'defend', 'flee', 'use_item'],
            
            startCombat: function(enemy) {
                this.isInCombat = true;
                this.currentEnemy = enemy;
                this.combatTurn = 0;
                game.output(`⚔️ COMBAT STARTED!`);
                game.output(`You are fighting: ${enemy.name}`);
                game.output(`Health: ${enemy.health}/${enemy.maxHealth}`);
                game.output(`Available actions: ${this.combatActions.join(', ')}`);
            },
            
            processCombatTurn: function(playerAction) {
                if (!this.isInCombat) return;
                
                this.combatTurn++;
                game.output(`\n--- TURN ${this.combatTurn} ---`);
                
                // Player action
                if (playerAction === 'attack') {
                    const damage = Math.floor(Math.random() * 20) + 10;
                    this.currentEnemy.health -= damage;
                    game.output(`You attack for ${damage} damage!`);
                } else if (playerAction === 'defend') {
                    game.output(`You take a defensive stance.`);
                } else if (playerAction === 'flee') {
                    if (Math.random() < 0.7) {
                        game.output(`You successfully flee from combat!`);
                        this.endCombat();
                        return;
                    } else {
                        game.output(`You fail to flee!`);
                    }
                }
                
                // Check if enemy is defeated
                if (this.currentEnemy.health <= 0) {
                    game.output(`🎉 You defeated ${this.currentEnemy.name}!`);
                    this.endCombat();
                    return;
                }
                
                // Enemy action
                const enemyAction = this.combatActions[Math.floor(Math.random() * this.combatActions.length)];
                if (enemyAction === 'attack') {
                    const damage = Math.floor(Math.random() * 15) + 5;
                    game.state.health -= damage;
                    game.output(`${this.currentEnemy.name} attacks for ${damage} damage!`);
                } else if (enemyAction === 'defend') {
                    game.output(`${this.currentEnemy.name} takes a defensive stance.`);
                }
                
                // Check if player is defeated
                if (game.state.health <= 0) {
                    game.output(`💀 You have been defeated!`);
                    this.endCombat();
                    return;
                }
                
                game.output(`Your health: ${game.state.health}`);
                game.output(`Enemy health: ${this.currentEnemy.health}`);
            },
            
            endCombat: function() {
                this.isInCombat = false;
                this.currentEnemy = null;
                this.combatTurn = 0;
                game.output(`⚔️ Combat ended.`);
            }
        };
        
        // Advanced quest system
        const questSystem = {
            activeQuests: new Map(),
            completedQuests: new Set(),
            questRewards: new Map(),
            
            addQuest: function(questId, questData) {
                this.activeQuests.set(questId, {
                    ...questData,
                    status: 'active',
                    progress: 0,
                    maxProgress: questData.maxProgress || 1
                });
                game.output(`📋 New quest: ${questData.name}`);
                game.output(`Description: ${questData.description}`);
            },
            
            updateQuestProgress: function(questId, progress = 1) {
                if (!this.activeQuests.has(questId)) return;
                
                const quest = this.activeQuests.get(questId);
                quest.progress += progress;
                
                if (quest.progress >= quest.maxProgress) {
                    this.completeQuest(questId);
                } else {
                    game.output(`📋 Quest progress: ${quest.progress}/${quest.maxProgress}`);
                }
            },
            
            completeQuest: function(questId) {
                const quest = this.activeQuests.get(questId);
                if (!quest) return;
                
                quest.status = 'completed';
                this.completedQuests.add(questId);
                this.activeQuests.delete(questId);
                
                game.output(`🎉 Quest completed: ${quest.name}`);
                
                // Give rewards
                if (quest.rewards) {
                    quest.rewards.forEach(reward => {
                        if (reward.type === 'experience') {
                            game.state.experience += reward.amount;
                            game.output(`+${reward.amount} experience`);
                        } else if (reward.type === 'item') {
                            inventorySystem.addItem(reward.item, reward.weight || 1);
                        } else if (reward.type === 'money') {
                            game.state.cash += reward.amount;
                            game.output(`+$${reward.amount}`);
                        }
                    });
                }
            },
            
            listQuests: function() {
                if (this.activeQuests.size === 0) {
                    game.output(`📋 No active quests.`);
                    return;
                }
                
                game.output(`📋 ACTIVE QUESTS:`);
                for (const [id, quest] of this.activeQuests) {
                    game.output(`  ${quest.name}: ${quest.progress}/${quest.maxProgress}`);
                }
            }
        };
        
        // Advanced crafting system
        const craftingSystem = {
            recipes: new Map(),
            materials: new Map(),
            
            addRecipe: function(itemName, materials, result) {
                this.recipes.set(itemName, { materials, result });
            },
            
            canCraft: function(itemName) {
                const recipe = this.recipes.get(itemName);
                if (!recipe) return false;
                
                for (const [material, amount] of recipe.materials) {
                    if (!inventorySystem.items.has(material) || 
                        inventorySystem.items.get(material) < amount) {
                        return false;
                    }
                }
                return true;
            },
            
            craftItem: function(itemName) {
                const recipe = this.recipes.get(itemName);
                if (!recipe) {
                    game.output(`❌ Unknown recipe: ${itemName}`);
                    return false;
                }
                
                if (!this.canCraft(itemName)) {
                    game.output(`❌ Not enough materials to craft ${itemName}`);
                    return false;
                }
                
                // Consume materials
                for (const [material, amount] of recipe.materials) {
                    inventorySystem.removeItem(material, 1);
                }
                
                // Add result
                inventorySystem.addItem(recipe.result, 1);
                game.output(`🔨 Crafted ${recipe.result}!`);
                return true;
            },
            
            listRecipes: function() {
                game.output(`🔨 AVAILABLE RECIPES:`);
                for (const [name, recipe] of this.recipes) {
                    const canCraft = this.canCraft(name) ? '✅' : '❌';
                    game.output(`  ${canCraft} ${name}: ${recipe.result}`);
                }
            }
        };
        
        // Add some default recipes
        craftingSystem.addRecipe('health_potion', [['herbs', 2], ['water', 1]], 'Health Potion');
        craftingSystem.addRecipe('lockpick', [['metal', 1], ['wire', 1]], 'Lockpick');
        craftingSystem.addRecipe('smoke_bomb', [['chemicals', 1], ['cloth', 1]], 'Smoke Bomb');
        
        // Add combat, quest, and crafting commands
        const originalProcessCommandAdvanced = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'combat') {
                if (combatSystem.isInCombat) {
                    game.output(`⚔️ Currently in combat! Use: attack, defend, flee`);
                } else {
                    game.output(`⚔️ Not in combat. Use 'attack [enemy]' to start combat.`);
                }
                return;
            } else if (lowerCommand.startsWith('attack ')) {
                const enemyName = command.substring(7);
                const enemy = { name: enemyName, health: 50, maxHealth: 50 };
                combatSystem.startCombat(enemy);
                return;
            } else if (lowerCommand === 'quests') {
                questSystem.listQuests();
                return;
            } else if (lowerCommand === 'craft') {
                craftingSystem.listRecipes();
                return;
            } else if (lowerCommand.startsWith('craft ')) {
                const itemName = command.substring(6);
                craftingSystem.craftItem(itemName);
                return;
            }
            
            return originalProcessCommandAdvanced.call(this, command);
        };
        
        // Advanced skill system
        const skillSystem = {
            skills: new Map(),
            skillPoints: 0,
            maxSkillLevel: 100,
            
            initializeSkill: function(skillName, baseValue = 0) {
                this.skills.set(skillName, {
                    level: baseValue,
                    experience: 0,
                    maxExperience: 100
                });
            },
            
            addExperience: function(skillName, amount) {
                if (!this.skills.has(skillName)) {
                    this.initializeSkill(skillName);
                }
                
                const skill = this.skills.get(skillName);
                skill.experience += amount;
                
                // Check for level up
                while (skill.experience >= skill.maxExperience && skill.level < this.maxSkillLevel) {
                    skill.experience -= skill.maxExperience;
                    skill.level++;
                    skill.maxExperience = Math.floor(skill.maxExperience * 1.2);
                    game.output(`🎉 ${skillName} leveled up to ${skill.level}!`);
                }
            },
            
            getSkillLevel: function(skillName) {
                return this.skills.has(skillName) ? this.skills.get(skillName).level : 0;
            },
            
            listSkills: function() {
                if (this.skills.size === 0) {
                    game.output(`📊 No skills learned yet.`);
                    return;
                }
                
                game.output(`📊 SKILLS:`);
                for (const [name, skill] of this.skills) {
                    const progress = Math.floor((skill.experience / skill.maxExperience) * 100);
                    game.output(`  ${name}: Level ${skill.level} (${progress}% to next level)`);
                }
            }
        };
        
        // Initialize some default skills
        skillSystem.initializeSkill('detective', 5);
        skillSystem.initializeSkill('combat', 3);
        skillSystem.initializeSkill('stealth', 2);
        skillSystem.initializeSkill('persuasion', 4);
        skillSystem.initializeSkill('investigation', 6);
        
        // Advanced reputation system
        const reputationSystem = {
            factions: new Map(),
            globalReputation: 0,
            
            initializeFaction: function(factionName, baseRep = 0) {
                this.factions.set(factionName, {
                    reputation: baseRep,
                    status: 'neutral',
                    history: []
                });
            },
            
            updateReputation: function(factionName, change, reason = '') {
                if (!this.factions.has(factionName)) {
                    this.initializeFaction(factionName);
                }
                
                const faction = this.factions.get(factionName);
                faction.reputation += change;
                faction.history.push({
                    timestamp: Date.now(),
                    change: change,
                    reason: reason
                });
                
                // Update status based on reputation
                if (faction.reputation >= 100) {
                    faction.status = 'allied';
                } else if (faction.reputation >= 50) {
                    faction.status = 'friendly';
                } else if (faction.reputation >= -50) {
                    faction.status = 'neutral';
                } else if (faction.reputation >= -100) {
                    faction.status = 'hostile';
                } else {
                    faction.status = 'enemy';
                }
                
                game.output(`📈 Reputation with ${factionName}: ${faction.reputation} (${faction.status})`);
            },
            
            getFactionStatus: function(factionName) {
                return this.factions.has(factionName) ? this.factions.get(factionName).status : 'unknown';
            },
            
            listReputations: function() {
                if (this.factions.size === 0) {
                    game.output(`📈 No faction reputations yet.`);
                    return;
                }
                
                game.output(`📈 FACTION REPUTATIONS:`);
                for (const [name, faction] of this.factions) {
                    game.output(`  ${name}: ${faction.reputation} (${faction.status})`);
                }
            }
        };
        
        // Initialize some default factions
        reputationSystem.initializeFaction('police', 0);
        reputationSystem.initializeFaction('criminals', -20);
        reputationSystem.initializeFaction('civilians', 10);
        reputationSystem.initializeFaction('press', 5);
        
        // Advanced dialogue system
        const dialogueSystem = {
            conversations: new Map(),
            currentConversation: null,
            
            startConversation: function(npcName, dialogueTree) {
                this.currentConversation = {
                    npc: npcName,
                    tree: dialogueTree,
                    currentNode: 'start'
                };
                
                this.displayCurrentNode();
            },
            
            displayCurrentNode: function() {
                if (!this.currentConversation) return;
                
                const node = this.currentConversation.tree[this.currentConversation.currentNode];
                if (!node) return;
                
                game.output(`\n💬 ${this.currentConversation.npc}: ${node.text}`);
                
                if (node.options && node.options.length > 0) {
                    game.output(`\nOptions:`);
                    node.options.forEach((option, index) => {
                        game.output(`  ${index + 1}. ${option.text}`);
                    });
                }
            },
            
            selectOption: function(optionIndex) {
                if (!this.currentConversation) return;
                
                const node = this.currentConversation.tree[this.currentConversation.currentNode];
                if (!node || !node.options || optionIndex < 0 || optionIndex >= node.options.length) {
                    game.output(`❌ Invalid option.`);
                    return;
                }
                
                const option = node.options[optionIndex];
                this.currentConversation.currentNode = option.nextNode || 'end';
                
                if (option.effect) {
                    option.effect();
                }
                
                if (this.currentConversation.currentNode === 'end') {
                    this.endConversation();
                } else {
                    this.displayCurrentNode();
                }
            },
            
            endConversation: function() {
                this.currentConversation = null;
                game.output(`\n💬 Conversation ended.`);
            }
        };
        
        // Add skill, reputation, and dialogue commands
        const originalProcessCommandSystems = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'skills') {
                skillSystem.listSkills();
                return;
            } else if (lowerCommand === 'reputation') {
                reputationSystem.listReputations();
                return;
            } else if (lowerCommand.startsWith('talk to ')) {
                const npcName = command.substring(8);
                // Simple dialogue tree for demonstration
                const dialogueTree = {
                    start: {
                        text: `Hello there! What can I do for you?`,
                        options: [
                            { text: "I need information", nextNode: 'info' },
                            { text: "Just passing by", nextNode: 'end' }
                        ]
                    },
                    info: {
                        text: `I might have some information. What are you looking for?`,
                        options: [
                            { text: "Tell me about the recent crimes", nextNode: 'crimes' },
                            { text: "Never mind", nextNode: 'end' }
                        ]
                    },
                    crimes: {
                        text: `There have been some strange happenings lately. Be careful out there.`,
                        options: [
                            { text: "Thank you", nextNode: 'end' }
                        ]
                    }
                };
                dialogueSystem.startConversation(npcName, dialogueTree);
                return;
            }
            
            return originalProcessCommandSystems.call(this, command);
        };
        
        // Advanced mini-game system
        const miniGameSystem = {
            activeGame: null,
            games: new Map(),
            
            registerGame: function(gameName, gameData) {
                this.games.set(gameName, gameData);
            },
            
            startGame: function(gameName) {
                if (!this.games.has(gameName)) {
                    game.output(`❌ Unknown mini-game: ${gameName}`);
                    return;
                }
                
                this.activeGame = {
                    name: gameName,
                    data: this.games.get(gameName),
                    state: this.games.get(gameName).initialState || {}
                };
                
                game.output(`🎮 Starting ${gameName} mini-game!`);
                this.activeGame.data.start(this.activeGame.state);
            },
            
            endGame: function() {
                if (this.activeGame) {
                    game.output(`🎮 ${this.activeGame.name} mini-game ended.`);
                    this.activeGame = null;
                }
            },
            
            processInput: function(input) {
                if (!this.activeGame) return false;
                
                const result = this.activeGame.data.processInput(input, this.activeGame.state);
                if (result) {
                    this.activeGame.state = result.state || this.activeGame.state;
                    if (result.end) {
                        this.endGame();
                    }
                }
                return true;
            }
        };
        
        // Register some mini-games
        miniGameSystem.registerGame('lockpick', {
            initialState: { difficulty: 1, attempts: 0, maxAttempts: 5 },
            start: function(state) {
                game.output(`🔓 Lockpicking mini-game started!`);
                game.output(`Difficulty: ${state.difficulty}/5`);
                game.output(`Attempts remaining: ${state.maxAttempts - state.attempts}`);
                game.output(`Commands: try [direction], quit`);
            },
            processInput: function(input, state) {
                const parts = input.toLowerCase().split(' ');
                const command = parts[0];
                
                if (command === 'quit') {
                    game.output(`🔓 Lockpicking abandoned.`);
                    return { end: true };
                } else if (command === 'try') {
                    const direction = parts[1];
                    if (!direction) {
                        game.output(`❌ Try what direction? (up, down, left, right)`);
                        return { state };
                    }
                    
                    state.attempts++;
                    const success = Math.random() < (0.3 - (state.difficulty * 0.05));
                    
                    if (success) {
                        game.output(`🎉 Lock picked successfully!`);
                        skillSystem.addExperience('stealth', 10);
                        return { end: true };
                    } else {
                        game.output(`❌ Failed attempt. ${state.maxAttempts - state.attempts} attempts remaining.`);
                        
                        if (state.attempts >= state.maxAttempts) {
                            game.output(`💀 Lockpicking failed! The lock is jammed.`);
                            return { end: true };
                        }
                    }
                } else {
                    game.output(`❌ Unknown command. Use: try [direction], quit`);
                }
                
                return { state };
            }
        });
        
        miniGameSystem.registerGame('hacking', {
            initialState: { level: 1, progress: 0, maxProgress: 100 },
            start: function(state) {
                game.output(`💻 Hacking mini-game started!`);
                game.output(`Security Level: ${state.level}/5`);
                game.output(`Progress: ${state.progress}/${state.maxProgress}%`);
                game.output(`Commands: hack [target], quit`);
            },
            processInput: function(input, state) {
                const parts = input.toLowerCase().split(' ');
                const command = parts[0];
                
                if (command === 'quit') {
                    game.output(`💻 Hacking session terminated.`);
                    return { end: true };
                } else if (command === 'hack') {
                    const target = parts[1];
                    if (!target) {
                        game.output(`❌ Hack what? (firewall, database, system)`);
                        return { state };
                    }
                    
                    const success = Math.random() < (0.4 - (state.level * 0.08));
                    if (success) {
                        const progress = Math.floor(Math.random() * 20) + 10;
                        state.progress += progress;
                        game.output(`✅ Successfully hacked ${target}! +${progress}% progress`);
                        
                        if (state.progress >= state.maxProgress) {
                            game.output(`🎉 System compromised!`);
                            skillSystem.addExperience('hacking', 15);
                            return { end: true };
                        }
                    } else {
                        game.output(`❌ Hack failed. Security systems are alert.`);
                    }
                } else {
                    game.output(`❌ Unknown command. Use: hack [target], quit`);
                }
                
                return { state };
            }
        });
        
        // Advanced event system
        const eventSystem = {
            events: new Map(),
            activeEvents: new Set(),
            eventHistory: [],
            
            registerEvent: function(eventName, eventData) {
                this.events.set(eventName, eventData);
            },
            
            triggerEvent: function(eventName, context = {}) {
                if (!this.events.has(eventName)) {
                    game.output(`❌ Unknown event: ${eventName}`);
                    return;
                }
                
                const event = this.events.get(eventName);
                this.activeEvents.add(eventName);
                this.eventHistory.push({
                    name: eventName,
                    timestamp: Date.now(),
                    context: context
                });
                
                game.output(`\n🎭 EVENT: ${event.title}`);
                game.output(event.description);
                
                if (event.choices && event.choices.length > 0) {
                    game.output(`\nChoices:`);
                    event.choices.forEach((choice, index) => {
                        game.output(`  ${index + 1}. ${choice.text}`);
                    });
                }
                
                if (event.effects) {
                    event.effects.forEach(effect => {
                        if (effect.type === 'reputation') {
                            reputationSystem.updateReputation(effect.faction, effect.change, event.title);
                        } else if (effect.type === 'skill') {
                            skillSystem.addExperience(effect.skill, effect.amount);
                        } else if (effect.type === 'item') {
                            inventorySystem.addItem(effect.item, effect.weight || 1);
                        }
                    });
                }
            },
            
            listEvents: function() {
                if (this.activeEvents.size === 0) {
                    game.output(`🎭 No active events.`);
                    return;
                }
                
                game.output(`🎭 ACTIVE EVENTS:`);
                for (const eventName of this.activeEvents) {
                    const event = this.events.get(eventName);
                    game.output(`  ${event.title}`);
                }
            }
        };
        
        // Register some events
        eventSystem.registerEvent('mysterious_stranger', {
            title: 'Mysterious Stranger',
            description: 'A shadowy figure approaches you in the alley. They seem to know something about your case.',
            choices: [
                { text: 'Listen to what they have to say' },
                { text: 'Ignore them and walk away' },
                { text: 'Ask them directly about the case' }
            ],
            effects: [
                { type: 'reputation', faction: 'criminals', change: 5, reason: 'Mysterious Stranger' }
            ]
        });
        
        eventSystem.registerEvent('police_raid', {
            title: 'Police Raid',
            description: 'The police are conducting a raid nearby. You need to decide how to handle this situation.',
            choices: [
                { text: 'Help the police' },
                { text: 'Stay out of it' },
                { text: 'Warn the suspects' }
            ],
            effects: [
                { type: 'reputation', faction: 'police', change: 10, reason: 'Police Raid' }
            ]
        });
        
        // Add mini-game and event commands
        const originalProcessCommandMini = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'minigames') {
                game.output(`🎮 Available mini-games: lockpick, hacking`);
                return;
            } else if (lowerCommand.startsWith('play ')) {
                const gameName = command.substring(5);
                miniGameSystem.startGame(gameName);
                return;
            } else if (lowerCommand === 'events') {
                eventSystem.listEvents();
                return;
            } else if (lowerCommand.startsWith('trigger ')) {
                const eventName = command.substring(8);
                eventSystem.triggerEvent(eventName);
                return;
            }
            
            // Check if we're in a mini-game
            if (miniGameSystem.processInput(command)) {
                return;
            }
            
            return originalProcessCommandMini.call(this, command);
        };
        
        // Advanced save system with multiple slots
        const saveSystem = {
            maxSaves: 10,
            currentSave: null,
            
            saveGame: function(saveName) {
                if (!saveName) {
                    game.output(`❌ Please provide a save name.`);
                    return;
                }
                
                const saveData = {
                    timestamp: Date.now(),
                    gameState: game.state,
                    skillSystem: skillSystem,
                    reputationSystem: reputationSystem,
                    inventorySystem: inventorySystem,
                    questSystem: questSystem,
                    combatSystem: combatSystem,
                    craftingSystem: craftingSystem,
                    weatherSystem: weatherSystem,
                    npcAI: npcAI,
                    achievements: achievements,
                    gameAnalytics: gameAnalytics
                };
                
                try {
                    localStorage.setItem(`gumshoe_noir_${saveName}`, JSON.stringify(saveData));
                    game.output(`💾 Game saved as "${saveName}"`);
                } catch (error) {
                    game.output(`❌ Failed to save game: ${error.message}`);
                }
            },
            
            loadGame: function(saveName) {
                if (!saveName) {
                    game.output(`❌ Please provide a save name.`);
                    return;
                }
                
                try {
                    const saveData = localStorage.getItem(`gumshoe_noir_${saveName}`);
                    if (!saveData) {
                        game.output(`❌ Save "${saveName}" not found.`);
                        return;
                    }
                    
                    const parsedData = JSON.parse(saveData);
                    
                    // Restore game state
                    game.state = parsedData.gameState;
                    skillSystem = parsedData.skillSystem || skillSystem;
                    reputationSystem = parsedData.reputationSystem || reputationSystem;
                    inventorySystem = parsedData.inventorySystem || inventorySystem;
                    questSystem = parsedData.questSystem || questSystem;
                    combatSystem = parsedData.combatSystem || combatSystem;
                    craftingSystem = parsedData.craftingSystem || craftingSystem;
                    weatherSystem = parsedData.weatherSystem || weatherSystem;
                    npcAI = parsedData.npcAI || npcAI;
                    achievements = parsedData.achievements || achievements;
                    gameAnalytics = parsedData.gameAnalytics || gameAnalytics;
                    
                    this.currentSave = saveName;
                    game.output(`💾 Game loaded from "${saveName}"`);
                    game.output(`You are in: ${game.getCurrentRoom().name}`);
                } catch (error) {
                    game.output(`❌ Failed to load game: ${error.message}`);
                }
            },
            
            listSaves: function() {
                const saves = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('gumshoe_noir_')) {
                        const saveName = key.replace('gumshoe_noir_', '');
                        const saveData = JSON.parse(localStorage.getItem(key));
                        saves.push({
                            name: saveName,
                            timestamp: saveData.timestamp,
                            date: new Date(saveData.timestamp).toLocaleString()
                        });
                    }
                }
                
                if (saves.length === 0) {
                    game.output(`💾 No saves found.`);
                    return;
                }
                
                game.output(`💾 SAVES:`);
                saves.sort((a, b) => b.timestamp - a.timestamp).forEach(save => {
                    game.output(`  ${save.name} - ${save.date}`);
                });
            },
            
            deleteSave: function(saveName) {
                if (!saveName) {
                    game.output(`❌ Please provide a save name.`);
                    return;
                }
                
                try {
                    localStorage.removeItem(`gumshoe_noir_${saveName}`);
                    game.output(`💾 Save "${saveName}" deleted.`);
                } catch (error) {
                    game.output(`❌ Failed to delete save: ${error.message}`);
                }
            }
        };
        
        // Advanced settings system
        const settingsSystem = {
            settings: {
                autoSave: true,
                autoSaveInterval: 300000, // 5 minutes
                showTips: true,
                soundEnabled: true,
                musicEnabled: true,
                fontSize: 'medium',
                theme: 'noir'
            },
            
            loadSettings: function() {
                try {
                    const savedSettings = localStorage.getItem('gumshoe_noir_settings');
                    if (savedSettings) {
                        this.settings = { ...this.settings, ...JSON.parse(savedSettings) };
                    }
                } catch (error) {
                    console.error('Failed to load settings:', error);
                }
            },
            
            saveSettings: function() {
                try {
                    localStorage.setItem('gumshoe_noir_settings', JSON.stringify(this.settings));
                } catch (error) {
                    console.error('Failed to save settings:', error);
                }
            },
            
            updateSetting: function(key, value) {
                if (this.settings.hasOwnProperty(key)) {
                    this.settings[key] = value;
                    this.saveSettings();
                    game.output(`⚙️ Setting ${key} updated to ${value}`);
                } else {
                    game.output(`❌ Unknown setting: ${key}`);
                }
            },
            
            listSettings: function() {
                game.output(`⚙️ SETTINGS:`);
                for (const [key, value] of Object.entries(this.settings)) {
                    game.output(`  ${key}: ${value}`);
                }
            }
        };
        
        // Load settings on startup
        settingsSystem.loadSettings();
        
        // Advanced help system
        const helpSystem = {
            categories: {
                basic: ['look', 'go', 'take', 'drop', 'inventory', 'help'],
                combat: ['attack', 'defend', 'flee', 'combat'],
                quests: ['quests', 'quest', 'complete'],
                crafting: ['craft', 'recipes', 'materials'],
                skills: ['skills', 'experience'],
                reputation: ['reputation', 'factions'],
                dialogue: ['talk to', 'conversation'],
                minigames: ['minigames', 'play'],
                events: ['events', 'trigger'],
                saves: ['save', 'load', 'saves'],
                settings: ['settings', 'config'],
                cheats: ['godmode', 'money', 'teleport', 'stats']
            },
            
            showHelp: function(category = null) {
                if (!category) {
                    game.output(`📚 HELP SYSTEM:`);
                    game.output(`Available categories: ${Object.keys(this.categories).join(', ')}`);
                    game.output(`Use 'help [category]' for specific help.`);
                    return;
                }
                
                if (!this.categories[category]) {
                    game.output(`❌ Unknown category: ${category}`);
                    return;
                }
                
                game.output(`📚 HELP - ${category.toUpperCase()}:`);
                this.categories[category].forEach(command => {
                    game.output(`  ${command}`);
                });
            },
            
            searchHelp: function(query) {
                const results = [];
                for (const [category, commands] of Object.entries(this.categories)) {
                    const matches = commands.filter(cmd => cmd.includes(query.toLowerCase()));
                    if (matches.length > 0) {
                        results.push({ category, commands: matches });
                    }
                }
                
                if (results.length === 0) {
                    game.output(`❌ No help found for "${query}"`);
                    return;
                }
                
                game.output(`📚 SEARCH RESULTS for "${query}":`);
                results.forEach(result => {
                    game.output(`  ${result.category}: ${result.commands.join(', ')}`);
                });
            }
        };
        
        // Add save, settings, and help commands
        const originalProcessCommandSave = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('save ')) {
                const saveName = command.substring(5);
                saveSystem.saveGame(saveName);
                return;
            } else if (lowerCommand.startsWith('load ')) {
                const saveName = command.substring(5);
                saveSystem.loadGame(saveName);
                return;
            } else if (lowerCommand === 'saves') {
                saveSystem.listSaves();
                return;
            } else if (lowerCommand.startsWith('delete ')) {
                const saveName = command.substring(7);
                saveSystem.deleteSave(saveName);
                return;
            } else if (lowerCommand === 'settings') {
                settingsSystem.listSettings();
                return;
            } else if (lowerCommand.startsWith('set ')) {
                const parts = command.substring(4).split(' ');
                const key = parts[0];
                const value = parts[1];
                settingsSystem.updateSetting(key, value);
                return;
            } else if (lowerCommand === 'help') {
                helpSystem.showHelp();
                return;
            } else if (lowerCommand.startsWith('help ')) {
                const category = command.substring(5);
                helpSystem.showHelp(category);
                return;
            } else if (lowerCommand.startsWith('search ')) {
                const query = command.substring(7);
                helpSystem.searchHelp(query);
                return;
            }
            
            return originalProcessCommandSave.call(this, command);
        };
        
        // Advanced tutorial system
        const tutorialSystem = {
            tutorials: new Map(),
            activeTutorial: null,
            completedTutorials: new Set(),
            
            registerTutorial: function(tutorialName, tutorialData) {
                this.tutorials.set(tutorialName, tutorialData);
            },
            
            startTutorial: function(tutorialName) {
                if (!this.tutorials.has(tutorialName)) {
                    game.output(`❌ Unknown tutorial: ${tutorialName}`);
                    return;
                }
                
                this.activeTutorial = {
                    name: tutorialName,
                    data: this.tutorials.get(tutorialName),
                    currentStep: 0
                };
                
                game.output(`📖 Starting tutorial: ${tutorialName}`);
                this.showCurrentStep();
            },
            
            showCurrentStep: function() {
                if (!this.activeTutorial) return;
                
                const step = this.activeTutorial.data.steps[this.activeTutorial.currentStep];
                if (!step) {
                    this.completeTutorial();
                    return;
                }
                
                game.output(`\n📖 TUTORIAL STEP ${this.activeTutorial.currentStep + 1}:`);
                game.output(step.text);
                
                if (step.command) {
                    game.output(`\nTry: ${step.command}`);
                }
                
                if (step.hint) {
                    game.output(`\n💡 Hint: ${step.hint}`);
                }
            },
            
            nextStep: function() {
                if (!this.activeTutorial) return;
                
                this.activeTutorial.currentStep++;
                this.showCurrentStep();
            },
            
            completeTutorial: function() {
                if (!this.activeTutorial) return;
                
                this.completedTutorials.add(this.activeTutorial.name);
                game.output(`\n🎉 Tutorial "${this.activeTutorial.name}" completed!`);
                this.activeTutorial = null;
            },
            
            listTutorials: function() {
                if (this.tutorials.size === 0) {
                    game.output(`📖 No tutorials available.`);
                    return;
                }
                
                game.output(`📖 TUTORIALS:`);
                for (const [name, tutorial] of this.tutorials) {
                    const status = this.completedTutorials.has(name) ? '✅' : '⭕';
                    game.output(`  ${status} ${name} - ${tutorial.description}`);
                }
            }
        };
        
        // Register some tutorials
        tutorialSystem.registerTutorial('getting_started', {
            description: 'Learn the basics of playing GUMSHOE',
            steps: [
                {
                    text: 'Welcome to GUMSHOE! This is a text-based detective game. You can type commands to interact with the world.',
                    command: 'look',
                    hint: 'Start by looking around to see what\'s in your current location.'
                },
                {
                    text: 'Great! Now try moving to a different location.',
                    command: 'go north',
                    hint: 'Use "go [direction]" to move around the world.'
                },
                {
                    text: 'Excellent! You can also examine objects and talk to people.',
                    command: 'examine [object]',
                    hint: 'Use "examine" to look at specific items or "talk to [person]" to start conversations.'
                },
                {
                    text: 'You can save your progress at any time.',
                    command: 'save mygame',
                    hint: 'Use "save [name]" to save your game and "load [name]" to load it later.'
                }
            ]
        });
        
        tutorialSystem.registerTutorial('combat_basics', {
            description: 'Learn how to fight and defend yourself',
            steps: [
                {
                    text: 'Combat in GUMSHOE is turn-based. You can attack, defend, or flee.',
                    command: 'combat',
                    hint: 'Use "combat" to see your current combat status.'
                },
                {
                    text: 'When in combat, use "attack [enemy]" to strike your opponent.',
                    command: 'attack [enemy]',
                    hint: 'Make sure to specify which enemy you want to attack.'
                },
                {
                    text: 'You can also defend to reduce incoming damage.',
                    command: 'defend',
                    hint: 'Defending reduces damage but doesn\'t attack back.'
                },
                {
                    text: 'If things get too dangerous, you can always flee.',
                    command: 'flee',
                    hint: 'Fleeing ends combat but may have consequences.'
                }
            ]
        });
        
        // Advanced achievement system
        const achievementSystem = {
            achievements: new Map(),
            unlockedAchievements: new Set(),
            
            registerAchievement: function(achievementName, achievementData) {
                this.achievements.set(achievementName, achievementData);
            },
            
            unlockAchievement: function(achievementName) {
                if (!this.achievements.has(achievementName)) {
                    console.error(`Unknown achievement: ${achievementName}`);
                    return;
                }
                
                if (this.unlockedAchievements.has(achievementName)) {
                    return; // Already unlocked
                }
                
                this.unlockedAchievements.add(achievementName);
                const achievement = this.achievements.get(achievementName);
                
                game.output(`\n🏆 ACHIEVEMENT UNLOCKED: ${achievement.title}`);
                game.output(`🎯 ${achievement.description}`);
                
                if (achievement.reward) {
                    game.output(`🎁 Reward: ${achievement.reward}`);
                }
            },
            
            checkAchievements: function() {
                // Check for various achievement conditions
                if (game.state.commandsExecuted >= 100 && !this.unlockedAchievements.has('command_master')) {
                    this.unlockAchievement('command_master');
                }
                
                if (game.state.roomsVisited >= 10 && !this.unlockedAchievements.has('explorer')) {
                    this.unlockAchievement('explorer');
                }
                
                if (game.state.npcsTalkedTo >= 5 && !this.unlockedAchievements.has('social_butterfly')) {
                    this.unlockAchievement('social_butterfly');
                }
                
                if (game.state.itemsCollected >= 20 && !this.unlockedAchievements.has('collector')) {
                    this.unlockAchievement('collector');
                }
            },
            
            listAchievements: function() {
                if (this.achievements.size === 0) {
                    game.output(`🏆 No achievements available.`);
                    return;
                }
                
                game.output(`🏆 ACHIEVEMENTS:`);
                for (const [name, achievement] of this.achievements) {
                    const status = this.unlockedAchievements.has(name) ? '✅' : '⭕';
                    game.output(`  ${status} ${achievement.title}`);
                    if (this.unlockedAchievements.has(name)) {
                        game.output(`     ${achievement.description}`);
                    }
                }
            }
        };
        
        // Register some achievements
        achievementSystem.registerAchievement('command_master', {
            title: 'Command Master',
            description: 'Execute 100 commands',
            reward: '+10 skill points'
        });
        
        achievementSystem.registerAchievement('explorer', {
            title: 'Explorer',
            description: 'Visit 10 different locations',
            reward: '+5 reputation with all factions'
        });
        
        achievementSystem.registerAchievement('social_butterfly', {
            title: 'Social Butterfly',
            description: 'Talk to 5 different NPCs',
            reward: '+3 persuasion skill'
        });
        
        achievementSystem.registerAchievement('collector', {
            title: 'Collector',
            description: 'Collect 20 different items',
            reward: '+5 inventory capacity'
        });
        
        // Add tutorial and achievement commands
        const originalProcessCommandTutorial = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'tutorials') {
                tutorialSystem.listTutorials();
                return;
            } else if (lowerCommand.startsWith('tutorial ')) {
                const tutorialName = command.substring(9);
                tutorialSystem.startTutorial(tutorialName);
                return;
            } else if (lowerCommand === 'next') {
                tutorialSystem.nextStep();
                return;
            } else if (lowerCommand === 'achievements') {
                achievementSystem.listAchievements();
                return;
            }
            
            return originalProcessCommandTutorial.call(this, command);
        };
        
        // Advanced music and sound system
        const audioSystem = {
            music: new Map(),
            sounds: new Map(),
            currentMusic: null,
            volume: 0.5,
            muted: false,
            
            registerMusic: function(trackName, trackData) {
                this.music.set(trackName, trackData);
            },
            
            registerSound: function(soundName, soundData) {
                this.sounds.set(soundName, soundData);
            },
            
            playMusic: function(trackName, loop = true) {
                if (this.muted) return;
                
                const track = this.music.get(trackName);
                if (!track) {
                    game.output(`❌ Music track not found: ${trackName}`);
                    return;
                }
                
                if (this.currentMusic) {
                    this.stopMusic();
                }
                
                this.currentMusic = trackName;
                game.output(`🎵 Now playing: ${track.title}`);
                
                // In a real implementation, you would play actual audio
                // For now, we'll just simulate it
                if (track.description) {
                    game.output(`📝 ${track.description}`);
                }
            },
            
            stopMusic: function() {
                if (this.currentMusic) {
                    game.output(`🎵 Music stopped`);
                    this.currentMusic = null;
                }
            },
            
            playSound: function(soundName) {
                if (this.muted) return;
                
                const sound = this.sounds.get(soundName);
                if (!sound) {
                    game.output(`❌ Sound not found: ${soundName}`);
                    return;
                }
                
                game.output(`🔊 ${sound.description}`);
            },
            
            setVolume: function(volume) {
                this.volume = Math.max(0, Math.min(1, volume));
                game.output(`🔊 Volume set to ${Math.floor(this.volume * 100)}%`);
            },
            
            toggleMute: function() {
                this.muted = !this.muted;
                game.output(`🔊 Audio ${this.muted ? 'muted' : 'unmuted'}`);
            },
            
            listMusic: function() {
                if (this.music.size === 0) {
                    game.output(`🎵 No music tracks available.`);
                    return;
                }
                
                game.output(`🎵 MUSIC TRACKS:`);
                for (const [name, track] of this.music) {
                    const status = this.currentMusic === name ? '▶️' : '⏸️';
                    game.output(`  ${status} ${name} - ${track.title}`);
                }
            },
            
            listSounds: function() {
                if (this.sounds.size === 0) {
                    game.output(`🔊 No sounds available.`);
                    return;
                }
                
                game.output(`🔊 SOUNDS:`);
                for (const [name, sound] of this.sounds) {
                    game.output(`  ${name} - ${sound.description}`);
                }
            }
        };
        
        // Register some music and sounds
        audioSystem.registerMusic('main_theme', {
            title: 'Main Theme',
            description: 'The haunting melody of the city streets'
        });
        
        audioSystem.registerMusic('combat_theme', {
            title: 'Combat Theme',
            description: 'Intense music for dangerous encounters'
        });
        
        audioSystem.registerMusic('mystery_theme', {
            title: 'Mystery Theme',
            description: 'Suspenseful music for investigation scenes'
        });
        
        audioSystem.registerSound('footsteps', {
            description: 'Footsteps on wet pavement'
        });
        
        audioSystem.registerSound('gunshot', {
            description: 'A gunshot rings out'
        });
        
        audioSystem.registerSound('door_creak', {
            description: 'A door creaks open'
        });
        
        audioSystem.registerSound('rain', {
            description: 'Rain falling on the streets'
        });
        
        // Advanced notification system
        const notificationSystem = {
            notifications: [],
            maxNotifications: 10,
            
            addNotification: function(type, title, message, duration = 5000) {
                const notification = {
                    id: Date.now(),
                    type: type,
                    title: title,
                    message: message,
                    timestamp: Date.now(),
                    duration: duration
                };
                
                this.notifications.unshift(notification);
                
                // Limit number of notifications
                if (this.notifications.length > this.maxNotifications) {
                    this.notifications = this.notifications.slice(0, this.maxNotifications);
                }
                
                this.displayNotification(notification);
            },
            
            displayNotification: function(notification) {
                const typeEmoji = {
                    'info': 'ℹ️',
                    'success': '✅',
                    'warning': '⚠️',
                    'error': '❌',
                    'achievement': '🏆',
                    'quest': '📋',
                    'combat': '⚔️',
                    'item': '🎒'
                };
                
                const emoji = typeEmoji[notification.type] || '📢';
                game.output(`\n${emoji} ${notification.title}`);
                game.output(`   ${notification.message}`);
            },
            
            listNotifications: function() {
                if (this.notifications.length === 0) {
                    game.output(`📢 No notifications.`);
                    return;
                }
                
                game.output(`📢 RECENT NOTIFICATIONS:`);
                this.notifications.slice(0, 5).forEach(notification => {
                    const timeAgo = Math.floor((Date.now() - notification.timestamp) / 1000);
                    const typeEmoji = {
                        'info': 'ℹ️',
                        'success': '✅',
                        'warning': '⚠️',
                        'error': '❌',
                        'achievement': '🏆',
                        'quest': '📋',
                        'combat': '⚔️',
                        'item': '🎒'
                    };
                    const emoji = typeEmoji[notification.type] || '📢';
                    game.output(`  ${emoji} ${notification.title} (${timeAgo}s ago)`);
                });
            },
            
            clearNotifications: function() {
                this.notifications = [];
                game.output(`📢 All notifications cleared.`);
            }
        };
        
        // Add audio and notification commands
        const originalProcessCommandAudio = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand === 'music') {
                audioSystem.listMusic();
                return;
            } else if (lowerCommand.startsWith('play ')) {
                const trackName = command.substring(5);
                audioSystem.playMusic(trackName);
                return;
            } else if (lowerCommand === 'stop') {
                audioSystem.stopMusic();
                return;
            } else if (lowerCommand === 'sounds') {
                audioSystem.listSounds();
                return;
            } else if (lowerCommand.startsWith('sound ')) {
                const soundName = command.substring(6);
                audioSystem.playSound(soundName);
                return;
            } else if (lowerCommand.startsWith('volume ')) {
                const volume = parseFloat(command.substring(7));
                audioSystem.setVolume(volume);
                return;
            } else if (lowerCommand === 'mute') {
                audioSystem.toggleMute();
                return;
            } else if (lowerCommand === 'notifications') {
                notificationSystem.listNotifications();
                return;
            } else if (lowerCommand === 'clear') {
                notificationSystem.clearNotifications();
                return;
            }
            
            return originalProcessCommandAudio.call(this, command);
        };
        
        // Advanced screenshot and recording system
        const recordingSystem = {
            screenshots: [],
            recordings: [],
            maxScreenshots: 50,
            maxRecordings: 10,
            
            takeScreenshot: function(description = '') {
                const screenshot = {
                    id: Date.now(),
                    timestamp: Date.now(),
                    description: description,
                    gameState: {
                        location: game.state.currentLocation,
                        inventory: game.state.inventory,
                        health: game.state.health,
                        cash: game.state.cash,
                        debt: game.state.debt
                    }
                };
                
                this.screenshots.unshift(screenshot);
                
                // Limit number of screenshots
                if (this.screenshots.length > this.maxScreenshots) {
                    this.screenshots = this.screenshots.slice(0, this.maxScreenshots);
                }
                
                game.output(`📸 Screenshot taken: ${description || 'Untitled'}`);
                notificationSystem.addNotification('info', 'Screenshot Saved', `Screenshot "${description || 'Untitled'}" has been saved.`);
            },
            
            startRecording: function(description = '') {
                const recording = {
                    id: Date.now(),
                    timestamp: Date.now(),
                    description: description,
                    startTime: Date.now(),
                    isRecording: true,
                    events: []
                };
                
                this.recordings.unshift(recording);
                
                // Limit number of recordings
                if (this.recordings.length > this.maxRecordings) {
                    this.recordings = this.recordings.slice(0, this.maxRecordings);
                }
                
                game.output(`🎬 Recording started: ${description || 'Untitled'}`);
                notificationSystem.addNotification('info', 'Recording Started', `Recording "${description || 'Untitled'}" has been started.`);
            },
            
            stopRecording: function() {
                const activeRecording = this.recordings.find(r => r.isRecording);
                if (!activeRecording) {
                    game.output(`❌ No active recording to stop.`);
                    return;
                }
                
                activeRecording.isRecording = false;
                activeRecording.endTime = Date.now();
                activeRecording.duration = activeRecording.endTime - activeRecording.startTime;
                
                game.output(`🎬 Recording stopped: ${activeRecording.description || 'Untitled'}`);
                game.output(`⏱️ Duration: ${Math.floor(activeRecording.duration / 1000)}s`);
                notificationSystem.addNotification('info', 'Recording Stopped', `Recording "${activeRecording.description || 'Untitled'}" has been stopped.`);
            },
            
            listScreenshots: function() {
                if (this.screenshots.length === 0) {
                    game.output(`📸 No screenshots available.`);
                    return;
                }
                
                game.output(`📸 SCREENSHOTS:`);
                this.screenshots.slice(0, 10).forEach(screenshot => {
                    const timeAgo = Math.floor((Date.now() - screenshot.timestamp) / 1000);
                    game.output(`  📸 ${screenshot.description || 'Untitled'} (${timeAgo}s ago)`);
                });
            },
            
            listRecordings: function() {
                if (this.recordings.length === 0) {
                    game.output(`🎬 No recordings available.`);
                    return;
                }
                
                game.output(`🎬 RECORDINGS:`);
                this.recordings.slice(0, 10).forEach(recording => {
                    const timeAgo = Math.floor((Date.now() - recording.timestamp) / 1000);
                    const status = recording.isRecording ? '🔴' : '⏹️';
                    const duration = recording.duration ? ` (${Math.floor(recording.duration / 1000)}s)` : '';
                    game.output(`  ${status} ${recording.description || 'Untitled'} (${timeAgo}s ago)${duration}`);
                });
            },
            
            clearScreenshots: function() {
                this.screenshots = [];
                game.output(`📸 All screenshots cleared.`);
            },
            
            clearRecordings: function() {
                this.recordings = [];
                game.output(`🎬 All recordings cleared.`);
            }
        };
        
        // Advanced macro system
        const macroSystem = {
            macros: new Map(),
            maxMacros: 20,
            
            createMacro: function(name, commands) {
                if (this.macros.size >= this.maxMacros) {
                    game.output(`❌ Maximum number of macros reached (${this.maxMacros}).`);
                    return;
                }
                
                if (this.macros.has(name)) {
                    game.output(`❌ Macro "${name}" already exists.`);
                    return;
                }
                
                this.macros.set(name, {
                    name: name,
                    commands: commands,
                    created: Date.now(),
                    uses: 0
                });
                
                game.output(`📝 Macro "${name}" created with ${commands.length} commands.`);
                notificationSystem.addNotification('success', 'Macro Created', `Macro "${name}" has been created successfully.`);
            },
            
            executeMacro: function(name) {
                const macro = this.macros.get(name);
                if (!macro) {
                    game.output(`❌ Macro "${name}" not found.`);
                    return;
                }
                
                game.output(`🎯 Executing macro: ${name}`);
                macro.uses++;
                
                // Execute each command with a small delay
                macro.commands.forEach((command, index) => {
                    setTimeout(() => {
                        game.processCommand(command);
                    }, index * 100); // 100ms delay between commands
                });
                
                notificationSystem.addNotification('info', 'Macro Executed', `Macro "${name}" has been executed (${macro.uses} uses).`);
            },
            
            listMacros: function() {
                if (this.macros.size === 0) {
                    game.output(`📝 No macros available.`);
                    return;
                }
                
                game.output(`📝 MACROS:`);
                for (const [name, macro] of this.macros) {
                    game.output(`  📝 ${name} - ${macro.commands.length} commands (${macro.uses} uses)`);
                }
            },
            
            deleteMacro: function(name) {
                if (!this.macros.has(name)) {
                    game.output(`❌ Macro "${name}" not found.`);
                    return;
                }
                
                this.macros.delete(name);
                game.output(`📝 Macro "${name}" deleted.`);
                notificationSystem.addNotification('info', 'Macro Deleted', `Macro "${name}" has been deleted.`);
            },
            
            clearMacros: function() {
                this.macros.clear();
                game.output(`📝 All macros cleared.`);
            }
        };
        
        // Add recording and macro commands
        const originalProcessCommandRecording = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('screenshot ')) {
                const description = command.substring(11);
                recordingSystem.takeScreenshot(description);
                return;
            } else if (lowerCommand === 'screenshots') {
                recordingSystem.listScreenshots();
                return;
            } else if (lowerCommand.startsWith('record ')) {
                const description = command.substring(7);
                recordingSystem.startRecording(description);
                return;
            } else if (lowerCommand === 'stop') {
                recordingSystem.stopRecording();
                return;
            } else if (lowerCommand === 'recordings') {
                recordingSystem.listRecordings();
                return;
            } else if (lowerCommand === 'clear screenshots') {
                recordingSystem.clearScreenshots();
                return;
            } else if (lowerCommand === 'clear recordings') {
                recordingSystem.clearRecordings();
                return;
            } else if (lowerCommand.startsWith('macro ')) {
                const parts = command.substring(6).split(' ');
                const action = parts[0];
                const name = parts[1];
                
                if (action === 'create') {
                    const commands = parts.slice(2).join(' ').split(';').map(cmd => cmd.trim());
                    macroSystem.createMacro(name, commands);
                } else if (action === 'execute') {
                    macroSystem.executeMacro(name);
                } else if (action === 'delete') {
                    macroSystem.deleteMacro(name);
                } else {
                    game.output(`❌ Unknown macro action: ${action}`);
                }
                return;
            } else if (lowerCommand === 'macros') {
                macroSystem.listMacros();
                return;
            } else if (lowerCommand === 'clear macros') {
                macroSystem.clearMacros();
                return;
            }
            
            return originalProcessCommandRecording.call(this, command);
        };
        
        // Advanced plugin system
        const pluginSystem = {
            plugins: new Map(),
            maxPlugins: 50,
            
            loadPlugin: function(pluginName, pluginCode) {
                if (this.plugins.size >= this.maxPlugins) {
                    game.output(`❌ Maximum number of plugins reached (${this.maxPlugins}).`);
                    return;
                }
                
                if (this.plugins.has(pluginName)) {
                    game.output(`❌ Plugin "${pluginName}" already loaded.`);
                    return;
                }
                
                try {
                    // Create a safe execution context
                    const pluginContext = {
                        game: game,
                        console: console,
                        Date: Date,
                        Math: Math,
                        JSON: JSON,
                        setTimeout: setTimeout,
                        setInterval: setInterval,
                        clearTimeout: clearTimeout,
                        clearInterval: clearInterval
                    };
                    
                    // Execute plugin code in safe context
                    const pluginFunction = new Function('context', `
                        with (context) {
                            ${pluginCode}
                        }
                    `);
                    
                    const pluginInstance = pluginFunction(pluginContext);
                    
                    this.plugins.set(pluginName, {
                        name: pluginName,
                        instance: pluginInstance,
                        loaded: Date.now(),
                        enabled: true
                    });
                    
                    game.output(`🔌 Plugin "${pluginName}" loaded successfully.`);
                    notificationSystem.addNotification('success', 'Plugin Loaded', `Plugin "${pluginName}" has been loaded successfully.`);
                } catch (error) {
                    game.output(`❌ Failed to load plugin "${pluginName}": ${error.message}`);
                    notificationSystem.addNotification('error', 'Plugin Error', `Failed to load plugin "${pluginName}": ${error.message}`);
                }
            },
            
            unloadPlugin: function(pluginName) {
                if (!this.plugins.has(pluginName)) {
                    game.output(`❌ Plugin "${pluginName}" not found.`);
                    return;
                }
                
                this.plugins.delete(pluginName);
                game.output(`🔌 Plugin "${pluginName}" unloaded.`);
                notificationSystem.addNotification('info', 'Plugin Unloaded', `Plugin "${pluginName}" has been unloaded.`);
            },
            
            listPlugins: function() {
                if (this.plugins.size === 0) {
                    game.output(`🔌 No plugins loaded.`);
                    return;
                }
                
                game.output(`🔌 LOADED PLUGINS:`);
                for (const [name, plugin] of this.plugins) {
                    const status = plugin.enabled ? '✅' : '❌';
                    game.output(`  ${status} ${name} (loaded ${Math.floor((Date.now() - plugin.loaded) / 1000)}s ago)`);
                }
            },
            
            enablePlugin: function(pluginName) {
                const plugin = this.plugins.get(pluginName);
                if (!plugin) {
                    game.output(`❌ Plugin "${pluginName}" not found.`);
                    return;
                }
                
                plugin.enabled = true;
                game.output(`🔌 Plugin "${pluginName}" enabled.`);
                notificationSystem.addNotification('info', 'Plugin Enabled', `Plugin "${pluginName}" has been enabled.`);
            },
            
            disablePlugin: function(pluginName) {
                const plugin = this.plugins.get(pluginName);
                if (!plugin) {
                    game.output(`❌ Plugin "${pluginName}" not found.`);
                    return;
                }
                
                plugin.enabled = false;
                game.output(`🔌 Plugin "${pluginName}" disabled.`);
                notificationSystem.addNotification('info', 'Plugin Disabled', `Plugin "${pluginName}" has been disabled.`);
            },
            
            clearPlugins: function() {
                this.plugins.clear();
                game.output(`🔌 All plugins cleared.`);
            }
        };
        
        // Advanced scripting system
        const scriptingSystem = {
            scripts: new Map(),
            maxScripts: 100,
            
            createScript: function(scriptName, scriptCode) {
                if (this.scripts.size >= this.maxScripts) {
                    game.output(`❌ Maximum number of scripts reached (${this.maxScripts}).`);
                    return;
                }
                
                if (this.scripts.has(scriptName)) {
                    game.output(`❌ Script "${scriptName}" already exists.`);
                    return;
                }
                
                this.scripts.set(scriptName, {
                    name: scriptName,
                    code: scriptCode,
                    created: Date.now(),
                    runs: 0
                });
                
                game.output(`📜 Script "${scriptName}" created successfully.`);
                notificationSystem.addNotification('success', 'Script Created', `Script "${scriptName}" has been created successfully.`);
            },
            
            runScript: function(scriptName) {
                const script = this.scripts.get(scriptName);
                if (!script) {
                    game.output(`❌ Script "${scriptName}" not found.`);
                    return;
                }
                
                try {
                    // Create a safe execution context
                    const scriptContext = {
                        game: game,
                        console: console,
                        Date: Date,
                        Math: Math,
                        JSON: JSON,
                        setTimeout: setTimeout,
                        setInterval: setInterval,
                        clearTimeout: clearTimeout,
                        clearInterval: clearInterval
                    };
                    
                    // Execute script code in safe context
                    const scriptFunction = new Function('context', `
                        with (context) {
                            ${script.code}
                        }
                    `);
                    
                    scriptFunction(scriptContext);
                    script.runs++;
                    
                    game.output(`📜 Script "${scriptName}" executed successfully.`);
                    notificationSystem.addNotification('info', 'Script Executed', `Script "${scriptName}" has been executed (${script.runs} runs).`);
                } catch (error) {
                    game.output(`❌ Failed to execute script "${scriptName}": ${error.message}`);
                    notificationSystem.addNotification('error', 'Script Error', `Failed to execute script "${scriptName}": ${error.message}`);
                }
            },
            
            listScripts: function() {
                if (this.scripts.size === 0) {
                    game.output(`📜 No scripts available.`);
                    return;
                }
                
                game.output(`📜 SCRIPTS:`);
                for (const [name, script] of this.scripts) {
                    game.output(`  📜 ${name} - ${script.runs} runs`);
                }
            },
            
            deleteScript: function(scriptName) {
                if (!this.scripts.has(scriptName)) {
                    game.output(`❌ Script "${scriptName}" not found.`);
                    return;
                }
                
                this.scripts.delete(scriptName);
                game.output(`📜 Script "${scriptName}" deleted.`);
                notificationSystem.addNotification('info', 'Script Deleted', `Script "${scriptName}" has been deleted.`);
            },
            
            clearScripts: function() {
                this.scripts.clear();
                game.output(`📜 All scripts cleared.`);
            }
        };
        
        // Add plugin and scripting commands
        const originalProcessCommandPlugin = game.processCommand;
        game.processCommand = function(command) {
            const lowerCommand = command.toLowerCase().trim();
            
            if (lowerCommand.startsWith('plugin load ')) {
                const parts = command.substring(12).split(' ');
                const pluginName = parts[0];
                const pluginCode = parts.slice(1).join(' ');
                pluginSystem.loadPlugin(pluginName, pluginCode);
                return;
            } else if (lowerCommand.startsWith('plugin unload ')) {
                const pluginName = command.substring(14);
                pluginSystem.unloadPlugin(pluginName);
                return;
            } else if (lowerCommand === 'plugins') {
                pluginSystem.listPlugins();
                return;
            } else if (lowerCommand.startsWith('plugin enable ')) {
                const pluginName = command.substring(14);
                pluginSystem.enablePlugin(pluginName);
                return;
            } else if (lowerCommand.startsWith('plugin disable ')) {
                const pluginName = command.substring(15);
                pluginSystem.disablePlugin(pluginName);
                return;
            } else if (lowerCommand === 'clear plugins') {
                pluginSystem.clearPlugins();
                return;
            } else if (lowerCommand.startsWith('script create ')) {
                const parts = command.substring(14).split(' ');
                const scriptName = parts[0];
                const scriptCode = parts.slice(1).join(' ');
                scriptingSystem.createScript(scriptName, scriptCode);
                return;
            } else if (lowerCommand.startsWith('script run ')) {
                const scriptName = command.substring(11);
                scriptingSystem.runScript(scriptName);
                return;
            } else if (lowerCommand === 'scripts') {
                scriptingSystem.listScripts();
                return;
            } else if (lowerCommand.startsWith('script delete ')) {
                const scriptName = command.substring(14);
                scriptingSystem.deleteScript(scriptName);
                return;
            } else if (lowerCommand === 'clear scripts') {
                scriptingSystem.clearScripts();
                return;
            }
            
            return originalProcessCommandPlugin.call(this, command);
        };
        
        // Load game data from server (only if not in localhost mode)
        if (API_BASE_URL) {
            (async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/games/data/noir`);
                    const result = await response.json();
                    
                    if (result.gameConfig) {
                        // Replace the original game.data with server data
                        game.data = result.gameConfig;
                        console.log('Game data loaded from server successfully');
                    } else {
                        console.error('Failed to load game data from server:', result.error?.message || 'Unknown error');
                    }
                } catch (error) {
                    console.error('Error loading game data from server:', error);
                }
            })();
        } else {
            console.log('Running in localhost mode - using local game data');
        }
        
        // --- 8-BIT BACKGROUND MUSIC ---
        class EightBitMusic {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.isMuted = false;
                this.currentMelody = null;
                this.mood = 'neutral'; // neutral, tense, mysterious, dangerous, triumphant
                this.intensity = 0.5; // 0-1 scale for dynamic intensity
                this.bpm = 120; // Base tempo
                this.lastLocation = null;
                this.gameState = null;
                this.patterns = this.initializePatterns();
                this.harmonies = this.initializeHarmonies();
                this.initAudio();
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }
            
            initializePatterns() {
                return {
                    // Base noir patterns with mood variations
                    noir_base: [
                        { freq: 220, duration: 0.5, intensity: 0.3 },
                        { freq: 196, duration: 0.5, intensity: 0.3 },
                        { freq: 174, duration: 0.5, intensity: 0.3 },
                        { freq: 196, duration: 0.5, intensity: 0.3 },
                        { freq: 220, duration: 0.5, intensity: 0.3 },
                        { freq: 246, duration: 0.5, intensity: 0.3 },
                        { freq: 220, duration: 1.0, intensity: 0.4 }
                    ],
                    noir_tense: [
                        { freq: 247, duration: 0.25, intensity: 0.6 },
                        { freq: 220, duration: 0.25, intensity: 0.6 },
                        { freq: 196, duration: 0.25, intensity: 0.6 },
                        { freq: 185, duration: 0.25, intensity: 0.6 },
                        { freq: 174, duration: 0.5, intensity: 0.7 },
                        { freq: 0, duration: 0.25, intensity: 0.2 },
                        { freq: 165, duration: 0.5, intensity: 0.8 }
                    ],
                    noir_mysterious: [
                        { freq: 330, duration: 0.75, intensity: 0.2 },
                        { freq: 294, duration: 0.25, intensity: 0.3 },
                        { freq: 262, duration: 0.5, intensity: 0.4 },
                        { freq: 0, duration: 0.25, intensity: 0.1 },
                        { freq: 294, duration: 0.5, intensity: 0.3 },
                        { freq: 330, duration: 1.0, intensity: 0.5 }
                    ],
                    noir_dangerous: [
                        { freq: 185, duration: 0.125, intensity: 0.9 },
                        { freq: 175, duration: 0.125, intensity: 0.9 },
                        { freq: 165, duration: 0.125, intensity: 0.9 },
                        { freq: 155, duration: 0.125, intensity: 0.9 },
                        { freq: 146, duration: 0.25, intensity: 1.0 },
                        { freq: 0, duration: 0.125, intensity: 0.1 },
                        { freq: 146, duration: 0.25, intensity: 1.0 }
                    ],
                    noir_triumphant: [
                        { freq: 330, duration: 0.25, intensity: 0.7 },
                        { freq: 370, duration: 0.25, intensity: 0.8 },
                        { freq: 415, duration: 0.25, intensity: 0.9 },
                        { freq: 440, duration: 0.25, intensity: 1.0 },
                        { freq: 494, duration: 0.5, intensity: 0.8 },
                        { freq: 523, duration: 0.5, intensity: 0.7 }
                    ]
                };
            }

            initializeHarmonies() {
                return {
                    minor: [0, 3, 7, 10, 14], // Minor pentatonic
                    major: [0, 4, 7, 11, 14], // Major pentatonic
                    diminished: [0, 3, 6, 9], // Diminished
                    chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] // Chromatic
                };
            }

            // Dynamic melody generation based on game state and mood
            generateDynamicMelody() {
                const basePattern = this.patterns[`noir_${this.mood}`] || this.patterns.noir_base;
                const melody = [...basePattern];

                // Add intensity-based variations
                if (this.intensity > 0.7) {
                    // Add more complex rhythms and higher notes for tension
                    melody.forEach((note, index) => {
                        if (Math.random() < this.intensity * 0.3) {
                            melody[index] = {
                                ...note,
                                freq: note.freq * (1 + Math.random() * 0.2),
                                duration: note.duration * (0.8 + Math.random() * 0.4)
                            };
                        }
                    });
                }

                // Add mood-specific variations
                if (this.mood === 'mysterious') {
                    // Add more pauses and lower intensity notes
                    melody.splice(2, 0, { freq: 0, duration: 0.5, intensity: 0.1 });
                } else if (this.mood === 'dangerous') {
                    // Add rapid, intense notes
                    melody.splice(3, 0, { freq: 185, duration: 0.125, intensity: 0.9 });
                    melody.splice(6, 0, { freq: 175, duration: 0.125, intensity: 0.9 });
                }
                
                return melody;
            }
            
            // Context-aware melody selection based on location and game state
            selectMoodBasedMelody() {
                if (!this.gameState) return this.generateDynamicMelody();

                const currentRoom = this.gameState.worldMap[`${this.gameState.playerPos.x},${this.gameState.playerPos.y},${this.gameState.playerPos.z}`];

                // Location-based mood changes
                if (currentRoom && currentRoom.name) {
                    const roomName = currentRoom.name.toLowerCase();

                    if (roomName.includes('dock') || roomName.includes('warehouse')) {
                        this.mood = 'mysterious';
                        this.intensity = 0.6;
                    } else if (roomName.includes('office') || roomName.includes('home')) {
                        this.mood = 'neutral';
                        this.intensity = 0.4;
                    } else if (roomName.includes('bar') || roomName.includes('street')) {
                        this.mood = 'tense';
                        this.intensity = 0.5;
                    } else if (roomName.includes('lab') || roomName.includes('xai')) {
                        this.mood = 'dangerous';
                        this.intensity = 0.8;
                    }
                }

                // Game state-based intensity
                const caseState = this.gameState.gameState?.blackwoodCase;
                if (caseState) {
                    const evidenceCount = caseState.evidenceCollected?.length || 0;
                    this.intensity = Math.min(0.3 + (evidenceCount * 0.1), 0.9);

                    if (evidenceCount >= 3) {
                        this.mood = 'triumphant';
                    }
                }

                return this.generateDynamicMelody();
            }
            
            generateNoirMelody() {
                // Use the new dynamic, context-aware melody generation
                return this.selectMoodBasedMelody();
            }
            
            playNote(frequency, duration, startTime = 0, intensity = 0.5) {
                if (!this.audioContext || this.isMuted) return;
                
                if (frequency === 0) return; // Rest
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filterNode = this.audioContext.createBiquadFilter();
                
                oscillator.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime + startTime);
                oscillator.type = 'square'; // 8-bit sound
                
                // Dynamic filter based on mood
                if (this.mood === 'mysterious') {
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(800, this.audioContext.currentTime + startTime);
                } else if (this.mood === 'dangerous') {
                    filterNode.type = 'highpass';
                    filterNode.frequency.setValueAtTime(2000, this.audioContext.currentTime + startTime);
                } else {
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(3000, this.audioContext.currentTime + startTime);
                }

                // Dynamic volume based on intensity
                const baseVolume = 0.08;
                const volumeMultiplier = 0.5 + (intensity * 0.5); // 0.5 to 1.0 range
                const finalVolume = baseVolume * volumeMultiplier;

                gainNode.gain.setValueAtTime(finalVolume, this.audioContext.currentTime + startTime);
                gainNode.gain.exponentialRampToValueAtTime(finalVolume * 0.3, this.audioContext.currentTime + startTime + duration);
                
                oscillator.start(this.audioContext.currentTime + startTime);
                oscillator.stop(this.audioContext.currentTime + startTime + duration);
            }
            
            playMelody() {
                if (!this.audioContext || this.isPlaying || this.isMuted) return;
                
                this.isPlaying = true;
                const melody = this.generateNoirMelody();
                let currentTime = 0;
                
                melody.forEach(note => {
                    // Use the intensity from the note if available, otherwise use the global intensity
                    const noteIntensity = note.intensity !== undefined ? note.intensity : this.intensity;
                    this.playNote(note.freq, note.duration, currentTime, noteIntensity);
                    currentTime += note.duration;
                });
                
                // Loop the melody with slight variation
                setTimeout(() => {
                    this.isPlaying = false;
                    if (this.audioContext.state === 'running' && !this.isMuted) {
                        this.playMelody();
                    }
                }, currentTime * 1000);
            }
            
            start() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                this.isMuted = false; // Start unmuted for better user experience
                this.playMelody();
            }
            
            stop() {
                if (this.audioContext) {
                    this.audioContext.suspend();
                }
                this.isPlaying = false;
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                const muteBtn = document.getElementById('mute-btn');
                if (muteBtn) {
                    muteBtn.classList.toggle('muted', this.isMuted);
                    muteBtn.innerHTML = this.isMuted ? 
                        '<i class="fas fa-volume-mute"></i> Unmute' : 
                        '<i class="fas fa-volume-up"></i> Mute';
                }
                
                if (this.isMuted) {
                    this.stop();
                } else if (this.audioContext && this.audioContext.state === 'running') {
                    this.start();
                }
            }

            // Method to update music based on game state changes
            updateFromGameState(gameState) {
                this.gameState = gameState;
                // Music will automatically adapt on next melody generation
            }

            // Method to trigger immediate mood change (for dramatic events)
            setMood(mood, intensity = null) {
                this.mood = mood;
                if (intensity !== null) {
                    this.intensity = intensity;
                }
                // Restart melody with new mood
                if (this.isPlaying) {
                    this.stop();
                    setTimeout(() => this.start(), 100);
                }
            }
        }
        
        // Initialize music
        const music = new EightBitMusic();
        
        // Global mute function
        function toggleMute() {
            music.toggleMute();
        }
        
        // Start music after user interaction
        document.addEventListener('click', () => {
            if (music.audioContext && music.audioContext.state === 'suspended') {
                music.start();
            }
        }, { once: true });
        
        // Also start music on any keypress
        document.addEventListener('keydown', () => {
            if (music.audioContext && music.audioContext.state === 'suspended') {
                music.start();
            }
        }, { once: true });
        
        // Start music when page loads (if browser allows)
        document.addEventListener('DOMContentLoaded', () => {
            // Try to start music immediately
            if (music.audioContext && music.audioContext.state === 'running') {
                music.start();
            }
        });
        
        // Start music when menu is interacted with
        document.getElementById('menu-overlay').addEventListener('click', () => {
            if (music.audioContext && music.audioContext.state === 'suspended') {
                music.start();
            }
        }, { once: true });
        
        // Test if game object was created successfully
        console.log('🔍 DEBUG: Testing game object...');
        try {
            if (typeof game !== 'undefined') {
                console.log('✅ DEBUG: Game object created successfully!', typeof game);
                console.log('🔍 DEBUG: Game object keys:', Object.keys(game));
            } else {
                console.error('🚨 DEBUG: Game object is undefined!');
            }
        } catch(e) {
            console.error('🚨 DEBUG: Error testing game object:', e.message);
        }
        
        console.log('🔍 DEBUG: All debug checks completed!');
    </script>
</body>
</html>


