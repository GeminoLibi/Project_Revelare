{% extends "base.html" %}

{% block title %}Fractal Encryption - Project Revelare{% endblock %}

{% block content %}
<div class="fractal-encryption">
    <div class="page-header">
        <h1><i class="fas fa-snowflake"></i> Fractal Encryption</h1>
        <p>Encode any file into the structure and color of an Iterated Function System (IFS) fractal.</p>
    </div>

    <div class="fractal-grid">
        <div class="card">
            <h2>Controls</h2>
            <div class="form-group">
                <label for="fileInput">1. Select Input File</label>
                <div class="file-upload-area" id="file-upload-area">
                    <span id="fileInputText">Click to select a file...</span>
                    <input type="file" id="fileInput">
                </div>
            </div>

            <div class="form-group">
                <label>2. Encryption Key (IFS Coefficients)</label>
                <div class="key-controls">
                    <button id="generateKeyBtn" class="btn btn-sm btn-primary">Generate Random</button>
                    <button id="importKeyBtn" class="btn btn-sm btn-outline">Import Key</button>
                    <button id="exportKeyBtn" class="btn btn-sm btn-outline">Export Key</button>
                    <button id="resetKeyBtn" class="btn btn-sm btn-outline">Reset Default</button>
                </div>
                <div id="ifs-editor"></div>
            </div>

            <div class="form-group">
                <label>3. Actions</label>
                <div class="action-grid">
                    <button id="encryptBtn" class="btn btn-primary"><i class="fas fa-lock"></i> Encrypt & Draw</button>
                    <button id="decryptBtn" class="btn btn-success"><i class="fas fa-unlock"></i> Decrypt Canvas</button>
                    <button id="downloadPNGBtn" class="btn btn-outline"><i class="fas fa-image"></i> Download PNG</button>
                    <button id="loadImageBtn" class="btn btn-outline"><i class="fas fa-upload"></i> Decrypt from PNG</button>
                </div>
                <input type="file" id="loadImageInput" class="hidden-input" accept=".png">
            </div>

            <div id="progress-container" style="display: none;">
                <div id="status" class="help-text" style="text-align: center;"></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-bar-fill" style="width: 0%;"></div>
                </div>
                <button id="cancelBtn" class="btn btn-danger" style="width: 100%; margin-top: 1rem;">Cancel</button>
            </div>
        </div>

        <div class="card canvas-container">
            <canvas id="fractalCanvas"></canvas>
        </div>
    </div>
</div>

<style>
    .fractal-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; align-items: flex-start; }
    .canvas-container { display: flex; align-items: center; justify-content: center; padding: 1rem; }
    #fractalCanvas { background: #000; border-radius: 8px; max-width: 100%; }
    .key-controls { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem; }
    #ifs-editor .transform-grid { display: grid; grid-template-columns: auto repeat(6, 1fr); gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; }
    #ifs-editor input { width: 100%; padding: 0.25rem; font-size: 0.8rem; text-align: center; }
    .action-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
    .hidden-input { display: none; }
    .progress-bar { width: 100%; height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; margin-top: 0.5rem; }
    .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.3s ease; }
    @media (max-width: 992px) { .fractal-grid { grid-template-columns: 1fr; } }
</style>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('fractalCanvas');
    const ctx = canvas.getContext('2d');
    const ifsEditor = document.getElementById('ifs-editor');
    const fileInput = document.getElementById('fileInput');
    const fileInputText = document.getElementById('fileInputText');
    const encryptBtn = document.getElementById('encryptBtn');
    const decryptBtn = document.getElementById('decryptBtn');
    const downloadPNGBtn = document.getElementById('downloadPNGBtn');
    const loadImageBtn = document.getElementById('loadImageBtn');
    const loadImageInput = document.getElementById('loadImageInput');
    const generateKeyBtn = document.getElementById('generateKeyBtn');
    const importKeyBtn = document.getElementById('importKeyBtn');
    const exportKeyBtn = document.getElementById('exportKeyBtn');
    const resetKeyBtn = document.getElementById('resetKeyBtn');
    const progressContainer = document.getElementById('progress-container');
    const statusEl = document.getElementById('status');
    const progressBarFill = document.getElementById('progress-bar-fill');
    const cancelBtn = document.getElementById('cancelBtn');

    let ifs = [];
    let encryptedData = { points: [] };
    let cancelRequested = false;
    let currentProcess = null;

    const BARNSLEY_FERN = [
        { a: 0, b: 0, c: 0, d: 0.16, e: 0, f: 0 },
        { a: 0.85, b: 0.04, c: -0.04, d: 0.85, e: 0, f: 1.60 },
        { a: 0.20, b: -0.26, c: 0.23, d: 0.22, e: 0, f: 1.60 },
        { a: -0.15, b: 0.28, c: 0.26, d: 0.24, e: 0, f: 0.44 }
    ];

    function setupCanvas() {
        const size = Math.min(canvas.parentElement.clientWidth, 600);
        canvas.width = size;
        canvas.height = size;
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function createIfsEditor(transforms = BARNSLEY_FERN) {
        ifsEditor.innerHTML = '';
        const header = document.createElement('div');
        header.className = 'transform-grid';
        header.innerHTML = `<span></span><strong>a</strong><strong>b</strong><strong>c</strong><strong>d</strong><strong>e</strong><strong>f</strong>`;
        ifsEditor.appendChild(header);
        transforms.forEach((t, i) => {
            const row = document.createElement('div');
            row.className = 'transform-grid';
            row.innerHTML = `<strong>w<sub>${i + 1}</sub></strong>` + Object.keys(t).map(p => `<input type="number" step="0.01" data-param="${p}" value="${t[p]}">`).join('');
            ifsEditor.appendChild(row);
        });
    }

    function updateIfsFromUI() {
        ifs = [];
        ifsEditor.querySelectorAll('.transform-grid:not(:first-child)').forEach(row => {
            const t = {};
            row.querySelectorAll('input').forEach(input => t[input.dataset.param] = parseFloat(input.value));
            ifs.push(t);
        });
    }

    function setProcessingState(isProcessing) {
        progressContainer.style.display = isProcessing ? 'block' : 'none';
        encryptBtn.parentElement.parentElement.style.display = isProcessing ? 'none' : 'block';
        cancelRequested = false;
    }

    function updateProgress(processed, total, task) {
        const percentage = total > 0 ? (processed / total) * 100 : 0;
        statusEl.textContent = `${task}: ${Math.round(percentage)}%`;
        progressBarFill.style.width = `${percentage}%`;
    }

    function startEncryption() {
        const file = fileInput.files[0];
        if (!file) { alert("Please select a file first."); return; }
        setProcessingState(true);
        updateProgress(0, 0, 'Reading file');
        const reader = new FileReader();
        reader.onload = e => {
            let bitStream = Array.from(new Uint8Array(e.target.result)).map(byte => byte.toString(2).padStart(8, '0')).join('');
            const remainder = bitStream.length % 26;
            if (remainder !== 0) bitStream += '0'.repeat(26 - remainder);
            
            setupCanvas();
            encryptedData = { originalFilename: file.name, points: [] };
            updateIfsFromUI();
            processEncryptionChunk(bitStream, 0, { x: 0, y: 0 });
        };
        reader.readAsArrayBuffer(file);
    }

    function processEncryptionChunk(bitStream, bitIndex, currentPoint) {
        if (cancelRequested) { setProcessingState(false); return; }
        const CHUNK_SIZE = 5000;
        const endBitIndex = Math.min(bitIndex + (CHUNK_SIZE * 26), bitStream.length);
        let point = currentPoint;

        for (let i = bitIndex; i < endBitIndex; i += 26) {
            const transformIndex = parseInt(bitStream.substr(i, 2), 2);
            const r = parseInt(bitStream.substr(i + 2, 8), 2);
            const g = parseInt(bitStream.substr(i + 10, 8), 2);
            const b = parseInt(bitStream.substr(i + 18, 8), 2);

            const w = ifs[transformIndex];
            const nextPoint = { x: w.a * point.x + w.b * point.y + w.e, y: w.c * point.x + w.d * point.y + w.f };
            
            encryptedData.points.push({ ...nextPoint, r, g, b });
            
            const cp = { x: (nextPoint.x + 2.5) * (canvas.width / 5.2), y: canvas.height - (nextPoint.y * (canvas.height / 10.0)) };
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(cp.x, cp.y, 1, 1);
            point = nextPoint;
        }

        updateProgress(endBitIndex / 26, bitStream.length / 26, 'Encrypting');

        if (endBitIndex < bitStream.length) {
            currentProcess = requestAnimationFrame(() => processEncryptionChunk(bitStream, endBitIndex, point));
        } else {
            statusEl.textContent = 'Encryption complete.';
            setProcessingState(false);
        }
    }

    function startDecryption() {
        if (encryptedData.points.length === 0) { alert("No data to decrypt."); return; }
        setProcessingState(true);
        updateIfsFromUI();
        processDecryptionChunk(0, { x: 0, y: 0 }, '');
    }

    function processDecryptionChunk(pointIndex, currentPoint, bitStream) {
        if (cancelRequested) { setProcessingState(false); return; }
        const CHUNK_SIZE = 5000;
        const endPointIndex = Math.min(pointIndex + CHUNK_SIZE, encryptedData.points.length);
        let point = currentPoint;
        let stream = bitStream;
        let success = true;

        for (let i = pointIndex; i < endPointIndex; i++) {
            const targetPoint = encryptedData.points[i];
            let found = false;
            for (let j = 0; j < ifs.length; j++) {
                const w = ifs[j];
                const testPoint = { x: w.a * point.x + w.b * point.y + w.e, y: w.c * point.x + w.d * point.y + w.f };
                if (Math.hypot(testPoint.x - targetPoint.x, testPoint.y - targetPoint.y) < 1e-9) {
                    stream += j.toString(2).padStart(2, '0');
                    stream += targetPoint.r.toString(2).padStart(8, '0');
                    stream += targetPoint.g.toString(2).padStart(8, '0');
                    stream += targetPoint.b.toString(2).padStart(8, '0');
                    found = true;
                    break;
                }
            }
            if (!found) { success = false; break; }
            point = { x: targetPoint.x, y: targetPoint.y };
        }
        
        updateProgress(endPointIndex, encryptedData.points.length, 'Decrypting');

        if (!success) {
            statusEl.textContent = 'Decryption failed: Key mismatch.';
            setProcessingState(false);
        } else if (endPointIndex < encryptedData.points.length) {
            currentProcess = requestAnimationFrame(() => processDecryptionChunk(endPointIndex, point, stream));
        } else {
            const bytes = [];
            for (let i = 0; i < stream.length; i += 8) {
                const byte = stream.substr(i, 8);
                if (byte.length === 8) bytes.push(parseInt(byte, 2));
            }
            const fileData = new Uint8Array(bytes);
            const blob = new Blob([fileData]);
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `decrypted-${encryptedData.originalFilename}`;
            a.click();
            URL.revokeObjectURL(a.href);
            statusEl.textContent = 'Decryption complete.';
            setProcessingState(false);
        }
    }
    
    // Event Listeners
    encryptBtn.addEventListener('click', startEncryption);
    decryptBtn.addEventListener('click', startDecryption);
    cancelBtn.addEventListener('click', () => { cancelRequested = true; });
    
    fileInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (file) fileInputText.textContent = file.name;
    });
    
    downloadPNGBtn.addEventListener('click', () => {
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = `fractal_encryption.png`;
        a.click();
    });

    loadImageBtn.addEventListener('click', () => loadImageInput.click());
    loadImageInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                setupCanvas();
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                alert("Image loaded onto canvas. Note: Direct decryption from a visual-only PNG is not possible. For full decryption, the original JSON data or a specially encoded PNG is required.");
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    generateKeyBtn.addEventListener('click', () => {
        const newTransforms = [];
        for (let i = 0; i < 4; i++) {
            newTransforms.push({
                a: (Math.random() * 2 - 1).toFixed(2), b: (Math.random() * 2 - 1).toFixed(2),
                c: (Math.random() * 2 - 1).toFixed(2), d: (Math.random() * 2 - 1).toFixed(2),
                e: (Math.random() * 4 - 2).toFixed(2), f: (Math.random() * 4 - 2).toFixed(2)
            });
        }
        createIfsEditor(newTransforms);
    });
    
    resetKeyBtn.addEventListener('click', () => createIfsEditor(BARNSLEY_FERN));
    
    importKeyBtn.addEventListener('click', () => alert('Import/Export functionality can be built here using JSON.'));
    exportKeyBtn.addEventListener('click', () => {
        updateIfsFromUI();
        const keyData = JSON.stringify({ ifs_key: ifs }, null, 2);
        const blob = new Blob([keyData], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'fractal_key.json';
        a.click();
        URL.revokeObjectURL(a.href);
    });
    
    // Init
    setupCanvas();
    createIfsEditor();
    window.addEventListener('resize', setupCanvas);
});
</script>
{% endblock %}