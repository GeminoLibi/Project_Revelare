<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Revelare: Fractal Steganography</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #121212; color: #e0e0e0; max-width: 900px; margin: 20px auto; padding: 20px; }
        .container { background-color: #1e1e1e; padding: 25px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); margin-bottom: 25px; }
        h1, h2 { color: #bb86fc; border-bottom: 2px solid #373737; padding-bottom: 10px; }
        label { display: block; margin-top: 15px; font-weight: bold; color: #cfcfcf; }
        input[type="text"], input[type="number"], textarea { width: 100%; padding: 10px; margin-top: 5px; background-color: #2c2c2c; border: 1px solid #444; border-radius: 4px; color: #e0e0e0; box-sizing: border-box; }
        textarea { resize: vertical; min-height: 120px; }
        button { background-color: #03dac6; color: #121212; border: none; padding: 12px 20px; border-radius: 4px; font-size: 16px; cursor: pointer; margin-top: 20px; transition: background-color 0.2s; }
        button:hover { background-color: #32fbe9; }
        canvas { max-width: 100%; border: 1px solid #444; margin-top: 15px; background-color: #000; }
        #downloadLink { display: none; margin-top: 15px; color: #03dac6; }
        #decryptedMessage { background-color: #2c2c2c; border: 1px solid #444; padding: 15px; margin-top: 15px; white-space: pre-wrap; word-wrap: break-word; min-height: 50px; }
        .status { margin-top: 15px; color: #f0e68c; font-style: italic; }
        .error { color: #cf6679; font-weight: bold; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
    </style>
</head>
<body>

    <h1>Revelare: Fractal Steganography Tool</h1>
    <p>Embed secret text into a Julia set fractal image. The image itself acts as the steganographic medium.</p>

    <div class="container">
        <h2>Encrypt (Embed Message)</h2>
        <label for="message">Secret Message:</label>
        <textarea id="message" placeholder="Type your secret message here..."></textarea>
        
        <div class="grid">
            <div>
                <label for="cKey">Julia Set Key (c):</label>
                <input type="text" id="cKey" value="-0.8+0.156j">
            </div>
            <div>
                <label for="width">Width:</label>
                <input type="number" id="width" value="800">
            </div>
            <div>
                <label for="height">Height:</label>
                <input type="number" id="height" value="600">
            </div>
            <div>
                <label for="iterations">Iterations:</label>
                <input type="number" id="iterations" value="300">
            </div>
        </div>
        
        <button id="encryptBtn">Generate & Embed</button>
        <div id="encryptStatus" class="status"></div>
        <canvas id="canvas"></canvas>
        <a id="downloadLink" href="#" download="stego_image.png">Download Stego Image</a>
    </div>

    <div class="container">
        <h2>Decrypt (Extract Message)</h2>
        <label for="uploadImage">Upload Stego Image:</label>
        <input type="file" id="uploadImage" accept="image/png">
        <button id="decryptBtn">Extract Message</button>
        <div id="decryptStatus" class="status"></div>
        <label for="decryptedMessage">Extracted Message:</label>
        <pre id="decryptedMessage"></pre>
    </div>

    <script>
        // --- Constants and Globals ---
        const DELIMITER_STR = "<-REVELARE_END->";
        const textEncoder = new TextEncoder();
        const textDecoder = new TextDecoder();
        const MESSAGE_DELIMITER = textEncoder.encode(DELIMITER_STR);

        // --- Core Functions ---

        /**
         * Parses a complex number string like "a+bj" into an object {re, im}.
         */
        function parseComplex(s) {
            s = s.replace(/\s/g, '');
            const match = s.match(/([+-]?\d+\.?\d*)([+-]\d+\.?\d*)j/);
            if (match) {
                return { re: parseFloat(match[1]), im: parseFloat(match[2]) };
            }
            throw new Error("Invalid complex number format. Use 'a+bj'.");
        }

        /**
         * Generates Julia set iteration data.
         */
        async function generateJuliaSet(width, height, c, maxIter) {
            const iterations = new Uint32Array(width * height);
            const x_min = -1.5, x_max = 1.5;
            const y_min = -1.5, y_max = 1.5;

            return new Promise(resolve => {
                for (let py = 0; py < height; py++) {
                    const y0 = y_min + py * (y_max - y_min) / height;
                    for (let px = 0; px < width; px++) {
                        const x0 = x_min + px * (x_max - x_min) / width;
                        let zx = x0, zy = y0;
                        let i = 0;
                        while (zx * zx + zy * zy < 4 && i < maxIter) {
                            const xtemp = zx * zx - zy * zy + c.re;
                            zy = 2 * zx * zy + c.im;
                            zx = xtemp;
                            i++;
                        }
                        iterations[py * width + px] = i;
                    }
                }
                resolve(iterations);
            });
        }

        /**
         * Colors the fractal based on iteration data and draws to canvas.
         */
        function colorizeAndDraw(ctx, iterations, width, height, maxIter) {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let i = 0; i < iterations.length; i++) {
                const iter = iterations[i];
                const idx = i * 4;
                if (iter === maxIter) {
                    data[idx] = 0; data[idx + 1] = 0; data[idx + 2] = 0; // Black
                } else {
                    data[idx] = Math.floor(9 * (1 - Math.cos(iter * 0.09)) * 127.5); // R
                    data[idx + 1] = Math.floor(9 * (1 - Math.cos(iter * 0.05)) * 127.5); // G
                    data[idx + 2] = Math.floor(9 * (1 - Math.cos(iter * 0.03)) * 127.5); // B
                }
                data[idx + 3] = 255; // Alpha
            }
            ctx.putImageData(imageData, 0, 0);
            return imageData;
        }

        /**
         * Embeds message data into the LSB of the blue channel of ImageData.
         */
        function embedData(imageData, message) {
            const messageBytes = textEncoder.encode(message);
            const dataToEmbed = new Uint8Array(messageBytes.length + MESSAGE_DELIMITER.length);
            dataToEmbed.set(messageBytes);
            dataToEmbed.set(MESSAGE_DELIMITER, messageBytes.length);

            const dataBits = [];
            dataToEmbed.forEach(byte => {
                for (let i = 7; i >= 0; i--) {
                    dataBits.push((byte >> i) & 1);
                }
            });

            const maxCapacity = imageData.data.length / 4;
            if (dataBits.length > maxCapacity) {
                throw new Error(`Message too large. Max capacity: ${Math.floor(maxCapacity/8)} bytes.`);
            }

            const stegoData = imageData.data;
            for (let i = 0; i < dataBits.length; i++) {
                const pixelIndex = i * 4;
                // Modify the blue channel (index +2)
                stegoData[pixelIndex + 2] = (stegoData[pixelIndex + 2] & 0xFE) | dataBits[i];
            }
            return imageData;
        }

        /**
         * Extracts data from the LSB of the blue channel of ImageData.
         */
        function extractData(imageData) {
            const data = imageData.data;
            const extractedBits = [];
            const delimiterBits = [];
             MESSAGE_DELIMITER.forEach(byte => {
                for (let i = 7; i >= 0; i--) {
                    delimiterBits.push((byte >> i) & 1);
                }
            });

            for (let i = 0; i < data.length; i += 4) {
                extractedBits.push(data[i + 2] & 1); // Get LSB of blue channel
                
                if (extractedBits.length >= delimiterBits.length) {
                    const tail = extractedBits.slice(-delimiterBits.length);
                    if (tail.every((val, index) => val === delimiterBits[index])) {
                        // Delimiter found
                        const messageBits = extractedBits.slice(0, -delimiterBits.length);
                        const messageBytes = new Uint8Array(messageBits.length / 8);
                        for (let j = 0; j < messageBytes.length; j++) {
                            let byte = 0;
                            for (let k = 0; k < 8; k++) {
                                byte = (byte << 1) | messageBits[j * 8 + k];
                            }
                            messageBytes[j] = byte;
                        }
                        return textDecoder.decode(messageBytes);
                    }
                }
            }
            throw new Error("Message delimiter not found in image.");
        }


        // --- Event Listeners ---
        const encryptBtn = document.getElementById('encryptBtn');
        const decryptBtn = document.getElementById('decryptBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const encryptStatus = document.getElementById('encryptStatus');
        const decryptStatus = document.getElementById('decryptStatus');

        encryptBtn.addEventListener('click', async () => {
            const message = document.getElementById('message').value;
            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);
            const iterations = parseInt(document.getElementById('iterations').value);
            const cKeyStr = document.getElementById('cKey').value;
            const downloadLink = document.getElementById('downloadLink');

            encryptStatus.textContent = "Processing...";
            encryptStatus.className = "status";
            downloadLink.style.display = 'none';
            canvas.width = width;
            canvas.height = height;

            try {
                if (!message) throw new Error("Message cannot be empty.");
                const c = parseComplex(cKeyStr);

                encryptStatus.textContent = "Generating fractal...";
                const fractalIters = await generateJuliaSet(width, height, c, iterations);
                
                encryptStatus.textContent = "Colorizing fractal...";
                const baseImageData = colorizeAndDraw(ctx, fractalIters, width, height, iterations);

                encryptStatus.textContent = "Embedding data...";
                const stegoImageData = embedData(baseImageData, message);
                
                encryptStatus.textContent = "Drawing final image...";
                ctx.putImageData(stegoImageData, 0, 0);

                downloadLink.href = canvas.toDataURL('image/png');
                downloadLink.style.display = 'block';
                encryptStatus.textContent = "Encryption complete. You can now download the image.";
            } catch (e) {
                encryptStatus.textContent = `Error: ${e.message}`;
                encryptStatus.className = "status error";
            }
        });

        decryptBtn.addEventListener('click', () => {
            const fileInput = document.getElementById('uploadImage');
            const decryptedMessageEl = document.getElementById('decryptedMessage');
            
            decryptStatus.textContent = "Processing...";
            decryptStatus.className = "status";
            decryptedMessageEl.textContent = "";

            if (fileInput.files.length === 0) {
                decryptStatus.textContent = "Error: Please select an image file.";
                decryptStatus.className = "status error";
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    try {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.width;
                        tempCanvas.height = img.height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);
                        const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
                        
                        decryptStatus.textContent = "Extracting message...";
                        const extractedMessage = extractData(imageData);
                        decryptedMessageEl.textContent = extractedMessage;
                        decryptStatus.textContent = "Extraction successful.";
                    } catch (e) {
                         decryptStatus.textContent = `Error: ${e.message}`;
                         decryptStatus.className = "status error";
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    </script>
</body>
</html>