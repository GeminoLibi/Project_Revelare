<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Encryption Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .coeff-input {
            width: 60px;
            background-color: #374151;
            color: #d1d5db;
            border: 1px solid #4b5563;
            border-radius: 0.375rem;
            padding: 0.25rem 0.5rem;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
        }
        .coeff-input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 2px #4f46e5;
        }
        .transform-grid {
            display: grid;
            grid-template-columns: auto repeat(6, 1fr);
            gap: 0.5rem;
            align-items: center;
        }
        #fileInputLabel {
            cursor: pointer;
            border: 2px dashed #4b5563;
        }
        #fileInputLabel:hover {
            border-color: #6366f1;
            background-color: #374151;
        }
        .progress-bar {
            background-color: #374151;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .progress-bar-fill {
            background-color: #4f46e5;
            height: 100%;
            transition: width 0.2s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300 antialiased">

    <div class="container mx-auto p-4 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl lg:text-4xl font-bold text-white tracking-tight">Fractal File Encryption & Compression</h1>
            <p class="text-gray-400 mt-2">Encode any file into the structure and color of an Iterated Function System (IFS) fractal.</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-8">

            <!-- Controls Panel -->
            <div class="lg:w-1/2 bg-gray-800 p-6 rounded-2xl shadow-lg border border-gray-700">
                <div class="space-y-6">
                    
                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3">1. Select Input Data</h3>
                        <label id="fileInputLabel" for="fileInput" class="w-full text-center block p-4 rounded-lg transition-colors">
                            <span id="fileInputText" class="text-gray-400">Click to select a file...</span>
                        </label>
                        <input type="file" id="fileInput" class="hidden">
                    </div>
                    
                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3">2. Encryption Key (IFS Coefficients)</h3>
                        <div id="ifs-editor" class="space-y-3"></div>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold text-white mb-3">3. Actions</h3>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4" id="action-buttons">
                            <button id="encryptBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition-colors shadow-md">Encrypt & Draw</button>
                            <button id="decryptBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-colors shadow-md">Decrypt from Canvas</button>
                            <button id="downloadBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors shadow-md">Download Encrypted</button>
                            <button id="loadBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg transition-colors shadow-md">Load & Decrypt</button>
                            <input type="file" id="loadFileInput" class="hidden" accept=".json">
                        </div>
                    </div>

                    <div id="progress-container" class="hidden space-y-2">
                        <div id="status" class="text-center text-sm text-gray-400 h-5"></div>
                        <div class="progress-bar h-2.5 w-full">
                            <div id="progress-bar-fill" class="progress-bar-fill" style="width: 0%;"></div>
                        </div>
                         <button id="cancelBtn" class="w-full mt-2 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors shadow-md">Cancel</button>
                    </div>
                    
                </div>
            </div>

            <!-- Canvas -->
            <div class="lg:w-1/2 bg-gray-800 p-2 rounded-2xl shadow-lg border border-gray-700 flex items-center justify-center">
                <canvas id="fractalCanvas" class="bg-black rounded-lg"></canvas>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        const ifsEditor = document.getElementById('ifs-editor');
        const fileInput = document.getElementById('fileInput');
        const fileInputText = document.getElementById('fileInputText');
        
        const actionButtonsContainer = document.getElementById('action-buttons');
        const encryptBtn = document.getElementById('encryptBtn');
        const decryptBtn = document.getElementById('decryptBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const loadBtn = document.getElementById('loadBtn');
        const loadFileInput = document.getElementById('loadFileInput');
        
        const progressContainer = document.getElementById('progress-container');
        const statusEl = document.getElementById('status');
        const progressBarFill = document.getElementById('progress-bar-fill');
        const cancelBtn = document.getElementById('cancelBtn');

        // --- Global State ---
        let ifs = [];
        let encryptedData = { originalFilename: 'untitled', points: [] };
        let currentProcess = null; // To hold the animation frame ID for cancellation
        let cancelRequested = false;

        const CHUNK_SIZE = 5000; // Process 5000 points per frame
        const START_POINT = { x: 0, y: 0 };
        const DECRYPTION_EPSILON = 1e-9;
        const BARNSLEY_FERN = [
            { a: 0,    b: 0,     c: 0,     d: 0.16,  e: 0, f: 0 },
            { a: 0.85, b: 0.04,  c: -0.04, d: 0.85,  e: 0, f: 1.60 },
            { a: 0.20, b: -0.26, c: 0.23,  d: 0.22,  e: 0, f: 1.60 },
            { a: -0.15,b: 0.28,  c: 0.26,  d: 0.24,  e: 0, f: 0.44 }
        ];

        // --- UI & State Management ---
        function setProcessingState(isProcessing) {
            if (isProcessing) {
                actionButtonsContainer.classList.add('hidden');
                progressContainer.classList.remove('hidden');
                cancelRequested = false;
            } else {
                actionButtonsContainer.classList.remove('hidden');
                progressContainer.classList.add('hidden');
                if (currentProcess) {
                    cancelAnimationFrame(currentProcess);
                    currentProcess = null;
                }
            }
        }

        function updateProgress(processed, total, task) {
            const percentage = total > 0 ? (processed / total) * 100 : 0;
            statusEl.textContent = `${task}: ${Math.round(percentage)}% (${processed}/${total})`;
            progressBarFill.style.width = `${percentage}%`;
        }
        
        // --- Canvas & IFS UI Setup ---
        function setupCanvas() {
            const size = Math.min(canvas.parentElement.clientWidth, 600);
            canvas.width = size;
            canvas.height = size;
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function createIfsEditor() {
            ifsEditor.innerHTML = '';
            const header = document.createElement('div');
            header.className = 'transform-grid text-xs text-gray-400 font-semibold';
            header.innerHTML = `<span></span><span>a</span><span>b</span><span>c</span><span>d</span><span>e</span><span>f</span>`;
            ifsEditor.appendChild(header);
            BARNSLEY_FERN.forEach((transform, i) => {
                const row = document.createElement('div');
                row.className = 'transform-grid';
                row.innerHTML = `<span class="font-bold text-indigo-400">w<sub>${i + 1}</sub></span>` + 
                                Object.keys(transform).map(param => 
                                `<input type="number" step="0.01" class="coeff-input" data-param="${param}" value="${transform[param]}">`
                                ).join('');
                ifsEditor.appendChild(row);
            });
        }
        
        // --- Core Logic (Data Conversion & Transforms) ---
        function updateIfsFromUI() {
            ifs = [];
            const rows = ifsEditor.querySelectorAll('.transform-grid:not(:first-child)');
            rows.forEach(row => {
                const transform = {};
                row.querySelectorAll('input').forEach(input => {
                    transform[input.dataset.param] = parseFloat(input.value);
                });
                ifs.push(transform);
            });
        }
        
        const dataToBitStream = buffer => new Uint8Array(buffer).reduce((acc, byte) => acc + byte.toString(2).padStart(8, '0'), '');
        const bitStreamToData = bitStream => {
            const bytes = [];
            for (let i = 0; i < bitStream.length; i += 8) {
                const byte = bitStream.substr(i, 8);
                if (byte.length === 8) bytes.push(parseInt(byte, 2));
            }
            return new Uint8Array(bytes);
        };
        
        const applyTransform = (w, p) => ({ x: w.a * p.x + w.b * p.y + w.e, y: w.c * p.x + w.d * p.y + w.f });
        const mapToCanvas = p => ({ x: (p.x + 2.5) * (canvas.width / 5.2), y: canvas.height - (p.y * (canvas.height / 10.0)) });
        const drawPoint = (p, color) => {
            const cp = mapToCanvas(p);
            ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
            ctx.fillRect(cp.x, cp.y, 1.5, 1.5);
        };
        
        // --- Asynchronous Encryption ---
        function startEncryption() {
            const file = fileInput.files[0];
            if (!file) {
                alert("Please select a file first.");
                return;
            }
            
            setProcessingState(true);
            updateProgress(0, file.size, 'Reading file');

            const reader = new FileReader();
            reader.onload = (e) => {
                let bitStream = dataToBitStream(e.target.result);
                const remainder = bitStream.length % 26;
                if (remainder !== 0) bitStream += '0'.repeat(26 - remainder);
                
                setupCanvas();
                encryptedData = { originalFilename: file.name, points: [] };
                updateIfsFromUI();
                
                processEncryptionChunk(bitStream, 0, START_POINT);
            };
            reader.readAsArrayBuffer(file);
        }

        function processEncryptionChunk(bitStream, bitIndex, currentPoint) {
            if (cancelRequested) {
                statusEl.textContent = 'Encryption cancelled.';
                setProcessingState(false);
                return;
            }

            const endBitIndex = Math.min(bitIndex + (CHUNK_SIZE * 26), bitStream.length);
            let point = currentPoint;

            for (let i = bitIndex; i < endBitIndex; i += 26) {
                const transformIndex = parseInt(bitStream.substr(i, 2), 2);
                const r = parseInt(bitStream.substr(i + 2, 8), 2);
                const g = parseInt(bitStream.substr(i + 10, 8), 2);
                const b = parseInt(bitStream.substr(i + 18, 8), 2);

                const nextPoint = applyTransform(ifs[transformIndex], point);
                encryptedData.points.push({ ...nextPoint, r, g, b });
                drawPoint(nextPoint, { r, g, b });
                point = nextPoint;
            }

            updateProgress(endBitIndex / 26, bitStream.length / 26, 'Encrypting');

            if (endBitIndex < bitStream.length) {
                currentProcess = requestAnimationFrame(() => processEncryptionChunk(bitStream, endBitIndex, point));
            } else {
                statusEl.textContent = 'Encryption complete.';
                setProcessingState(false);
            }
        }
        
        // --- Asynchronous Decryption ---
        function startDecryption() {
            if (encryptedData.points.length === 0) {
                alert("No encrypted data to decrypt. Encrypt or load a file first.");
                return;
            }
            setProcessingState(true);
            updateIfsFromUI();
            processDecryptionChunk(0, START_POINT, '');
        }

        function processDecryptionChunk(pointIndex, currentPoint, bitStream) {
            if (cancelRequested) {
                statusEl.textContent = 'Decryption cancelled.';
                setProcessingState(false);
                return;
            }
            
            const endPointIndex = Math.min(pointIndex + CHUNK_SIZE, encryptedData.points.length);
            let point = currentPoint;
            let stream = bitStream;
            let success = true;

            for (let i = pointIndex; i < endPointIndex; i++) {
                const targetPoint = encryptedData.points[i];
                let found = false;
                for (let j = 0; j < ifs.length; j++) {
                    const testPoint = applyTransform(ifs[j], point);
                    if (Math.hypot(testPoint.x - targetPoint.x, testPoint.y - targetPoint.y) < DECRYPTION_EPSILON) {
                        stream += j.toString(2).padStart(2, '0');
                        stream += targetPoint.r.toString(2).padStart(8, '0');
                        stream += targetPoint.g.toString(2).padStart(8, '0');
                        stream += targetPoint.b.toString(2).padStart(8, '0');
                        found = true;
                        break;
                    }
                }
                if (!found) { success = false; break; }
                point = { x: targetPoint.x, y: targetPoint.y };
            }
            
            updateProgress(endPointIndex, encryptedData.points.length, 'Decrypting');

            if (!success) {
                statusEl.textContent = 'Decryption failed: Key mismatch or corruption.';
                setProcessingState(false);
            } else if (endPointIndex < encryptedData.points.length) {
                currentProcess = requestAnimationFrame(() => processDecryptionChunk(endPointIndex, point, stream));
            } else {
                const fileData = bitStreamToData(stream);
                const blob = new Blob([fileData]);
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `decrypted-${encryptedData.originalFilename}`;
                a.click();
                URL.revokeObjectURL(a.href);
                statusEl.textContent = 'Decryption complete. File downloaded.';
                setProcessingState(false);
            }
        }

        // --- File Handling ---
        const handleFileSelect = e => fileInputText.textContent = e.target.files[0] ? e.target.files[0].name : "Click to select a file...";
        
        function downloadEncryptedFile() {
            if (encryptedData.points.length === 0) {
                alert("Nothing to download."); return;
            }
            const blob = new Blob([JSON.stringify(encryptedData)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${encryptedData.originalFilename}.fractal.json`;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function loadAndDecryptFile(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    encryptedData = JSON.parse(ev.target.result);
                    if (!encryptedData.points || !encryptedData.originalFilename) throw new Error("Invalid format");
                    setupCanvas();
                    encryptedData.points.forEach(p => drawPoint(p, p));
                    startDecryption();
                } catch {
                    alert("Error: Could not parse or validate the fractal file.");
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        // --- Initialization ---
        function init() {
            setupCanvas();
            createIfsEditor();
            setProcessingState(false);
            
            encryptBtn.addEventListener('click', startEncryption);
            decryptBtn.addEventListener('click', startDecryption);
            downloadBtn.addEventListener('click', downloadEncryptedFile);
            loadBtn.addEventListener('click', () => loadFileInput.click());
            cancelBtn.addEventListener('click', () => { cancelRequested = true; });
            fileInput.addEventListener('change', handleFileSelect);
            loadFileInput.addEventListener('change', loadAndDecryptFile);
            window.addEventListener('resize', setupCanvas);
        }
        
        init();
    });
    </script>
</body>
</html>